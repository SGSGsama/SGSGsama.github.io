<!doctype html>
<html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>SGSG&#039;s Blog</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="SGSG&#039;s Blog"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="SGSG&#039;s Blog"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta property="og:type" content="blog"><meta property="og:title" content="SGSG&#039;s Blog"><meta property="og:url" content="https://sgsgsama.github.io/"><meta property="og:site_name" content="SGSG&#039;s Blog"><meta property="og:locale" content="en_US"><meta property="og:image" content="https://sgsgsama.github.io/img/og_image.png"><meta property="article:author" content="SGSG"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="https://sgsgsama.github.io/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://SGSGsama.github.io"},"headline":"SGSG's Blog","image":["https://sgsgsama.github.io/img/og_image.png"],"author":{"@type":"Person","name":"SGSG"},"publisher":{"@type":"Organization","name":"SGSG's Blog","logo":{"@type":"ImageObject","url":"https://sgsgsama.github.io/img/logo.svg"}},"description":""}</script><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link data-pjax rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@11.7.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.lug.ustc.edu.cn/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link data-pjax rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="SGSG&#039;s Blog" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Github" href="https://github.com/SGSGsama"><i class="fab fa-github"></i></a><a class="navbar-item search" title="Search" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2025-03-24T10:49:06.000Z" title="2025/3/24 18:49:06">2025-03-24</time></span><span class="level-item">Updated&nbsp;<time dateTime="2025-04-03T12:57:07.741Z" title="2025/4/3 20:57:07">2025-04-03</time></span><span class="level-item"><a class="link-muted" href="/categories/Development/">Development</a></span><span class="level-item">8 minutes read (About 1260 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/development/kotlin_beginer/">kotlin备忘录速记</a></p><div class="content"><p>记录一些速查的kotlin高频函数和API，省的太久不写忘了</p>
<h4 id="定义约定"><a href="#定义约定" class="headerlink" title="定义约定"></a>定义约定</h4><h5 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h5><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> Name : Type = initVal</span><br></pre></td></tr></table></figure>
<h5 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h5><p>var Name : Type &#x3D; initVal</p>
<h5 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h5><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">override</span>... 修饰符) <span class="function"><span class="keyword">fun</span> <span class="title">Name</span> <span class="params">(para:<span class="type">paraType</span> = deafultVal)</span></span> : <span class="keyword">return</span> Type&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="可为null"><a href="#可为null" class="headerlink" title="可为null"></a>可为null</h5><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> Name : Type? = initVal/<span class="literal">null</span></span><br><span class="line"><span class="comment">// 如果显式设置了类型,只有类型名后加?才可设为null</span></span><br><span class="line"></span><br><span class="line">Name!!.member <span class="comment">// !!后缀表示断言该量一定不为null</span></span><br><span class="line">              <span class="comment">// 条件表达式也可以智能推断是否为null</span></span><br><span class="line">              <span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> Name : Type = <span class="literal">null</span>?:deafultVal</span><br><span class="line"><span class="comment">// ?:是 Elvis运算符，当运算符左侧的值为null时返回运算符右侧设置的默认值</span></span><br></pre></td></tr></table></figure>

<h5 id="类"><a href="#类" class="headerlink" title="类"></a>类</h5><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 主构造函数，参数前加val/var则无需在类主体中再次定义该成员</span></span><br><span class="line"><span class="comment">// open说明该类可被继承</span></span><br><span class="line"><span class="comment">// 父类的构造函数的调用接在主构造函数后</span></span><br><span class="line"><span class="comment">// 实现的接口接在父构造函数后，用逗号链接</span></span><br><span class="line">(<span class="keyword">open</span>) <span class="keyword">class</span> <span class="title class_">Name</span>(<span class="keyword">val</span> member:Type,...) : FatherClassConstructor(para),<span class="keyword">interface</span>&#123;</span><br><span class="line">    <span class="keyword">val</span> member = initVal</span><br><span class="line">    <span class="keyword">get</span>()</span><br><span class="line">    <span class="keyword">set</span>() </span><br><span class="line">    <span class="comment">// get,set为内置关键字，可选，紧跟在对应成员后</span></span><br><span class="line">    <span class="keyword">constructor</span>(para):<span class="keyword">this</span>(para)<span class="comment">//重载构造函数，如果需要给主构造函数补参数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h5><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ClassName</span>()&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">val</span> member1 <span class="comment">// 默认修饰符，可以任意访问</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> member2 <span class="comment">// 仅可在类内部访问</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">val</span> member3 <span class="comment">// 只能被子类访问</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">val</span> member4 <span class="comment">// 只能在同一文件中被访问</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="定义委托"><a href="#定义委托" class="headerlink" title="定义委托"></a>定义委托</h5><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Name <span class="keyword">by</span> delegateObject</span><br><span class="line"><span class="comment">// 把变量的getter和setter委托给自定义类(即重载变量的getter和setter)</span></span><br><span class="line"><span class="comment">// 委托类需实现ReadWriteProperty&lt;Any?, Type&gt;或ReadOnlyProperty&lt;Any?&gt;接口</span></span><br></pre></td></tr></table></figure>

<h5 id="储存函数"><a href="#储存函数" class="headerlink" title="储存函数"></a>储存函数</h5><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">myFunc</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">val</span> FunctionVal = ::myFunc <span class="comment">// 将函数作为变量存储须在函数名前加::</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="lambda"><a href="#lambda" class="headerlink" title="lambda"></a>lambda</h5><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> Name:(paraType) -&gt; returnType = &#123;</span><br><span class="line">    para -&gt; body</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 后置lambda语法</span></span><br><span class="line"><span class="comment">// myFunc(Int,Int,(Int,Int)-&gt;Int)</span></span><br><span class="line"><span class="comment">// 当函数的最后一个参数是lambda时可以在调用函数时直接把lambda写在调用后面</span></span><br><span class="line">myFunc(<span class="number">1</span>,<span class="number">2</span>)&#123;</span><br><span class="line">    x,y -&gt; x+y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> </span><br></pre></td></tr></table></figure>
<h5 id="函数数据类型约定"><a href="#函数数据类型约定" class="headerlink" title="函数数据类型约定"></a>函数数据类型约定</h5><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(paraType1,ParaType2...) -&gt; returnType</span><br></pre></td></tr></table></figure>

<h5 id="泛型-模板类-约定"><a href="#泛型-模板类-约定" class="headerlink" title="泛型(模板类)约定"></a>泛型(模板类)约定</h5><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">tempClass</span>&lt;<span class="type">T</span>&gt;(<span class="keyword">val</span> para:Type,<span class="keyword">val</span> tempPara:T)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">val</span> Name = tempClass&lt;<span class="built_in">Int</span>&gt;(para1,<span class="number">2</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="枚举类约定"><a href="#枚举类约定" class="headerlink" title="枚举类约定"></a>枚举类约定</h5><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="keyword">class</span> <span class="title class_">Name</span>&#123;</span><br><span class="line">    enumName1,enumName2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> enumNum:Name = Name.enumName1</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="数据类约定"><a href="#数据类约定" class="headerlink" title="数据类约定"></a>数据类约定</h5><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">Name</span>(<span class="keyword">val</span> value1:Type,<span class="keyword">val</span> value2:Type...)&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//专用于处理数据的类，没有任何执行操作的方法</span></span><br><span class="line"><span class="comment">//编译器会自动实现equals()，hashCode()，toString()，componentN()：component1()、component2() ... ，copy()这些方法</span></span><br></pre></td></tr></table></figure>
<h5 id="单例对象约定"><a href="#单例对象约定" class="headerlink" title="单例对象约定"></a>单例对象约定</h5><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">object</span> Name&#123;</span><br><span class="line">&#125;</span><br><span class="line">和类相同，但是全局只存在一个实例，且无须自己创建，必须在定义时就初始化</span><br></pre></td></tr></table></figure>

<h5 id="定义拓展属性"><a href="#定义拓展属性" class="headerlink" title="定义拓展属性"></a>定义拓展属性</h5><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">val</span> typeName.extendPropertyName : dataType</span><br><span class="line"><span class="keyword">get</span>()<span class="comment">//为拓展属性设置getter</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> typeName.<span class="title">extendFunctionName</span><span class="params">(para...)</span></span> : returnType&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//拓展属性只能读取不能写入</span></span><br></pre></td></tr></table></figure>
<h5 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h5><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">InterfaceName</span>&#123;</span><br><span class="line">    <span class="keyword">val</span> member:Type</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">function</span><span class="params">(para)</span></span>:<span class="keyword">return</span> Type</span><br><span class="line">    <span class="comment">//接口只声明不实现，继承接口的类必须实现接口声明的所有内容(override)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="分支约定"><a href="#分支约定" class="headerlink" title="分支约定"></a>分支约定</h4><h5 id="if-else"><a href="#if-else" class="headerlink" title="if-else"></a>if-else</h5><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(condition)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="when"><a href="#when" class="headerlink" title="when"></a>when</h5><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">when</span>(para)&#123;</span><br><span class="line">    condition1 -&gt; &#123;body1&#125;</span><br><span class="line">    condition2 -&gt; &#123;body2&#125;</span><br><span class="line">    .....</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="特殊约定"><a href="#特殊约定" class="headerlink" title="特殊约定"></a>特殊约定</h4><h5 id="分支，lambda返回值"><a href="#分支，lambda返回值" class="headerlink" title="分支，lambda返回值"></a>分支，lambda返回值</h5><p>分支,lambda的最后一个表达式的值会作为整个结构的返回值</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">x= <span class="keyword">if</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">    <span class="string">&quot;1&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="string">&quot;0&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// x=&quot;1&quot;</span></span><br><span class="line"></span><br><span class="line">x=&#123;<span class="number">2</span>&#125; <span class="comment">// x=2</span></span><br></pre></td></tr></table></figure>
<h5 id="字符串中嵌入表达式"><a href="#字符串中嵌入表达式" class="headerlink" title="字符串中嵌入表达式"></a>字符串中嵌入表达式</h5><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;x= <span class="subst">$&#123;x.value&#125;</span>&quot;</span></span><br></pre></td></tr></table></figure>
<p>使用${}向字符串嵌入表达式</p>
<h4 id="帮手函数"><a href="#帮手函数" class="headerlink" title="帮手函数"></a>帮手函数</h4><h5 id="repeat-times-Int-action-Int-Unit"><a href="#repeat-times-Int-action-Int-Unit" class="headerlink" title="repeat(times: Int, action: (Int) -&gt; Unit)"></a>repeat(times: Int, action: (Int) -&gt; Unit)</h5><p>重复执行某一操作，传入一个lambda，有一个从0开始的迭代器参数</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">repeat(<span class="number">5</span>)&#123;</span><br><span class="line">    it -&gt; println(it)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 4</span></span><br></pre></td></tr></table></figure>
<h5 id="let"><a href="#let" class="headerlink" title="let()"></a>let()</h5><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//before let</span></span><br><span class="line">println(Obj.member1)</span><br><span class="line">println(Obj.member2)</span><br><span class="line">println(Obj.member3)</span><br><span class="line"></span><br><span class="line"><span class="comment">// after let</span></span><br><span class="line">Obj.let&#123;</span><br><span class="line">    println(it.member1)</span><br><span class="line">    println(it.member2)</span><br><span class="line">    println(it.member3)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>let后接一个lambda函数，可以把let前的对象用it关键字简写<br>lambda 最后一条语句的返回值会被作为let的返回值</p>
<h5 id="apply"><a href="#apply" class="headerlink" title="apply()"></a>apply()</h5><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Obj.apply&#123;</span><br><span class="line">    <span class="keyword">this</span>.member= ....</span><br><span class="line">    <span class="keyword">this</span>.initFunc()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// hint : 可以实现链式调用</span></span><br><span class="line">Obj.apply&#123;</span><br><span class="line">    member1 = ...</span><br><span class="line">&#125;.apply&#123;</span><br><span class="line">    member2 = ...</span><br><span class="line">&#125;.....</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>对目标对象做一系列操作，通过this访问目标对象，返回操作完的目标对象</p>
<h5 id="forEach-action-T-Unit"><a href="#forEach-action-T-Unit" class="headerlink" title="forEach(action: (T) -&gt; Unit)"></a>forEach(action: (T) -&gt; Unit)</h5><p>forEach传入一个lambda，对目标集(List,set…)中的每一个元素执行该lambda</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> test1=setOf(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>)</span><br><span class="line">   test1.forEach&#123;</span><br><span class="line">       println(it)</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">// 1,2,3,4,5</span></span><br></pre></td></tr></table></figure>

<h5 id=""><a href="#" class="headerlink" title=""></a></h5><h4 id="数据管理"><a href="#数据管理" class="headerlink" title="数据管理"></a>数据管理</h4><h5 id="数组-array"><a href="#数组-array" class="headerlink" title="数组 array"></a>数组 array</h5><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> array = arrayOf&lt;Type&gt;(elem1,elem2,....) <span class="comment">// 使用arrayOf初始化，单一类型，长度不可变</span></span><br><span class="line">println(array[<span class="number">0</span>]) <span class="comment">// 使用下标访问</span></span><br><span class="line"><span class="keyword">val</span> arrry12 = array1+array2 <span class="comment">//拼接两个数组</span></span><br></pre></td></tr></table></figure>

<h5 id="列表-可变长数组-list"><a href="#列表-可变长数组-list" class="headerlink" title="列表(可变长数组) list"></a>列表(可变长数组) list</h5><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> aList=listOf(<span class="number">1</span>,<span class="number">2</span>,<span class="literal">true</span>,<span class="string">&quot;123&quot;</span>) <span class="comment">// 使用listOf初始化，可以混合类型，不可修改元素，不可增减元素</span></span><br><span class="line">println(aList.size) <span class="comment">// 查询长度</span></span><br><span class="line">println(aList[<span class="number">0</span>]) <span class="comment">// 下标访问</span></span><br><span class="line">println(aList.indexOf(<span class="string">&quot;123))　// 3 ,若未找到返回-1</span></span><br><span class="line"><span class="string">for (elem in aList) &#123;</span></span><br><span class="line"><span class="string">    // 使用 for 遍历</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">anotherList=mutableListOf(1,2,true,&quot;</span><span class="number">123</span><span class="string">&quot;) // 可修改的列表</span></span><br><span class="line"><span class="string">anotherList.add(&quot;</span><span class="number">4</span><span class="string">&quot;) // [1,2,true,&quot;</span><span class="number">123</span><span class="string">&quot;,&quot;</span><span class="number">4</span><span class="string">&quot;] //向末尾添加元素</span></span><br><span class="line"><span class="string">anotherList.add(2,&quot;</span><span class="number">4</span><span class="string">&quot;) // [1,2,&quot;</span><span class="number">4</span><span class="string">&quot;,true,&quot;</span><span class="number">123</span><span class="string">&quot;,&quot;</span><span class="number">4</span><span class="string">&quot;]  // 向中间插入</span></span><br><span class="line"><span class="string">anotherList.removeAt(0) // [2,&quot;</span><span class="number">4</span><span class="string">&quot;,true,&quot;</span><span class="number">123</span><span class="string">&quot;,&quot;</span><span class="number">4</span><span class="string">&quot;]   // 按下标删除</span></span><br><span class="line"><span class="string">anotherList.remove(&quot;</span><span class="number">123</span><span class="string">&quot;) // [2,&quot;</span><span class="number">4</span><span class="string">&quot;,true,&quot;</span><span class="number">4</span><span class="string">&quot;] // 按值删除</span></span><br><span class="line"><span class="string">anotherList.contains(2) //查询是否存在</span></span><br><span class="line"><span class="string">2 in anotherList // 前者的另一写法</span></span><br></pre></td></tr></table></figure>

<h5 id="集合-set"><a href="#集合-set" class="headerlink" title="集合 set"></a>集合 set</h5><p>Set &#x2F; mutableSet 同样 不可修&#x2F;可修</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> aSet=mutableSetOf(<span class="string">&quot;123&quot;</span>,<span class="literal">true</span>,<span class="number">32</span>)</span><br><span class="line"><span class="comment">// 有add，remove，contain，size，没有下标操作</span></span><br><span class="line"><span class="comment">// 基于每个类的hashCode()实现</span></span><br></pre></td></tr></table></figure>
<h5 id="映射-map"><a href="#映射-map" class="headerlink" title="映射 map"></a>映射 map</h5><p>Map &#x2F; mutableMap 同样 不可修&#x2F;可修</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> aMap=mutableMapOf(</span><br><span class="line">    <span class="string">&quot;cake&quot;</span> to <span class="number">10</span>,</span><br><span class="line">    <span class="string">&quot;cookie&quot;</span> to <span class="number">5</span>,</span><br><span class="line">	<span class="literal">true</span> to <span class="number">22</span></span><br><span class="line">)</span><br><span class="line">println(aMap[<span class="string">&quot;cake&quot;</span>]) <span class="comment">// 10 通过key访问value，不存在的key会返回null</span></span><br><span class="line"><span class="comment">// 有size属性</span></span><br></pre></td></tr></table></figure>
<h5 id="-1"><a href="#-1" class="headerlink" title=""></a></h5><h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><p><a target="_blank" rel="noopener" href="https://developer.android.com/courses/android-basics-compose/course">https://developer.android.com/courses/android-basics-compose/course</a></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2025-03-20T12:15:54.000Z" title="2025/3/20 20:15:54">2025-03-20</time></span><span class="level-item">Updated&nbsp;<time dateTime="2025-03-20T12:20:59.127Z" title="2025/3/20 20:20:59">2025-03-20</time></span><span class="level-item"><a class="link-muted" href="/categories/%E6%9D%82%E9%A1%B9/">杂项</a></span><span class="level-item">an hour read (About 10383 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/%E6%9D%82%E9%A1%B9/acm-log/">ACM刷题日记</a></p><div class="content"><p>想起来去年还在打acm的时候写了一段时间的做题日记，索性放到博客上好了</p>
<h4 id="CF1898D-Milena-and-Admirer"><a href="#CF1898D-Milena-and-Admirer" class="headerlink" title="CF1898D   Milena and Admirer"></a>CF1898D   Milena and Admirer</h4><h5 id="贪心-绝对值图像化思想"><a href="#贪心-绝对值图像化思想" class="headerlink" title="贪心   绝对值图像化思想"></a>贪心   绝对值图像化思想</h5><p>把$ a_i $，$b_i$抽象成<strong>线段</strong>的端点，|$a_i-b_i$|表示线段长，操作等同于交换两个线段的端点，通过分类讨论求每种情况下产生的贡献</p>
<h4 id="CF1901B-Chip-and-Ribbon"><a href="#CF1901B-Chip-and-Ribbon" class="headerlink" title="CF1901B  Chip and Ribbon"></a>CF1901B  Chip and Ribbon</h4><h5 id="思维"><a href="#思维" class="headerlink" title="思维"></a>思维</h5><p>还算有趣的题，推一下发现每次操作的贡献是<strong>当前段数</strong> * <strong>当前剩下的最小的数</strong>，如果是第一次操作则后者<strong>减一</strong>，对于维护段数，考虑对于每个数存它出现的位置，如果删除时左右都有数则标记段数++，如果左右都空则标记段数–</p>
<h4 id="CF1901C-Add，-Divide-and-Floor"><a href="#CF1901C-Add，-Divide-and-Floor" class="headerlink" title="CF1901C  Add， Divide and Floor"></a>CF1901C  Add， Divide and Floor</h4><h5 id="推式子找规律"><a href="#推式子找规律" class="headerlink" title="推式子找规律"></a>推式子找规律</h5><p>让整个序列都相同等价于把最大的和最小的变成相同的<br>假设每次选一个满足$minn \leq x \leq maxn$的x<br>$\Delta maxn&#x3D;\lvert \frac{maxn-x}{2}\rvert&#x3D; \frac{maxn-x}{2}$<br>$\Delta minn&#x3D;\lvert \frac{minn-x}{2}\rvert&#x3D; \frac{x-minn}{2}$</p>
<p>发现如果不考虑精度误差则x可以任意选，考虑精度误差，发现当maxn为奇数，minn为偶数时，选x为偶数可以使maxn下降更快，minn上升更快，反之同理</p>
<h4 id="CF1901D-Yet-Another-Monster-Fight"><a href="#CF1901D-Yet-Another-Monster-Fight" class="headerlink" title="CF1901D Yet Another Monster Fight"></a>CF1901D Yet Another Monster Fight</h4><h5 id="思维-1"><a href="#思维-1" class="headerlink" title="思维"></a>思维</h5><p>意外的简单，不知道为啥场切人数那么少<br>显然对于每一个$a_j$，答案最差的情况是在到达$a_j$左侧或右侧某个很大的点$a_i$之前多走弯路(浪费威力最多)，可以对这个大点$a_i$按在$a_j$的左侧或是右侧分类讨论，通过手模发现，结果为$ans_{a_j}&#x3D;max\begin{cases}  n-i+a_i ，\quad i &lt; j \ i+a_i，\quad i &gt;j \ a_j\end{cases}$<br>直接开两个multiset L，R，j从左向右扫，每次删掉一个右边的，增加一个左边的，对于每个j统计答案取min即可</p>
<h4 id="数论涉及多个gcd求和-CF1900D"><a href="#数论涉及多个gcd求和-CF1900D" class="headerlink" title="数论涉及多个gcd求和 CF1900D"></a>数论涉及多个gcd求和 CF1900D</h4><p>有可能是欧拉反演，但是不想学数论</p>
<h4 id="CF1900E-Transitive-Graph"><a href="#CF1900E-Transitive-Graph" class="headerlink" title="CF1900E Transitive Graph"></a>CF1900E Transitive Graph</h4><h5 id="图论tarjan"><a href="#图论tarjan" class="headerlink" title="图论tarjan"></a>图论tarjan</h5><p>对于随便一个环(强连通分量)，按题意会连成一个完全图，也就是说在这个块里可以任意走<br>要走长度最长且点权和最小的路，因为上面的条件所以随便一个强连通分量我们都可以一笔画走完，显然能走就走是最优的，tarjan跑完写个拓扑跑类似最长路的dp即可</p>
<p>####CF1896A Jagged Swaps</p>
<h5 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h5><p>$a_1&#x3D;1$就是合法的，手模得出</p>
<h4 id="CF1896B-AB-Flipping"><a href="#CF1896B-AB-Flipping" class="headerlink" title="CF1896B AB Flipping"></a>CF1896B AB Flipping</h4><h5 id="结论-1"><a href="#结论-1" class="headerlink" title="结论"></a>结论</h5><p>同样有趣的题，手模发现原序列去掉前导B和后导A后每个点都可以操作(后面的B可以被一路换到前面去)，固答案为$max \lbrace   0，len-1    \rbrace$</p>
<h4 id="CF1896D-Ones-and-Twos"><a href="#CF1896D-Ones-and-Twos" class="headerlink" title="CF1896D Ones and Twos"></a>CF1896D Ones and Twos</h4><h5 id="结论-DS"><a href="#结论-DS" class="headerlink" title="结论+DS"></a>结论+DS</h5><p>题目里给了$a_i \in \lbrace 1，2\rbrace$是有道理的<br>对于一个左右端点都是1的子串，任意删掉一个端点的1可以改变子串和的奇偶性，连续删去两个1等价于删去一个2(无论两个1是否相连，由分类讨论得)，那么显然对于每个询问，先取出左右端点为1的最长的串L，如果$sum_L\geq v$那就合法，否则考虑$sum_L$和$v$的奇偶性，奇偶性相同就向两边凑2，不同则删去一侧的1然后取剩下侧的2，左右端点重合的情况也适用</p>
<p>用set存每个1的位置，查询时直接取set的头尾，区间和用树状数组维护</p>
<h4 id="CF1896C-Matching-Arrays"><a href="#CF1896C-Matching-Arrays" class="headerlink" title="CF1896C Matching Arrays"></a>CF1896C Matching Arrays</h4><h5 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h5><p>似乎这种题都是大的对大的小的对小的？</p>
<h4 id="constexpr预处理"><a href="#constexpr预处理" class="headerlink" title="constexpr预处理"></a>constexpr预处理</h4><p>这个关键字放在定义前可以让后面的东西在编译的时候跑，可能初始化素数表之类的挺有用的？</p>
<p>####重载运算符<br>对于二元运算符重载的时候成员函数作为左边的参数，显式操作数作为右边的参数</p>
<h4 id="move"><a href="#move" class="headerlink" title="move()"></a>move()</h4><p>a&#x3D;move(b)  把b的资源转移给a，比复制快很多，大概在滚动数组里有用</p>
<h4 id="CF1902C-Insert-and-Equalize"><a href="#CF1902C-Insert-and-Equalize" class="headerlink" title="CF1902C Insert and Equalize"></a>CF1902C Insert and Equalize</h4><h5 id="贪心-1"><a href="#贪心-1" class="headerlink" title="贪心"></a>贪心</h5><p>还算巧的贪心，选择一个数$x$使得可以通过不断加$x$让$a_{1…n+1}$相等，首先考虑$a_{1…n}$，先从小到大排序然后考虑相邻项的差值，因为只能不断加一个数这个数只能是这些差值的大公因数，不然凑不齐。然后考虑$a_{n+1}$，记之前得出的最大公因数为$g$，则$a_{n+1}$可以由$a_n$加上或减去g得到，我们优先考虑减，如果减了n次都不行就直接令$a_{n+1}&#x3D;a_n+g$，同时把{a_{1…n}}抬高g</p>
<h4 id="CF1902D-Robot-Queries"><a href="#CF1902D-Robot-Queries" class="headerlink" title="CF1902D Robot Queries"></a>CF1902D Robot Queries</h4><h5 id="DS-前缀和"><a href="#DS-前缀和" class="headerlink" title="DS+前缀和"></a>DS+前缀和</h5><p>询问执行给定操作后是否经过指定点，先不考虑翻转，可以把经过的点做成一个前缀和，对于每个询问查询前缀和数组里是否有这个点<br>考虑翻转的情况，对于一个原本能到达的点$pre_i&#x3D;(x，y)$，我们先把它还原到翻转区间的起点，即$pre_i-(pre_i-pre_{l-1})$，然后看他翻转后是什么样，即$pre_i-(pre_i-pre_{l-1})+(pre_r-pre_{i-1})$<br>如果这个反转后到达的点就是所求的$P&#x3D;(x，y)$，那么整理下得出$pre_{i-1}&#x3D;pre_{l-1}+pre_r-P$，所以对于翻转过的区间，我们只要在$[l-1，r-1]$里找是否有符合条件的$pre_{i-1}$即可，对于正常的区间就在$[0，l-1]，[r+1，n]$里找是否有询问的点$P$即可，显然翻转后对于翻转区间外的点是没影响的。<br>找点的具体实现用线段树套set，线段树的每个节点上开一个set，添加点就一路insert到叶子，查的时候合并各区间答案即可</p>
<h4 id="CF1907B-YetnotherrokenKeoard"><a href="#CF1907B-YetnotherrokenKeoard" class="headerlink" title="CF1907B YetnotherrokenKeoard"></a>CF1907B YetnotherrokenKeoard</h4><h5 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h5><p>签到题，分大小写开两个栈即可</p>
<h4 id="CF1907C-Removal-of-Unattractive-Pairs"><a href="#CF1907C-Removal-of-Unattractive-Pairs" class="headerlink" title="CF1907C Removal of Unattractive Pairs"></a>CF1907C Removal of Unattractive Pairs</h4><h5 id="贪心-2"><a href="#贪心-2" class="headerlink" title="贪心"></a>贪心</h5><p>发现最后肯定只剩一个字母了，而且那个字母肯定是数量最多的，根据出现次数最多的字母的数量和n的大小分类讨论即可</p>
<h4 id="CF1907D-Jumping-Through-Segments"><a href="#CF1907D-Jumping-Through-Segments" class="headerlink" title="CF1907D Jumping Through Segments"></a>CF1907D Jumping Through Segments</h4><h5 id="二分"><a href="#二分" class="headerlink" title="二分"></a>二分</h5><p>二分答案，在check的过程中维护每次能到达的点的区间$[a，b]_n$，显然这个$[a，b]<em>n$的更新可以通过分类讨论$[a，b]</em>{n-1}$与$[l_n，r_n]$的相交情况实现，如果不相交就说明k非法</p>
<h4 id="CF1907F-Shift-and-Reverse"><a href="#CF1907F-Shift-and-Reverse" class="headerlink" title="CF1907F Shift and Reverse"></a>CF1907F Shift and Reverse</h4><h5 id="哈希-结论"><a href="#哈希-结论" class="headerlink" title="哈希+结论"></a>哈希+结论</h5><p>首先这道题要知道只有以下几种情况可能是最优的：<br>1.一直往前翻<br>2.翻转然后一直往前翻<br>3.翻转一直往前翻然后翻回来<br>4.一直往前翻最后翻转<br>这四种情况1，4等价于把后面的搬到前面去，2，3等价于把前面的搬到后面，然后最后的结果是使序列变成递增或递减的<br>然后我们把原序列复制一遍放在后面，这样扫过去就可以直接得到所有我们可能通过操作产生的序列，然后操作数可以直接算出来，具体通过手模找规律，然后只要扫到某个数$a_i$是最大或是最小的（可以作为单调序列的起点），我们就用哈希判断$a_{i…i+n-1}$是否和排序好的序列一样，如果一样就计算把原序列变成这样需要的最小操作数并更新答案</p>
<h4 id="set使用自定义类型"><a href="#set使用自定义类型" class="headerlink" title="set使用自定义类型"></a>set使用自定义类型</h4><p>对于自定义类型，劣质的重载&lt;会影响set的行为(大概率导致set出问题)</p>
<h4 id="CF1904B-Collecting-Game"><a href="#CF1904B-Collecting-Game" class="headerlink" title="CF1904B Collecting Game"></a>CF1904B Collecting Game</h4><h5 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h5><p>双指针板子题，排序后跑双指针即可</p>
<h4 id="CF1904D1-Set-To-Max-Easy-Version"><a href="#CF1904D1-Set-To-Max-Easy-Version" class="headerlink" title="CF1904D1 Set To Max (Easy Version)"></a>CF1904D1 Set To Max (Easy Version)</h4><h5 id="贪心-3"><a href="#贪心-3" class="headerlink" title="贪心"></a>贪心</h5><p>easy version的数据较小，直接跑$n^2$的贪心即可，hard version可能要在原做法上加一个线段树维护区间最大值<br>从小到大依次取$a_i$，然后分别向左右拓展，只要是扫到的数比$a_i$小并且比$b_i$小就可以把他设为$a_i$，最后扫一遍a看和b是否相同即可</p>
<h4 id="CF1904D2-Set-To-Max-Hard-Version"><a href="#CF1904D2-Set-To-Max-Hard-Version" class="headerlink" title="CF1904D2 Set To Max (Hard Version)"></a>CF1904D2 Set To Max (Hard Version)</h4><h5 id="贪心-RMQ"><a href="#贪心-RMQ" class="headerlink" title="贪心+RMQ"></a>贪心+RMQ</h5><p>还真是原做法随便加一个单次logn或者更优的rmq，对于一个需要set to max的$a_i$显然我们需要找到它左边或右边最近的和$b_i$相等的$a_j$，选最近可以让一次操作对其他数字的影响最小，然后用rmq查$a_{i…j}$里面是否有比$b_i$大的，$b_{i…j}$里面是否有比$b_i$小的，如果都没有显然这次操作是合法的，然后优化下easy version取数的方式，改成从小到大取$b_i$（从结果入手），总的复杂度限制在rmq初始化$nlogn$</p>
<h4 id="CF1904C-Array-Game"><a href="#CF1904C-Array-Game" class="headerlink" title="CF1904C Array Game"></a>CF1904C Array Game</h4><h5 id="分类讨论"><a href="#分类讨论" class="headerlink" title="分类讨论"></a>分类讨论</h5><p>发现对于k&gt;&#x3D;3，可以直接先选两次一样的$a_i，a_j$，然后第三次让两次的差互相减，答案肯定为0<br>对于k&#x3D;1，直接在所有的差和本来就有的数中间选一个最小的即可<br>对于k&#x3D;2，先$n^2$搞出来所有的差，然后每次在原数组中lower_bound一下去找和这个差最近的数再做差，也是把搞出来的所有数取min求答案，复杂度$n^2logn$</p>
<h4 id="后缀BIT"><a href="#后缀BIT" class="headerlink" title="后缀BIT"></a>后缀BIT</h4><p>把前缀树状数组的所有循环顺序倒过来就能实现后缀bit</p>
<h4 id="费马小定理"><a href="#费马小定理" class="headerlink" title="费马小定理"></a>费马小定理</h4><p>一个数在 mod b下关于a的逆元为 $a^{b-2}$</p>
<h4 id="CF1917B-Erase-First-or-Second-Letter"><a href="#CF1917B-Erase-First-or-Second-Letter" class="headerlink" title="CF1917B Erase First or Second Letter"></a>CF1917B Erase First or Second Letter</h4><h5 id="计数"><a href="#计数" class="headerlink" title="计数"></a>计数</h5><p>对于一个字符串，如果确定第一个和第二个字符，那就不能继续操作了，可以将最终的字符串拆分成一个后缀和一个字母组合的形式，我们可以不断进行操作2来使一个字母匹配每一个后缀，同时因为我们只能删前两个字母，所以实际上我们最多有n个不同的后缀，且长度分别为1~n，所以我们要统计对于每一个后缀，前面有多少个不同的字母可以与其组合，开一个桶计数即可，把每个后缀的答案求和就是总的答案。</p>
<h4 id="CF1917C-Watering-an-Array"><a href="#CF1917C-Watering-an-Array" class="headerlink" title="CF1917C Watering an Array"></a>CF1917C Watering an Array</h4><h5 id="贪心-4"><a href="#贪心-4" class="headerlink" title="贪心"></a>贪心</h5><p>一个重要的性质，假设a&#x3D;[0，0，…，0]，不管b的组成是什么样的，且执行几次添加操作，始终最多有1个$a_i&#x3D;i$，因为假设$a_x&#x3D;x$，那么对于$a_x$前面的所有$a_i$肯定有$a_i \geq a_x$（因为每次是对一个前缀+1），对于后面的同理，所以如果我们进行过一次reset操作，之后最优的做法一定是add一次就reset一次，总贡献为d&#x2F;2，所以问题转化成确定第一次reset的时间，注意到第一次reset最多也就产生n的贡献，所以如果我们第一次reset的时间晚于2*n+1，则一定不是最优的，即一开始最多add 2n次，直接暴力add 并统计答案取max即可，注意判断操作是否合法</p>
<h4 id="CF1917E-Construct-Matrix"><a href="#CF1917E-Construct-Matrix" class="headerlink" title="CF1917E Construct Matrix"></a>CF1917E Construct Matrix</h4><h5 id="构造"><a href="#构造" class="headerlink" title="构造"></a>构造</h5><p>非常神秘的构造，答案一半很显然，一半很不显然<br>要求构造一个n*n的矩阵m，n为偶数，要求每行的1的数量同奇或同偶，每列同奇或同偶，且总数等于k<br>首先特判，如果$k &#x3D; n^2-2 || k&#x3D;2 $，此时如果k!&#x3D;2，则无解<br>然后是对于k%4&#x3D;0的部分，显然我们可以尝试把1组合成2x2的块放进去，一个2x2的块对横纵的奇偶性都是没影响的<br>对于k%4&#x3D;2的部分(不知道怎么想到的)如果k&lt;6肯定是第一种无解的情况，当$k \geq 6$，我们先把$m_{1，1}，m_{1，2}，m_{2，1}，m_{3，3}，m_{3，2}，m_{2，3}$这六块变成1，然后剩下k-6的部分在除左上角4x4的范围继续组成2x2的块填进去，然后$k&#x3D;n^2-6$则正好会有4个1多出来，则在$m_{1，3}，m_{1，4}，m_{4，4}，m_{4，3}$四个位置填上1，对于其他的所有情况，均无解</p>
<h4 id="CF1913B-Swap-and-Delete"><a href="#CF1913B-Swap-and-Delete" class="headerlink" title="CF1913B Swap and Delete"></a>CF1913B Swap and Delete</h4><h5 id="思维，字符串"><a href="#思维，字符串" class="headerlink" title="思维，字符串"></a>思维，字符串</h5><p>定义两种操作，从s中删去任意一个字符，代价为1，任意交换一对字符，代价为0<br>记操作任意次后得到的字符串为t，问使t与s对应位置的字符均不相同的最小代价<br>因为交换是无代价的，所以只要让t的1数量和s长度为|t|的前缀的0数量相同，反之亦然即可<br>考虑直接枚举答案，显然答案最大为|s|，删完了肯定都一样了，对于每个答案n，实际上我们可以在合法的前提下任意删除总数为n的0和1，如果s里的0比t里的1多肯定这个答案是不行的，因为我们只能从t里删东西，对于每个可能成为答案的t，一定有$cnt1_t&#x3D;cnt1_{preS_|t|}$，所以我们只要对于每个可能成为答案的t，统计s的0与t的1的数量差值和s的1与t的0的数量差值，如果两个差值和与我们枚举到的答案相等，则这个答案就是合法的，从小到大枚举找的合法的就退出即可</p>
<h4 id="CF1913C-Game-with-Multiset"><a href="#CF1913C-Game-with-Multiset" class="headerlink" title="CF1913C Game with Multiset"></a>CF1913C Game with Multiset</h4><h5 id="贪心，二进制"><a href="#贪心，二进制" class="headerlink" title="贪心，二进制"></a>贪心，二进制</h5><p>很套路的题<br>往一个集合里多次插入$2^x$，多次询问集合里的数是否可以凑出w<br>显然先把w拆成二进制的形式，然后每次询问从低位向高位枚举，如果集合里这位有多的就除二借给下一位，一路枚举到头即可</p>
<h4 id="CF1913E-Matrix-Problem"><a href="#CF1913E-Matrix-Problem" class="headerlink" title="CF1913E Matrix Problem"></a>CF1913E Matrix Problem</h4><h5 id="最小费用最大流"><a href="#最小费用最大流" class="headerlink" title="最小费用最大流"></a>最小费用最大流</h5><p>板子题，出在div2E估计是科技太高了<br>发现n很小，且是约束问题，考虑网络流<br>要求$i$行要有$a_i$个1，$j$列要有$b_j$个1，可以建超级源超级汇，合法的情况就是每个$a$点有$a_i$的流量，每个$b$点有$b_j$的流量，直接从源点向每个$a$拉流量为$a_i$的边，从每个$b$向汇点拉流量为$b_i$的边，费用均为0<br>然后中间$a，b$直接拉完全图，边代表矩阵里的点，流量都是1，如果这个点本来是0，就拉费用为1的边，如果已经是1了，就拉费用为-1的边，同时先在答案里+1，表示如果这个点最终就是1，则不需要付出代价，所以费用和先加的1抵消，如果这个点最终应该是0，那这个点的流量就不会算进总流量里，也不会计算这个点的费用，按题意需要付出一点代价，而这个代价在拉边时已经加好了<br>建完图跑dinic板子即可，最后如果a，b流量都跑满且相同就是合法答案</p>
<h4 id="CF1914C-Quests"><a href="#CF1914C-Quests" class="headerlink" title="CF1914C Quests"></a>CF1914C Quests</h4><h5 id="贪心-5"><a href="#贪心-5" class="headerlink" title="贪心"></a>贪心</h5><p>显然最优答案是前i个先各做一次，然后剩下k-i次全部做b最大的那一个</p>
<h4 id="CF1914D-Three-Activities"><a href="#CF1914D-Three-Activities" class="headerlink" title="CF1914D Three Activities"></a>CF1914D Three Activities</h4><h5 id="贪心-6"><a href="#贪心-6" class="headerlink" title="贪心"></a>贪心</h5><p>假设每次我们都只选a，b，c里前三大的i，最差的情况是这三个都相同，如果随意拿掉一个a，b，c也总还有两个可以选，而且这些选的都是前三大的，答案一定是在这里面产生的，所以直接找三元组里a，b，c分别是前三大的，从这几个(3~9个)里暴力枚举答案</p>
<h4 id="CF1914E-Game-with-Marbles"><a href="#CF1914E-Game-with-Marbles" class="headerlink" title="CF1914E Game with Marbles"></a>CF1914E Game with Marbles</h4><h5 id="贪心-7"><a href="#贪心-7" class="headerlink" title="贪心"></a>贪心</h5><p>easy version直接爆搜<br>hard version这么考虑，对alice，一次操作产生的贡献是$a_i+b_i$（A取了$a_i-1$，同时B的$b_i-1$不能取了，等价于对总答案的贡献是$(a_i-1)-(b_i-1)$），发现对bob来说也是同理，所以直接按照$a_i+b_i$排序，依次取大的即可</p>
<h4 id="CF1914G1-Light-Bulbs-Easy-Version"><a href="#CF1914G1-Light-Bulbs-Easy-Version" class="headerlink" title="CF1914G1 Light Bulbs (Easy Version)"></a>CF1914G1 Light Bulbs (Easy Version)</h4><h5 id="tarjan"><a href="#tarjan" class="headerlink" title="tarjan"></a>tarjan</h5><p>这题有2100？ 不是很认可<br>mod 998244353不开long long 是存在溢出并且输出不是负数的可能性的(能开long long 尽量开)<br>发现对于一个颜色，显然如果我们先把一个灯点亮，那另一个灯也亮了，然后这两个灯之间的通过操作2也全亮了<br>把灯抽象成线段的两端，如果一条线段被另一条完全覆盖，那只要长的那条点亮就行，如果交叉覆盖，则任意点亮一条即可，考虑对于每条线段u，向他所覆盖到的所有线段v拉单向边，表示点亮u就能点亮v，这样对于完全覆盖就是只能点亮u，对于交叉覆盖就是u，v任意点亮一个，注意到这里产生了强连通的问题，把图建好后跑缩点，缩完点的图中入度为0的点的数量就是S的大小，然后显然这些入度为零的点里被压缩了颜色数*2个灯泡，用乘法原理全乘在一起就是方案数</p>
<h4 id="CF1918A-Brick-Wall"><a href="#CF1918A-Brick-Wall" class="headerlink" title="CF1918A Brick Wall"></a>CF1918A Brick Wall</h4><h5 id="贪心-8"><a href="#贪心-8" class="headerlink" title="贪心"></a>贪心</h5><p>一个砖的大小是$1<em>k$，墙的稳定性是横着的砖的数量减去竖着的砖的数量<br>显然偶数长度就直接全部$1</em>2$的砖，奇数长度就一排$1<em>3$的砖，其他的就全部继续用$1</em>2$的</p>
<h4 id="CF1918B-Minimize-Inversions"><a href="#CF1918B-Minimize-Inversions" class="headerlink" title="CF1918B Minimize Inversions"></a>CF1918B Minimize Inversions</h4><h5 id="思维-2"><a href="#思维-2" class="headerlink" title="思维"></a>思维</h5><p>给定两个序列A，B，可以同时交换$a_i，a_j和b_i，b_j$，要求输出排序后的A，B，使得其中逆序对的数量和最少<br>考虑单独的一对$a_i，a_j，b_i，b_j$可能会有0，1，2对逆序对的情况，对于0的情况，交换产生2组逆序对，对于1的情况，交换消除一组逆序对，并产生一组逆序对，对于2的情况，交换消除两组逆序对<br>发现如果对A排序，那么A中的逆序对数为0，那么对于所有的$a_i，a_j，b_i，b_j$，只会出现1和0的情况，而这两种情况无论怎么交换都无法减少逆序对的总量，所以此时总的逆序对数达到最小</p>
<h4 id="CF1918C-XOR-distance"><a href="#CF1918C-XOR-distance" class="headerlink" title="CF1918C XOR-distance"></a>CF1918C XOR-distance</h4><h5 id="思维-3"><a href="#思维-3" class="headerlink" title="思维"></a>思维</h5><p>异或问题拆位考虑<br>假设$a&gt;b$，发现如果我们搞a，b的最高位（对齐情况下），就会搞完后$a &lt; b$，那后面就没法确定怎么搞了，所以考虑不动最高位，从次高位开始搞，这样不管怎么弄都能满足$a&gt;b$，只要尽可能缩小a并增大b就行了<br>对于a，b该位都是0或1的情况显然对答案没影响<br>1：对于a是1，b是0的情况，x这位是1对答案有贡献<br>2：对于a是0，b是1的情况，x这位是0对答案有贡献<br>所以对于每一个情况1，在$x \leq r$的前提下不断将x这位置1就可得到最终的x</p>
<h4 id="CF1918D-Blocking-Elements"><a href="#CF1918D-Blocking-Elements" class="headerlink" title="CF1918D Blocking Elements"></a>CF1918D Blocking Elements</h4><h5 id="二分-单调队列-dp"><a href="#二分-单调队列-dp" class="headerlink" title="二分 单调队列 dp"></a>二分 单调队列 dp</h5><p>给定一个序列，要求通过删去元素把序列分为的几段，同时删去的元素一起作为一段，要求使所有段中和最大的最小</p>
<p>最大值最小考虑二分答案，在序列头和尾分别设两个值为0的虚点，$dp_i$表示目前到第i个元素，并删除这个元素，此时被删除元素的总和的最小值，我们每次更新$dp_i$最好是选择某一块合法区间内最小的dp值，考虑单调队列维护这个值，当队头不合法时（队头和i之间的元素和超过二分的答案），不断弹出队头，每次使用队头的值更新此时的$dp_i$，并不断弹出比$dp_i$大的队尾元素，并把i插入单调队列，只要$dp_{n+1}$比此时的答案小，就继续更新答案</p>
<h4 id="CF1921D-Very-Different-Array"><a href="#CF1921D-Very-Different-Array" class="headerlink" title="CF1921D Very Different Array"></a>CF1921D Very Different Array</h4><h5 id="贪心-9"><a href="#贪心-9" class="headerlink" title="贪心"></a>贪心</h5><p>从B里选n个作为数组A，使$A_{1…n}和C_{1…n}$对应位元素差的绝对值之和最大<br>考虑先让B里最大的对应C里最小的数，这样B里会剩下一些最小的数，同时发现这样每次产生的贡献使递减的，同时最后可能会有B中的数比C中的数小的情况，所以我们再倒着用B里最小的数去对应C里最大的数，这样每次更新答案只用变换一个位置的值，不断更新答案的最大值即可</p>
<h4 id="CF1921E-Eat-the-Chip"><a href="#CF1921E-Eat-the-Chip" class="headerlink" title="CF1921E Eat the Chip"></a>CF1921E Eat the Chip</h4><h5 id="贪心-结论"><a href="#贪心-结论" class="headerlink" title="贪心 结论"></a>贪心 结论</h5><p>Alice可以往下，左下，右下走，Bob可以往上，左上，右上走，Alice先手，问谁赢或者平局<br>贪心地想，两边同时向左，同时向右，一左一右都不影响横向距离的奇偶性，即不影响最后谁赢，只有纵向距离的奇偶性影响结果，所以纵向距离为奇数时，bob必定会考虑保平，反之同理<br>考虑保平的情况，显然游戏结束的时间时确定的，即双方纵向位置相同的时候，此时不能吃掉对方就一定平局，所以直接考虑不可能赢的那方在结束前最远能到达左边或右边的哪个位置，再看另一方能否也到达那个位置，能到达就赢，否则平局</p>
<h4 id="CF1922A-Tricky-Template"><a href="#CF1922A-Tricky-Template" class="headerlink" title="CF1922A Tricky Template"></a>CF1922A Tricky Template</h4><h5 id="贪心-10"><a href="#贪心-10" class="headerlink" title="贪心"></a>贪心</h5><p>给定一个字符串s，称满足以下条件的小写字符串t是符合题意的<br>1.如果s第i位是小写，t这一位必须和s一样<br>2.如何s第i位是大写，t这一位必须和s不一样<br>给定符合题意的字符串a，b ，和不符合题意得字符串c，问这样的t是否存在<br>如果a，b，c这一位不一样，只要让t这一位和c一样并大写即可<br>如果a，b这一位一样，和c不一样，只要让t这一位和ab一样并小写即可</p>
<h4 id="CF1922B-Forming-Triangles"><a href="#CF1922B-Forming-Triangles" class="headerlink" title="CF1922B Forming Triangles"></a>CF1922B Forming Triangles</h4><h5 id="组合数"><a href="#组合数" class="headerlink" title="组合数"></a>组合数</h5><p>给定n个木棍，第i根木棍的长度是$2^{a_i}$，问选三根木棍组成三角形有多少种方案<br>首先发现木棍的长度都是2的幂，显然想组成三角形就只能组成等边三角形，找到每种长度的棍的数量求组合数就行了</p>
<h4 id="CF1922C-Closest-Cities"><a href="#CF1922C-Closest-Cities" class="headerlink" title="CF1922C Closest Cities"></a>CF1922C Closest Cities</h4><h5 id="贪心-11"><a href="#贪心-11" class="headerlink" title="贪心"></a>贪心</h5><p>n个城市在数轴上，有两种移动方式<br>1.移动到任意城市，代价为两城市间的距离<br>2.移动到最近的城市，代价为1<br>q次询问，问从a到b的最小代价<br>发现对于每个城市，发现在只考虑往一个方向走的情况下他和离他最近的那个城市的距离可以压成1，然后显然我们每次询问肯定都是往一个方向走的<br>考虑向左和向右走两种情况分开做，预处理出新的位置，然后询问时直接位置相减算答案</p>
<h4 id="CF1922D-Berserk-Monsters"><a href="#CF1922D-Berserk-Monsters" class="headerlink" title="CF1922D Berserk Monsters"></a>CF1922D Berserk Monsters</h4><h5 id="贪心-set-链表"><a href="#贪心-set-链表" class="headerlink" title="贪心 set 链表"></a>贪心 set 链表</h5><p>每个怪物每轮会被他的邻居攻击，每轮结束时，受到的伤害大于防御的怪物会死亡，问每轮死亡的怪物数<br>每一轮结束后，如果一个怪物这一轮没有死，且他的邻居也没有死，那他下一轮也不会死（受到和这一轮一样的伤害）<br>所以我们考虑每轮结束时，把死亡的怪物加入set，显然下一轮我们只要更新这些怪物的邻居的答案就行了，更新答案的总复杂度最差为O(3n)，找邻居和删除的过程用链表实现</p>
<h4 id="CF1923A-Moving-Chips"><a href="#CF1923A-Moving-Chips" class="headerlink" title="CF1923A Moving Chips"></a>CF1923A Moving Chips</h4><h5 id="贪心-12"><a href="#贪心-12" class="headerlink" title="贪心"></a>贪心</h5><p>一个1可以被移到最左边最近的空格，问把所有1连起来的最小移动次数<br>显然删除前导0，后导0，剩下的0的数量就是我们要移动的次数</p>
<h4 id="CF1923B-Monsters-Attack"><a href="#CF1923B-Monsters-Attack" class="headerlink" title="CF1923B Monsters Attack!"></a>CF1923B Monsters Attack!</h4><h5 id="贪心-13"><a href="#贪心-13" class="headerlink" title="贪心"></a>贪心</h5><p>每秒发射k个子弹，任意分配，每发子弹造成1点伤害，数轴上n个怪物，每秒向原点移动一格，如果任意一秒结束时原点上有存活的怪物则失败，问能否杀死全部怪物<br>先把所有怪物按离原点的距离排序，考虑按秒模拟，每秒射出的总子弹数增加k，并减去这一秒到达原点的所有怪物的血量值，如果出现子弹数不够则失败</p>
<h4 id="CF1923C-Find-B"><a href="#CF1923C-Find-B" class="headerlink" title="CF1923C  Find B"></a>CF1923C  Find B</h4><h5 id="贪心-构造"><a href="#贪心-构造" class="headerlink" title="贪心 构造"></a>贪心 构造</h5><p>一个长度为m的序列a是好的当且仅当存在一个长度为m的序列b满足<br>1.a的和等于b的和<br>2.a和b每一位均不相等<br>3.b每一位都大于0<br>给定一个序列c，q次询问，每次问c的一个子段是否是好的<br>显然有一种贪心的构造法，我们考虑c的这个子段里有多少个1，对于这些1，我们构造2，对于剩下不是1的，我们全部构造1，然后如过此时总和还不够，就把少的全部任找一个2加进去，如果不能这么做则这个子段就是不是好的</p>
<h4 id="CF1923D-Slimes"><a href="#CF1923D-Slimes" class="headerlink" title="CF1923D Slimes"></a>CF1923D Slimes</h4><h5 id="贪心-二分-前缀和"><a href="#贪心-二分-前缀和" class="headerlink" title="贪心 二分 前缀和"></a>贪心 二分 前缀和</h5><p>n个史莱姆，每秒有且只有一只史莱姆吃掉一个大小严格小于他的邻居，且大小变为两者之和，n次独立询问，问每只史莱姆最早第几秒被吃掉<br>一个重要的性质，假设一个史莱姆i最终被j吃掉，而j在吃i之前一定吃了包含j的一个子段里的所有史莱姆，然后我们发现，找到j等价于找到这个子段，而这个子段一定是在i的左边或右边且与i相邻，且和正好大于i，即不用去考虑j吃掉i的具体过程，$ans_i$就是这个子段的长度，所以问题转化为对于每个i，找到他左边或右边最短的总和大于他的子段，前缀和+二分即可，总复杂度O(nlogn)</p>
<h4 id="CF1945B-Fireworks"><a href="#CF1945B-Fireworks" class="headerlink" title="CF1945B Fireworks"></a>CF1945B Fireworks</h4><h5 id="结论-2"><a href="#结论-2" class="headerlink" title="结论"></a>结论</h5><p>观察样例发现答案就是$m&#x2F;a+m&#x2F;b+2$</p>
<h4 id="CF1945C-Left-and-Right-Houses"><a href="#CF1945C-Left-and-Right-Houses" class="headerlink" title="CF1945C Left and Right Houses"></a>CF1945C Left and Right Houses</h4><h5 id="前缀和"><a href="#前缀和" class="headerlink" title="前缀和"></a>前缀和</h5><p>前缀和统计1的数量，枚举断点即可</p>
<h4 id="CF1945D-Seraphim-the-Owl"><a href="#CF1945D-Seraphim-the-Owl" class="headerlink" title="CF1945D Seraphim the Owl"></a>CF1945D Seraphim the Owl</h4><h5 id="贪心-14"><a href="#贪心-14" class="headerlink" title="贪心"></a>贪心</h5><p>假设从i交换至j，发现有两种交换途径，一种是每次只前进一格，这样每次代价为$a_{i+1}$，或者前进x格，那么代价为$\sum_{p&#x3D;i+1}^{i+x-1}b_p+a_x$，发现这两种前进方式是灵活的，如果这一步不是终点的话，我们的代价是$\min(a_i，b_i)$，因此从i交换到j的最优解是$\sum_{p&#x3D;i+1}^{j-1}\min(a_p，b_p)+a_j$，倒着累加即可</p>
<h4 id="CF1945E-Binary-Search"><a href="#CF1945E-Binary-Search" class="headerlink" title="CF1945E Binary Search"></a>CF1945E Binary Search</h4><h5 id="结论-3"><a href="#结论-3" class="headerlink" title="结论"></a>结论</h5><p>考察了二分的性质，对于我们瞎跑出来的l，可以发现有$p_l \leq x$，这是给出的描述决定的，然后发现如果我们把此时的$p_l$换成一个不大于$x$的数，显然对l的位置也没有影响<br>所以我们直接在原序列上跑题目给出的二分，然后把$x$的位置和跑出来的$l$交换即可</p>
<h4 id="CF1945F-Kirill-and-Mushrooms"><a href="#CF1945F-Kirill-and-Mushrooms" class="headerlink" title="CF1945F Kirill and Mushrooms"></a>CF1945F Kirill and Mushrooms</h4><h5 id="贪心-set"><a href="#贪心-set" class="headerlink" title="贪心 set"></a>贪心 set</h5><p>首先为了方便处理不能选的情况，把原序列按$i_{s_j}$从小到大排序<br>依次考虑选$k$的个情况<br>假设我们要选$k$个，那么最优的做法肯定是从可以选的$n-(k-1)$个里选$k$个最大的，可以考虑从选$k-1$个的情况转移来，我们考虑开两个set，把没选的扔进unselect里，选了的扔进select个里，当我们准备选第$k$个的时候，根据题意此时排序后的第$k-1$个就不能选了，如果他在unselect里，就把他删了，然后再选unslect里最大的移到select里，如果他在select里，也把他删了，再从unselect里选最大和次大的移到select里，可以发现这样单次更新答案是logn的，unselect空了就结束，每次更新答案时统计最大值即可</p>
<h4 id="gym104090M-ICPCHZ2022-M-Please-Save-Pigeland"><a href="#gym104090M-ICPCHZ2022-M-Please-Save-Pigeland" class="headerlink" title="gym104090M ICPCHZ2022 M. Please Save Pigeland"></a>gym104090M ICPCHZ2022 M. Please Save Pigeland</h4><h5 id="换根-线段树"><a href="#换根-线段树" class="headerlink" title="换根 线段树"></a>换根 线段树</h5><p>缝合怪题，给定点集$S$，要求在树上找到一个点$u$，使得$\frac{\sum dist(u，S_i)}{gcd(dist(u，S_i))}最小$<br>考虑换根，我们先求出$u$为1的情况，然后以1为根开始换根，发现我们每向经过一条边$E(u，v)$，对答案产生的影响是$v$子树内的所有特殊点的$dist$全部减去$dis_{E(u，v)}$，其余的特殊点全部加上$dis_{E(u，v)}$，考虑记录以1为根的每个点的dfs序，可以发现一个点子树内的点满足$dfn[u]\leq dfn[v] \leq dfn[u]+siz[u]-1$，可以把特殊点按dfs序排序并每次通过两次二分求左右端点的方法得到哪段是要被减去距离的，我们需要一个可以维护区间加减和区间gcd的数据结构，考虑线段树，由gcd的性质得知一个序列的gcd等同于这个序列的差分的gcd，问题转化成单点修和区间gcd，所以每次换根的时候，用线段树维护差分数组，并统计整个特殊点序列的gcd计算答案即可，总复杂度$O(nlog(n)log(V))$</p>
<h4 id="CF1956F-Nene-and-the-Passing-Game"><a href="#CF1956F-Nene-and-the-Passing-Game" class="headerlink" title="CF1956F Nene and the Passing Game"></a>CF1956F Nene and the Passing Game</h4><h5 id="set-思维"><a href="#set-思维" class="headerlink" title="set 思维"></a>set 思维</h5><p>因为能否传接球的关系是双向的，不妨设$i&gt;j$，把给定的式子化简一下，可以得到</p>
<ol>
<li>$i-l_i \geq j+l_j$</li>
<li>$i-r_i \leq j+r_j$</li>
</ol>
<p>可以在保证1式成立的前提下考虑2式，我们可以把n个人拆成权值分别为$i-l_i$和$i+l_i$的2n个点，再把这些点按权值从小到大排序，这样我们就能保证每个点对前面的所有点都满足1式，同时我们可以把权值为$i+l_i$的点视作修改，把权值为$i-l_i$的点视作询问，每当扫到前者时，我们往一个递减的set中插入该点，权值为$i+r_i$，这样当我们扫到代表询问的点x时，只要不断从set头中取出满足$x-r_x \leq i+r_i$的点i与x组成连通块，并从set中删去该点，连完后再把整个连通块的根塞回set里，最后统计连通块的数量就可以得到答案了<br>同时我们注意到，对于一个连通块，我们只要看他最大的$i+r_i$的值，所以只要把第一个取出的点作为整个连通块的根即可，因为我们保证了set中第一个取出的点一定是全局$i+r_i$值最大的</p>
<h4 id="CF1942A-Farmer-John’s-Challenge"><a href="#CF1942A-Farmer-John’s-Challenge" class="headerlink" title="CF1942A Farmer John’s Challenge"></a>CF1942A Farmer John’s Challenge</h4><h5 id="结论-4"><a href="#结论-4" class="headerlink" title="结论"></a>结论</h5><p>对于$n&#x3D;k$ 显然全部输出1就行了<br>对于$k&#x3D;1$ 显然先输出n，再依次输出1~n-1即可<br>对于$1&lt;k&lt;n$，发现一个有序序列只要平移一次一定会变成无序的，所以这些都是不可能的情况</p>
<h4 id="CF1942B-Bessie-and-MEX"><a href="#CF1942B-Bessie-and-MEX" class="headerlink" title="CF1942B Bessie and MEX"></a>CF1942B Bessie and MEX</h4><h5 id="贪心-15"><a href="#贪心-15" class="headerlink" title="贪心"></a>贪心</h5><p>由于mex和排列的性质，考虑倒着做<br>对于$ans_n$，显然此时的mex为n，直接可以算出$ans_n$，当知道了ans_n后，$ans_{n-1}$的mex显然就是目前的mex和$ans_n$的值取小的那个，不倒推即可</p>
<h4 id="CF1942C-Bessie’s-Birthday-Cake"><a href="#CF1942C-Bessie’s-Birthday-Cake" class="headerlink" title="CF1942C   Bessie’s Birthday Cake"></a>CF1942C   Bessie’s Birthday Cake</h4><h5 id="贪心-思维"><a href="#贪心-思维" class="headerlink" title="贪心 思维"></a>贪心 思维</h5><p>考虑y&#x3D;0的情况，把给定的点连成多边形，对于一个多边形，其内部能划分出的三角形个数就是其边数x-2，然后我们发现如果两个给定的点之间夹了一个未给定的点，这种情况也能组成三角形，所以就是统计距离为2的点对的数量ans,最终答案是ans+x-2</p>
<p>当$y \neq 0$时，我们要不断构造上面所说的距离为2的点对的情况，这也能分两类讨论，当两个相邻的给定点距离大于2时，根据画图找规律可以发现，在把间隔按照中间每隔一格赛一个点的规则填满时，当距离（$a_x-a_y$）为偶数，一共可以填$(a_x-a_y)&#x2F;2$个点，产生$(a_x-a_y)&#x2F;+1$个三角形，当填不满时则少一个，当距离为奇数时，可以填$(a_x-a_y-1)&#x2F;2$个点，产生$(a_x-a_y-1)&#x2F;2$个三角形，所以我们先填距离为偶数的间隔，并先填短的，注意处理未填满的情况即可</p>
<h4 id="CF1957B-A-BIT-of-a-Construction"><a href="#CF1957B-A-BIT-of-a-Construction" class="headerlink" title="CF1957B A BIT of a Construction"></a>CF1957B A BIT of a Construction</h4><h5 id="贪心-16"><a href="#贪心-16" class="headerlink" title="贪心"></a>贪心</h5><p>直接从低位到高位枚举$a_i$并将k减去$a_i$即可</p>
<h4 id="CF1957D-A-BIT-of-an-Inequality"><a href="#CF1957D-A-BIT-of-an-Inequality" class="headerlink" title="CF1957D A BIT of an Inequality"></a>CF1957D A BIT of an Inequality</h4><h5 id="思维-二进制"><a href="#思维-二进制" class="headerlink" title="思维 二进制"></a>思维 二进制</h5><p>我们把原式展开，首先可以的到几个结论：</p>
<ol>
<li>当x&#x3D;y&#x3D;z时肯定不符合题意</li>
<li>原问题等价于，对于一个区间的异或和$pre_{l…r}$，问这个区间内有几个数$a_i$满足$a_i \bigoplus pre_{l..r} &gt;pre $</li>
<li>进一步分析2，发现2等价于，要求$a_i$的最高位对于$pre_{l..r}$而言，该位为0</li>
</ol>
<p>发现如果枚举区间复杂度无法接受，考虑对于y寻找可能的x，y，即区间的左右端点，从左往右枚举y，考虑分别记录y左边至0，y右边至n有多少个$pre_i$第j位为0或者1，假设j为$a_i$的最高位，我们只需简单使用乘法原理（cnt0之间相乘,cnt1之间相乘）就可以得到有多少对$pre_r \bigoplus pre_l$满足题意<br>实现过程中注意，开始应该把所有点都扔进右边的桶里计数<br>在计算$a_i$的答案时，考虑到实际的区间左端点是$l+1$，所以我们先算答案，再把$pre_i$从右边的桶移到左边的桶，这点通过画图可以得知</p>
<h4 id="CF1966A-Card-Exchange"><a href="#CF1966A-Card-Exchange" class="headerlink" title="CF1966A Card Exchange"></a>CF1966A Card Exchange</h4><h5 id="贪心-17"><a href="#贪心-17" class="headerlink" title="贪心"></a>贪心</h5><p>发现我们只关心一次换了k-1张牌，不关心牌具体的情况，所以最优策略就是每次换当前数量最多的，换过来的k-1张牌存进tot里，遇到不够换的时候拿tot补，最后没法换了把剩下的总牌数加上剩下的tot就是答案（注意最后tot和k-1取min）,开个堆瞎搞即可</p>
<h4 id="CF1966B-Rectangle-Filling"><a href="#CF1966B-Rectangle-Filling" class="headerlink" title="CF1966B Rectangle Filling"></a>CF1966B Rectangle Filling</h4><h5 id="思维-4"><a href="#思维-4" class="headerlink" title="思维"></a>思维</h5><p>发现对于一种颜色，我们相当于是选一条对角线代表的矩形涂色，我们考虑看对于每个颜色，显然它在x轴上最多只能涂到x值最大的同色块那么远，然后x轴和y轴的答案显然是不干扰的，所以要全部涂成同一颜色，我们只要看对一个颜色，它最小的x值和y值是否为1，最大的x值和y值是否为n和m即可</p>
<h4 id="CF1966C-Everything-Nim"><a href="#CF1966C-Everything-Nim" class="headerlink" title="CF1966C Everything Nim"></a>CF1966C Everything Nim</h4><h5 id="博弈论"><a href="#博弈论" class="headerlink" title="博弈论"></a>博弈论</h5><p>对于每轮游戏，选择一个最多不超过最小石子堆石子个数的正整数k，并将每个堆都移去k个石子<br>因为每次移的个数有上限，而且还是对所有的堆都移，考虑每轮最多能移几个，发现问题等价于对原序列排序后的差分数组进行移石子，且遇到0全部跳过（显然），而且只能从左往右移，然后考虑先后手，当目前堆石子数大于1的时候,先手的那个人可以选择全部移走，或者留一个，意味着他可以决定在移下一堆石子是自己是先手还是后手，也就是再之后遇到1时的强制交换先后手对它没有影响（这点手摸可以发现），所以我们只要考虑遇到第一个大于1的数时谁是先手，也就是统计去0后的差分数组里连续的前导1的数量（不包括差分数组最后一位的数），偶数Alice，奇数Bob</p>
<h4 id="CF1966D-Missing-Subsequence-Sum"><a href="#CF1966D-Missing-Subsequence-Sum" class="headerlink" title="CF1966D Missing Subsequence Sum"></a>CF1966D Missing Subsequence Sum</h4><h5 id="构造-1"><a href="#构造-1" class="headerlink" title="构造"></a>构造</h5><p>看到串的长度小于25，考虑二进制分解，我们可以构造一个1,2,4…的串，同时这个串不包含k最高位的1，这样我们就确保了对于这一位是1的所有数都凑不出来<br>然后考虑如何凑出这一位是1的，且不等于k的其他数，假设这一位为i，串中比它低的位的和加起来是$2^i-1$，那我们如果放一个$k-2^i$，它与前面这些数加起来就是k-1，根据二进制分解的原理我们确保了1…k-1都可以凑出来,然后我们可以暴力添加一个k+1，那么这个k+1与我们前面已经构造出来的1…k-1就可以凑出k+2…2k,</p>
<h4 id="CF1969A-Two-Friends"><a href="#CF1969A-Two-Friends" class="headerlink" title="CF1969A  Two Friends"></a>CF1969A  Two Friends</h4><h5 id="贪心-18"><a href="#贪心-18" class="headerlink" title="贪心"></a>贪心</h5><p>有长度为2的环答案就是2，否则是3</p>
<h4 id="CF1969B-Shifts-and-Sorting"><a href="#CF1969B-Shifts-and-Sorting" class="headerlink" title="CF1969B Shifts and Sorting"></a>CF1969B Shifts and Sorting</h4><h5 id="贪心-19"><a href="#贪心-19" class="headerlink" title="贪心"></a>贪心</h5><p>手玩发现对于1100，我先操作$s_{1…3}$再操作$s_{2…4}$和直接操作$s_{1…4}$结果是一样的<br>问题就化为从左往右，对于每一个1，把他和他后面遇到的第一个0交换位置（以这两个数为端点执行一次右移）<br>注意到我们这么做的实质是不断把1后面的0提到最前面，所以我们只要记录第一个1的位置pos，然后每次操作后pos+1就是下一个1的位置，所有的1是很自然被排到一起的</p>
<h4 id="CF1969C-Minimizing-the-Sum"><a href="#CF1969C-Minimizing-the-Sum" class="headerlink" title="CF1969C Minimizing the Sum"></a>CF1969C Minimizing the Sum</h4><h5 id="dp"><a href="#dp" class="headerlink" title="dp"></a>dp</h5><p>一次操作可以把一个数左边或右边的邻居替换为它，问最多操作$k (k \leq 10)$次后整个序列和的最小值<br>发现k很小，考虑预处理以i为右端点，i-j为左端点,操作j次产生的贡献$v_{i,j}$,以i为右端点可以方便处理后效性的问题<br>自然想到dp数组$dp_{i,k}$代表前i个数操作k次产生的最小贡献<br>考虑如何转移，假设我们在i处操作j次，此时总共操作了k次，$dp_{i,k}$显然就要从$dp_{i-j-1,k-j}$前面的状态转移来，然后我们肯定要从前面里选一个最小的,所以$mindp_{i,j}$表示$dp_{1…i,j}$里最小的值，转移方程就是$dp_{i,k}&#x3D;min(dp_{i,k},mindp_{i-l-1,k-j}+v_{i,j})$，记得每次转移完后更新$mindp_{i,j}$,并且$mindp_{i,j}$在进入第一次转移前初始化为$mindp_{i-1,j}$，dp入口为$dp_{0,0}$，因为没说一定要选k次，所以dp和mindp初始化全0即可</p>
<h4 id="CF1969D-Shop-Game"><a href="#CF1969D-Shop-Game" class="headerlink" title="CF1969D Shop Game"></a>CF1969D Shop Game</h4><h5 id="贪心-20"><a href="#贪心-20" class="headerlink" title="贪心"></a>贪心</h5><p>选任意个物品，alice可以以$a_i$的价格买入,并以$b_i$的价格卖给bob，bob可以选择不超过k个物品免费拿走，bob希望alice的总收入最少，alice希望最多，问alice的最大收益是多少</p>
<p>对bob来说，显然他会拿走alice的物品里$b_i$最大的k个，所以我们按b从大到小排序，可以将原序列分成两部分，对于一个$i(i&gt;k)$，它左边需要选k个a最小的的让bob拿，并且其他的都不拿，右边则是a&gt;b的全拿，然后我们往右枚举这个断点并每次统计答案，左边拿一个优先队列维护前k个最小的a的和即可，右边先对$b_i-a_i$求和，然后不断减掉即可，对于左边为什么不用选超过k个，我们考虑，因为bob的行为其实是固定的，对于alice一个物品都不移除的情况，bob实际上就是选第1…k个免费拿，当断点移动到k+2的时候，如果我们不移除k+1，实际上bob还是拿1…k，而不移除k+1的情况在断点为k+1时已经计算过答案了，所以只需要保证左边留k个，其他全移除即可</p>
<h4 id="CF1972A-Contest-Proposal"><a href="#CF1972A-Contest-Proposal" class="headerlink" title="CF1972A Contest Proposal"></a>CF1972A Contest Proposal</h4><h5 id="暴力"><a href="#暴力" class="headerlink" title="暴力"></a>暴力</h5><p>按题意模拟即可，答案最大不会超过n</p>
<h4 id="CF1972B-Coin-Games"><a href="#CF1972B-Coin-Games" class="headerlink" title="CF1972B Coin Games"></a>CF1972B Coin Games</h4><h5 id="思维-结论"><a href="#思维-结论" class="headerlink" title="思维 结论"></a>思维 结论</h5><p>n个硬币排成环，可以对朝上的硬币进行操作，若硬币数小于2则直接删除这个硬币，否则删除这个硬币的同时翻转相邻的两个硬币，无法操作的人输<br>发现对于所有的情况，朝上的硬币数要么一次减少3个，要么减少1个，要么增加1个，所以每次操作都会改变朝上硬币数的奇偶性，最后把数量变成0，即偶数的那个人赢，所以开始朝上硬币数为奇数时alice赢，否则bob</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2025-03-11T07:36:13.000Z" title="2025/3/11 15:36:13">2025-03-11</time></span><span class="level-item">Updated&nbsp;<time dateTime="2025-03-11T07:56:04.250Z" title="2025/3/11 15:56:04">2025-03-11</time></span><span class="level-item"><a class="link-muted" href="/categories/Reverse/">Reverse</a><span> / </span><a class="link-muted" href="/categories/Reverse/ctf-test/">ctf-test</a></span><span class="level-item">3 minutes read (About 488 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/ctf/WP/buu/GWCTF%202019%20babyvm/">[GWCTF 2019]babyvm</a></p><div class="content"><p>提示是vm题</p>
<p>打开修复下符号，确实是vm题<br><img src="/gallery/illustration/GWCTF%202019%20babyvm/main.png"><br>进去修复下结构体，结构还是很明显的<br><img src="/gallery/illustration/GWCTF%202019%20babyvm/type.png"><br><img src="/gallery/illustration/GWCTF%202019%20babyvm/initvm.png"><br>修完后基本知道在干什么了，直接去看text段，指令有五百多个byte，写个脚本解析</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">i = <span class="number">0</span></span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&quot;output.txt&quot;</span>, <span class="string">&quot;w&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line">cnt = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> i &lt; <span class="built_in">len</span>(text) <span class="keyword">and</span> cnt &lt; <span class="number">2</span>:</span><br><span class="line">    <span class="keyword">if</span> text[i] == <span class="number">0xF1</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;mov &quot;</span>, end=<span class="string">&quot;&quot;</span>, file=f)</span><br><span class="line">        op = text[i+<span class="number">1</span>]</span><br><span class="line">        i += <span class="number">2</span></span><br><span class="line">        num = text[i]+text[i+<span class="number">1</span>]*<span class="number">256</span>+text[i+<span class="number">2</span>]*<span class="number">256</span>*<span class="number">256</span>+text[i+<span class="number">3</span>]*<span class="number">256</span>*<span class="number">256</span></span><br><span class="line">        <span class="keyword">if</span> op == <span class="number">0xE1</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;r0 = input[&#123;&#125;]&quot;</span>.<span class="built_in">format</span>(num), file=f)</span><br><span class="line">        <span class="keyword">elif</span> op == <span class="number">0xE2</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;r1 = input[&#123;&#125;]&quot;</span>.<span class="built_in">format</span>(num), file=f)</span><br><span class="line">        <span class="keyword">elif</span> op == <span class="number">0xE3</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;r2 = input[&#123;&#125;]&quot;</span>.<span class="built_in">format</span>(num), file=f)</span><br><span class="line">        <span class="keyword">elif</span> op == <span class="number">0xE4</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;input[&#123;&#125;] = r0&quot;</span>.<span class="built_in">format</span>(num), file=f)</span><br><span class="line">        <span class="keyword">elif</span> op == <span class="number">0xE5</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;r3 = input[&#123;&#125;]&quot;</span>.<span class="built_in">format</span>(num), file=f)</span><br><span class="line">        <span class="keyword">elif</span> op == <span class="number">0xE7</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;input[&#123;&#125;] = r1&quot;</span>.<span class="built_in">format</span>(num), file=f)</span><br><span class="line">        i += <span class="number">4</span></span><br><span class="line">    <span class="keyword">elif</span> text[i] == <span class="number">0xF2</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;r0 ^= r1&quot;</span>, file=f)</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">    <span class="keyword">elif</span> text[i] == <span class="number">0xF5</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;readInput&quot;</span>, file=f)</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">    <span class="keyword">elif</span> text[i] == <span class="number">0xF4</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;rip++&quot;</span>, file=f)</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">    <span class="keyword">elif</span> text[i] == <span class="number">0xF7</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;r0 *= r3&quot;</span>, file=f)</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">    <span class="keyword">elif</span> text[i] == <span class="number">0xF8</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;swap r0 r3&quot;</span>, file=f)</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">    <span class="keyword">elif</span> text[i] == <span class="number">0xF6</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;r0 = r2 + 2*r1 + 3*r0&quot;</span>, file=f)</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">    <span class="keyword">elif</span> text[i] == <span class="number">0xF4</span>:</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">        cnt += <span class="number">1</span></span><br><span class="line">    <span class="comment"># print(i, hex(text[i]))</span></span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure>
<p>这题有个很恶心的地方，他text段有两段逻辑，并不是rip到0xF4就停止了，前一段是假flag，要用类似栈溢出的方法去第二段逻辑<br>最后手动逆出真正的加密逻辑如下</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="selector-tag">i</span> <span class="number">1</span> ~ <span class="number">5</span>  <span class="selector-tag">input</span><span class="selector-attr">[i]</span> ^= <span class="selector-attr">[i+1]</span></span><br><span class="line"></span><br><span class="line"><span class="selector-tag">input</span><span class="selector-attr">[6]</span>=(<span class="selector-tag">input</span><span class="selector-attr">[8]</span>+<span class="number">2</span>*<span class="selector-tag">input</span><span class="selector-attr">[7]</span>+<span class="number">3</span>*<span class="selector-tag">input</span><span class="selector-attr">[6]</span>)*<span class="selector-tag">input</span><span class="selector-attr">[12]</span></span><br><span class="line"><span class="selector-tag">input</span><span class="selector-attr">[7]</span>=(<span class="selector-tag">input</span><span class="selector-attr">[9]</span>+<span class="number">2</span>*<span class="selector-tag">input</span><span class="selector-attr">[8]</span>+<span class="number">3</span>*<span class="selector-tag">input</span><span class="selector-attr">[7]</span>)*<span class="selector-tag">input</span><span class="selector-attr">[12]</span></span><br><span class="line"><span class="selector-tag">input</span><span class="selector-attr">[8]</span>=(<span class="selector-tag">input</span><span class="selector-attr">[10]</span>+<span class="number">2</span>*<span class="selector-tag">input</span><span class="selector-attr">[9]</span>+<span class="number">3</span>*<span class="selector-tag">input</span><span class="selector-attr">[8]</span>)*<span class="selector-tag">input</span><span class="selector-attr">[12]</span></span><br><span class="line">swap <span class="selector-tag">input</span><span class="selector-attr">[13]</span> <span class="selector-tag">input</span><span class="selector-attr">[19]</span></span><br><span class="line">swap <span class="selector-tag">input</span><span class="selector-attr">[14]</span> <span class="selector-tag">input</span><span class="selector-attr">[18]</span></span><br><span class="line">swap <span class="selector-tag">input</span><span class="selector-attr">[15]</span> <span class="selector-tag">input</span><span class="selector-attr">[17]</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>直接逆即可<br>注意到密文也是假的，真正的密文在一个没有交叉引用的函数里</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">sec = [<span class="number">0x69</span>, <span class="number">0x45</span>, <span class="number">0x2A</span>, <span class="number">0x37</span>, <span class="number">0x09</span>, <span class="number">0x17</span>, <span class="number">0xC5</span>, <span class="number">0x0B</span>, <span class="number">0x5C</span>, <span class="number">0x72</span>,</span><br><span class="line">       <span class="number">0x33</span>, <span class="number">0x76</span>, <span class="number">0x33</span>, <span class="number">0x21</span>, <span class="number">0x74</span>, <span class="number">0x31</span>, <span class="number">0x5F</span>, <span class="number">0x33</span>, <span class="number">0x73</span>, <span class="number">0x72</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">30</span>, <span class="number">127</span>):</span><br><span class="line">    <span class="keyword">if</span> sec[<span class="number">8</span>] == ((sec[<span class="number">10</span>]+<span class="number">2</span>*sec[<span class="number">9</span>]+<span class="number">3</span>*i)*sec[<span class="number">12</span>]) &amp; <span class="number">0xFF</span>:</span><br><span class="line">        sec[<span class="number">8</span>] = i</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">30</span>, <span class="number">127</span>):</span><br><span class="line">    <span class="keyword">if</span> sec[<span class="number">7</span>] == ((sec[<span class="number">9</span>]+<span class="number">2</span>*sec[<span class="number">8</span>]+<span class="number">3</span>*i)*sec[<span class="number">12</span>]) &amp; <span class="number">0xFF</span>:</span><br><span class="line">        sec[<span class="number">7</span>] = i</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">30</span>, <span class="number">127</span>):</span><br><span class="line">    <span class="keyword">if</span> sec[<span class="number">6</span>] == ((sec[<span class="number">8</span>]+<span class="number">2</span>*sec[<span class="number">7</span>]+<span class="number">3</span>*i)*sec[<span class="number">12</span>]) &amp; <span class="number">0xFF</span>:</span><br><span class="line">        sec[<span class="number">6</span>] = i</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">sec[<span class="number">15</span>], sec[<span class="number">17</span>] = sec[<span class="number">17</span>], sec[<span class="number">15</span>]</span><br><span class="line">sec[<span class="number">14</span>], sec[<span class="number">18</span>] = sec[<span class="number">18</span>], sec[<span class="number">14</span>]</span><br><span class="line">sec[<span class="number">13</span>], sec[<span class="number">19</span>] = sec[<span class="number">19</span>], sec[<span class="number">13</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">    sec[i] ^= sec[i+<span class="number">1</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> sec:</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">hex</span>(i), end=<span class="string">&quot; &quot;</span>)</span><br></pre></td></tr></table></figure>

</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2025-03-06T11:42:14.000Z" title="2025/3/6 19:42:14">2025-03-06</time></span><span class="level-item">Updated&nbsp;<time dateTime="2025-03-06T13:20:51.148Z" title="2025/3/6 21:20:51">2025-03-06</time></span><span class="level-item"><a class="link-muted" href="/categories/Reverse/">Reverse</a><span> / </span><a class="link-muted" href="/categories/Reverse/LLVM/">LLVM</a></span><span class="level-item">10 minutes read (About 1437 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/ctf/llvm/llvm0x1/">从零开始的LLVM-pass （一） 环境搭建和第一个demo</a></p><div class="content"><h3 id="为什么有这篇文章"><a href="#为什么有这篇文章" class="headerlink" title="为什么有这篇文章"></a>为什么有这篇文章</h3><p>前段时间看了点LLVM的博客，学的非常痛苦，所以打算写一篇文章记录一下基本的框架搭建过程，省的一段时间后又忘了</p>
<h3 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h3><p>实现一个 <strong>FunctionPass</strong> ，遍历所有函数，如果函数不是main函数就修改混淆函数的名字</p>
<h3 id="关于环境"><a href="#关于环境" class="headerlink" title="关于环境"></a>关于环境</h3><p>开发环境是win，至于为什么不选linux，主要是没有物理机实在不方便，后续如果被win恶心到了可能会迁移到linux</p>
<p><a target="_blank" rel="noopener" href="https://github.com/tfslabs/llvm-gnu-windows">win-gnu-llvm下载</a></p>
<p>非常神奇的找到了兼容win-gnu ABI的llvm工具链，试了下能跑，索性先这样<br>g++用的是MinGW，网上随便下一个新一点的都行</p>
<p>直接下载完就是编译完的二进制文件，把bin加到环境目录就能识别clang和opt了</p>
<h3 id="框架搭建"><a href="#框架搭建" class="headerlink" title="框架搭建"></a>框架搭建</h3><p>目录结构如图所示<br><img src="/gallery/illustration/llvm0x1/1.png"><br>build是Cmake的输出路径，最终编译好的pass就存在里面<br>test里是测试文件，用来测试pass的混淆效果<br>transforms里是pass的源码</p>
<h4 id="transforms-CMakelists-txt"><a href="#transforms-CMakelists-txt" class="headerlink" title="&#x2F;transforms&#x2F;CMakelists.txt"></a>&#x2F;transforms&#x2F;CMakelists.txt</h4><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># /transforms/CMakelists.txt</span></span><br><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.13</span>)</span><br><span class="line"><span class="keyword">project</span>(MyPass)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_C_COMPILER <span class="string">&quot;gcc&quot;</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_COMPILER <span class="string">&quot;g++&quot;</span>)</span><br><span class="line"><span class="keyword">set</span>(LLVM_DIR <span class="string">&quot;C://llvm-19.1.6-1/lib/cmake/llvm&quot;</span>)</span><br><span class="line"><span class="keyword">find_package</span>(LLVM REQUIRED CONFIG)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">$&#123;LLVM_INCLUDE_DIRS&#125;</span>)</span><br><span class="line"><span class="keyword">link_directories</span>(<span class="variable">$&#123;LLVM_LIBRARY_DIRS&#125;</span>)</span><br><span class="line"><span class="keyword">add_definitions</span>(<span class="variable">$&#123;LLVM_DEFINITIONS&#125;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">add_library</span>(MyPass MODULE MyPass.cpp</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">target_link_libraries</span>(MyPass</span><br><span class="line">    LLVMCore</span><br><span class="line">    LLVMSupport</span><br><span class="line">    LLVMIRReader</span><br><span class="line">    LLVMPasses</span><br><span class="line">    LLVMAnalysis</span><br><span class="line">    LLVMTransformUtils</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>CMakelist如上设置，要手动导入LLVM的cmake路径，然后中间这些宏都是LLVM的.cmake文件里自带的，直接抄就行<br>之后就和正常cmake项目一样，设置链接库源文件，输出和依赖</p>
<h4 id="test-sh"><a href="#test-sh" class="headerlink" title="test.sh"></a>test.sh</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># test.sh</span></span><br><span class="line"><span class="built_in">cd</span> ./build  </span><br><span class="line">cmake -G <span class="string">&quot;Ninja&quot;</span> ../transforms            </span><br><span class="line">cmake --build .</span><br><span class="line"><span class="built_in">cd</span> ../test</span><br><span class="line">g++ test.cpp -o beforeLLVM_test</span><br><span class="line">clang++ -S -emit-llvm test.cpp -o test.ll</span><br><span class="line">opt -load-pass-plugin=../build/libMyPass.dll -passes=encode-func -S test.ll -o test.out.ll</span><br><span class="line">llc test.out.ll -filetype=obj -o test.o</span><br><span class="line">g++  test.o -o <span class="built_in">test</span> </span><br><span class="line">./test</span><br><span class="line"><span class="built_in">cd</span> ..</span><br></pre></td></tr></table></figure>

<p>使用g++编译一份未加pass的二进制文件方便以后对比，使用clang++配合-S -emit-llvm参数输出llvm-IR文件，这是llvm的中间语言文件，之后pass所有的处理都在该文件上进行<br><strong>-load-pass-plugin&#x3D;${filePath}</strong> 是opt新版的api，我们生成的是类似于插件库的dll，之后还要加上 <strong>-passes&#x3D;{passName}</strong> 指定具体用哪个pass，之后讲如何注册pas时会具体讲这个passName是怎么来的</p>
<p>处理好后用llc把中间文件编译成目标文件，再用g++把中间文件编译成可执行文件就完事了</p>
<h4 id="MyPass-cpp"><a href="#MyPass-cpp" class="headerlink" title="MyPass.cpp"></a>MyPass.cpp</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;llvm/IR/PassManager.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;llvm/Passes/PassBuilder.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;llvm/Passes/PassPlugin.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;llvm/Support/raw_ostream.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> llvm;</span><br><span class="line"><span class="keyword">namespace</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">EncodeFunctionName</span> : <span class="keyword">public</span> PassInfoMixin&lt;EncodeFunctionName&gt;</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="type">static</span> <span class="type">int</span> functionCnt;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function">PreservedAnalyses <span class="title">run</span><span class="params">(Function &amp;F, FunctionAnalysisManager &amp;FAM)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (F.<span class="built_in">getName</span>() != <span class="string">&quot;main&quot;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">errs</span>() &lt;&lt; <span class="string">&quot;Old name: &quot;</span> &lt;&lt; F.<span class="built_in">getName</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">                F.<span class="built_in">setName</span>(<span class="string">&quot;114514func&quot;</span> + std::<span class="built_in">to_string</span>(++functionCnt));</span><br><span class="line">                <span class="built_in">errs</span>() &lt;&lt; <span class="string">&quot;New name: &quot;</span> &lt;&lt; F.<span class="built_in">getName</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">errs</span>() &lt;&lt; <span class="string">&quot;function is &quot;</span> &lt;&lt; F.<span class="built_in">getName</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> PreservedAnalyses::<span class="built_in">all</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">isRequired</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="literal">true</span>; &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> EncodeFunctionName::functionCnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> LLVM_ATTRIBUTE_WEAK ::<span class="function">llvm::PassPluginLibraryInfo</span></span><br><span class="line"><span class="function"><span class="title">llvmGetPassPluginInfo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        LLVM_PLUGIN_API_VERSION,</span><br><span class="line">        <span class="string">&quot;encode-func&quot;</span>,</span><br><span class="line">        LLVM_VERSION_STRING,</span><br><span class="line">        [](PassBuilder &amp;PB)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">errs</span>() &lt;&lt; <span class="string">&quot;\n=== Registering EncodeFunctionName Pass ===\n&quot;</span>;</span><br><span class="line">            PB.<span class="built_in">registerPipelineParsingCallback</span>(</span><br><span class="line">                [](StringRef Name, FunctionPassManager &amp;FPM,</span><br><span class="line">                   ArrayRef&lt;PassBuilder::PipelineElement&gt;)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (Name == <span class="string">&quot;encode-func&quot;</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="built_in">errs</span>() &lt;&lt; <span class="string">&quot;Adding EncodeFunctionName pass to manager\n&quot;</span>;</span><br><span class="line">                        FPM.<span class="built_in">addPass</span>(<span class="built_in">EncodeFunctionName</span>());</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;);</span><br><span class="line">        &#125;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>llvm的所有实现都定义在llvm空间中，因为是个demo所以干脆直接using namespace llvm<br>要实现一个自己的pass，我们要从 <strong>PassInfoMixin&lt;&gt;</strong> 这个基类模板继承，这是LLVM的新版API，区别于旧版的是我们不用指定pass的类型，而是依靠下面的 <strong>run</strong> 方法的实现区分pass类型，我们要实现一个functionPAss，所以 <strong>run</strong> 的参数就是 <strong>llvm:Function</strong> 和 <strong>llvm:FunctionAnalysisManager</strong> </p>
<p><strong>run</strong> 是pass中最关键的方法，一个pass所有的业务都是在run中完成的，这是一个回调，会对所有的函数执行，我们直接用getName获取名字，然后用setName重设名字就行，返回 <strong>PreservedAnalyses::all()</strong> 表示这个pass不会对其他任何pass产生影响，反正我们也只跑这一个pass，返回all即可</p>
<p><strong>isRequired()</strong> 编译器可能会跳过我们的pass，因为实际上pass没做优化，所以要实现 <strong>isRequired</strong> 返回ture强制要求编译器执行我们的pass</p>
<p><strong>extern “C” LLVM_ATTRIBUTE_WEAK ::llvm::PassPluginLibraryInfo llvmGetPassPluginInfo()</strong><br>这是新版LLVM注册pass的惯用约定，这部分基本没什么好改的，返回一个四元组 <strong>{LLVM插件API版本号，插件名，插件版本号，注册回调函数}</strong> ，其中插件名就是我们用-pass时传递的名字，opt会解析这个名字并并调用相关回调，插件版本号随便写就行</p>
<p>回调会传入一个PassBuilder,我们往里面注册一个解析回调，每次opt解析我们的命令时都会执行这个回调，这个回调的格式也基本是固定的，最重要的是 <strong>Name</strong> ，这是解析得到的 <strong>passName</strong> ，我们调用 <strong>FPM.FPM.addPass(EncodeFunctionName())</strong> 来完成注册</p>
<h4 id="test-cpp"><a href="#test-cpp" class="headerlink" title="test.cpp"></a>test.cpp</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// test.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">testFunctionA</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;testA&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">testFunctionB</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;testB&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">testFunctionC</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;testC&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">testFunctionA</span>();</span><br><span class="line">    <span class="built_in">testFunctionB</span>();</span><br><span class="line">    <span class="built_in">testFunctionC</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们声明了三个函数，预期这三个函数的名字都会被改成114514funcxxx</p>
<h4 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h4><p>根据pass输出的调试信息可以发现opt按照从上到下的顺序对每个函数执行了pass<br><img src="/gallery/illustration/llvm0x1/2.png"></p>
<p>然后再打开ida看看二进制文件是否真的被修改了</p>
<p><img src="/gallery/illustration/llvm0x1/before.png"><br><img src="/gallery/illustration/llvm0x1/after.png"><br>可以看到确实被修改了</p>
<p>下一篇文章可能会写一下怎么修改基本块和怎么混淆运算符</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2025-03-03T10:43:30.000Z" title="2025/3/3 18:43:30">2025-03-03</time></span><span class="level-item">Updated&nbsp;<time dateTime="2025-04-03T12:57:06.060Z" title="2025/4/3 20:57:06">2025-04-03</time></span><span class="level-item"><a class="link-muted" href="/categories/Development/">Development</a></span><span class="level-item">19 minutes read (About 2884 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/development/selenium0x1/">selenium爬虫入门</a></p><div class="content"><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>selenium是基于浏览器DevTool模拟用户态行为的爬虫框架，与传统爬虫相比selenium最大的优点就是可以通过模拟行为绕过大部分的反爬，同时因为其本身基于浏览器，在对抗加密方面有天然的优势</p>
<h3 id="常用API"><a href="#常用API" class="headerlink" title="常用API"></a>常用API</h3><h4 id="webDriver-Chrome-Options-Option"><a href="#webDriver-Chrome-Options-Option" class="headerlink" title="webDriver.Chrome.Options() : Option"></a>webDriver.Chrome.Options() : <em>Option</em></h4><p>返回一个 <strong>option</strong> 对象，用于在之后为浏览器提供选项参数，最常见的用法如下</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">options = webdriver.ChromeOptions()</span><br><span class="line">options.add_argument(<span class="string">&quot;disable-blink-features=AutomationControlled&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>这段代码为option添加了一个参数将浏览器的 <strong>webdriver</strong> 属性置为false，该属性常用于检测浏览器是否处于调试模式，常见的反爬会检测该属性，该属性为true则会触发反爬<br>此外还可以添加包括但不限于下列的属性，但用处都不大</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">--disable-gpu     <span class="comment"># 禁用gpu加速</span></span><br><span class="line">--headless        <span class="comment"># 将浏览器设置为无头浏览器</span></span><br><span class="line">--windows-size=<span class="number">1920</span>,<span class="number">1080</span> <span class="comment">#设置浏览器窗口大小</span></span><br></pre></td></tr></table></figure>

<h4 id="webdriver-Chrome-options-Option-WebDriver"><a href="#webdriver-Chrome-options-Option-WebDriver" class="headerlink" title="webdriver.Chrome(options : Option ) :  WebDriver"></a>webdriver.Chrome(options : <em>Option</em> ) :  <em>WebDriver</em></h4><p>创建一个浏览器对象，所有与浏览器的交互都会通过这个对象进行</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">driver = webdriver.Chrome(options=options)</span><br></pre></td></tr></table></figure>

<h4 id="driver-get-url-str-void"><a href="#driver-get-url-str-void" class="headerlink" title="driver.get(url : str ) : void"></a>driver.get(url : <em>str</em> ) : <em>void</em></h4><p>打开一个页面</p>
<h4 id="driver-find-element-by-str-value-str-WebElement"><a href="#driver-find-element-by-str-value-str-WebElement" class="headerlink" title="driver.find_element(by: str , value : str ) :  WebElement"></a>driver.find_element(by: <em>str</em> , value : <em>str</em> ) :  <em>WebElement</em></h4><p>在webdriver目前聚焦的页面中寻找对应html元素，并返回一个可以对找到的元素进行交互的对象， <strong>by</strong> 是 <strong>selenium.webdriver.common.by</strong> 中的枚举类， <strong>value</strong> 是搜索对应的值或表达式，这里只介绍 <strong>By.CSS_SELECTOR</strong> 和 <strong>By.LINK_TEXT</strong>，个人认为算是最通用的方法。<br>这个方法只返回找到的第一个元素，且找不到则抛出错误，另一个类似的方法是 <strong>driver.find_elements</strong> 返回所有找到的元素，如果找不到就返回空列表</p>
<p><strong>By.CSS_SELECTOR</strong> 利用CSS选择器查找元素，<strong>value</strong> 应为一个CSS选择器表达式<br>下面是一些示例</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">value = <span class="string">&quot;div&quot;</span>   <span class="comment"># 单独的名字表示筛选特定tag的元素</span></span><br><span class="line">value = <span class="string">&quot;.targetClass&quot;</span> <span class="comment"># class名前带.表示筛选带特定类的元素</span></span><br><span class="line">value = <span class="string">&quot;#ID&quot;</span>   <span class="comment"># ID前带#表示筛选含特定id的元素</span></span><br><span class="line">value = <span class="string">&quot;[attribute]&quot;</span> <span class="comment"># 筛选带具备特定属性的元素</span></span><br><span class="line">value = <span class="string">&#x27;[attribute=&quot;value&quot;]&#x27;</span> <span class="comment"># 筛选带特定属性且属性值为value的元素，其中&quot;&quot;不可省略和替换</span></span><br><span class="line">value = <span class="string">&quot;div.targetClass#ID&quot;</span> <span class="comment"># 选择含多个条件的元素则将所有条件不加空格地组合在一起</span></span><br><span class="line"></span><br><span class="line">value = <span class="string">&quot;div#fatherDiv div#sonDiv&quot;</span> <span class="comment"># 如果要选择某个元素的后代元素则将两个元素的筛选条件以空格隔开</span></span><br><span class="line"></span><br><span class="line">value = <span class="string">&quot;div#faterDiv &gt; div#directSonDiv&quot;</span> <span class="comment"># 如果要选择直属于某个元素的子元素则在两个元素的筛选条件之间额外加入 &gt;</span></span><br><span class="line"></span><br><span class="line">value = <span class="string">&quot;:not()&quot;</span> <span class="comment"># 选择不符合特定条件的元素，()中可以嵌套另一个CSS选择器表达式</span></span><br><span class="line">                 <span class="comment"># 比如 &quot;div:not(.disabled)&quot; ,选择不为disable类的div元素</span></span><br></pre></td></tr></table></figure>

<p><strong>By.LINK_TEXT</strong> 筛选文本为 <strong>value</strong> 的&lt;a&gt;元素即超链接元素，执行严格匹配，另一个类似的方法是 <strong>By.PARTIAL_LINK_TEXT</strong>，只需提供的 <strong>value</strong> 是目标的子串就行，此方法用于快捷定位特定超链接对应的元素，方便爬虫在页面间进行跳转</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Page = driver.find_element(by=By.LINK_TEXT, value=<span class="string">&quot;下一页&quot;</span>) <span class="comment"># 这样我们就定位到了一个翻页按钮，可以用click之类的方法让我们的爬虫翻页</span></span><br></pre></td></tr></table></figure>

<h4 id="ActionChains-driver-WebDriver-ActionChains"><a href="#ActionChains-driver-WebDriver-ActionChains" class="headerlink" title="ActionChains(driver : WebDriver ) : ActionChains"></a>ActionChains(driver : <em>WebDriver</em> ) : <em>ActionChains</em></h4><p>这是selenium提供的动作链类，用于模拟用户的操作输入</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">actions = ActionChains(driver)  <span class="comment"># 指定所属的webdriver，还可以指定duration属性来控制每次操作的时间，用来绕过针对仿真行为的反爬</span></span><br><span class="line">actions.key_down(Keys.CONTROL).click(</span><br><span class="line">        Page).key_up(Keys.CONTROL).perform() </span><br><span class="line">        <span class="comment"># 这个操作就模拟了ctrl+左键，即在新页面打开对应链接</span></span><br><span class="line">        <span class="comment"># 使用连续调用来设计动作链，最后调用perform()执行</span></span><br><span class="line">        <span class="comment"># click之类的要指定具体点击的webElement，否则点击鼠标指针所在位置</span></span><br><span class="line">        <span class="comment"># 按键类的动作可以用selenium.webdriver.common.keys中的Keys枚举类来模拟按下ctrl之类的功能键，其他按键直接输入对应字符即可</span></span><br></pre></td></tr></table></figure>

<h4 id="driver-switch-to-window-window-name-str-void"><a href="#driver-switch-to-window-window-name-str-void" class="headerlink" title="driver.switch_to.window(window_name : str ) : void"></a>driver.switch_to.window(window_name : <em>str</em> ) : <em>void</em></h4><p>将浏览器的焦点切换至另一个页面，其中 <strong>window_name</strong> 可以通过 <strong>driver.window_handles</strong> 获取，这是webdriver类的一个列表成员，储存了当前浏览器所有窗口的 <strong>window_name</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">driver.switch_to.window(driver.window_handles[-<span class="number">1</span>]) </span><br><span class="line"><span class="comment"># 切换至最右边的窗口，事实上这个列表里句柄的排列顺序是按窗口打开顺序排列的</span></span><br></pre></td></tr></table></figure>

<h4 id="driver-close-void"><a href="#driver-close-void" class="headerlink" title="driver.close() : void"></a>driver.close() : <em>void</em></h4><p>当一个页面的数据爬完了可能要关闭该页面，用close方法就能把当前页面关掉，但是注意driver并 <strong>不会自动切换聚焦到新窗口</strong> ，所以close后要调用switch_to.window把焦点转移到新窗口</p>
<h4 id="driver-quit-void"><a href="#driver-quit-void" class="headerlink" title="driver.quit() : void"></a>driver.quit() : <em>void</em></h4><p>直接关闭浏览器</p>
<h3 id="项目实战"><a href="#项目实战" class="headerlink" title="项目实战"></a>项目实战</h3><p>项目地址 &#x3D;&gt;  <a target="_blank" rel="noopener" href="https://github.com/SGSGsama/avdAliyunCrawer">基于selenium框架爬取avd.aliyun.com上的漏洞报告</a></p>
<p>阿里云的漏洞网站用了很恶心的加密算法，把本机的时间戳套了一堆加密做成token放进payload里做验证，如果验证不通过就无法进入漏洞库和漏洞报告，我们直接上selenium，只要我们全程模拟用户态行为就不用管加密，这点和逆向工程中的动态调试非常像，本质上是利用了应用自加密&#x2F;自解密的性质</p>
<p>下面直接上代码</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#utility.py</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">init_driver</span>(<span class="params">url: <span class="built_in">str</span></span>):</span><br><span class="line">    options = webdriver.ChromeOptions()</span><br><span class="line">    options.add_argument(<span class="string">&quot;disable-blink-features=AutomationControlled&quot;</span>)</span><br><span class="line">    driver = webdriver.Chrome(options=options)</span><br><span class="line">    driver.get(url)</span><br><span class="line">    <span class="keyword">return</span> driver</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>他的加密算法会在加载时就读取 <strong>webdriver</strong> 标记的值，并且这个参数会被用于加密过程，如果是undefined或者true加密跑出来就是错的，而且非常恶心的是他并不直接从 <strong>navigator.webdriver</strong> 实时读取，而是加载时检测到 <strong>webdriver</strong> 不为false就让加密胡乱输出，所以我们加一个参数在网页加载前就把 <strong>webdriver</strong> 标记设置成false</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Crawler.py</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">runCrawler</span>(<span class="params">catalog: <span class="built_in">str</span>, number: <span class="built_in">int</span> = <span class="number">0</span>, debug: <span class="built_in">bool</span> = <span class="number">0</span>, sleepSecond: <span class="built_in">float</span> = <span class="number">1</span></span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    sleepSecond为每跳转一个页面的等待时长，过短可能会触发限流或反爬\n</span></span><br><span class="line"><span class="string">    如果cve的命名不符合windows文件命名规范则会转换为url命名输出\n</span></span><br><span class="line"><span class="string">    catalog为要爬取的漏洞库的按钮文本&#123;&quot;CVE 漏洞库&quot;,&quot;非CVE漏洞库&quot;,&quot;高危漏洞&quot;&#125;\n</span></span><br><span class="line"><span class="string">    number为爬取的记录数量，若不指定则在调用函数时提示输入</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    driver = init_driver(<span class="string">&quot;https://avd.aliyun.com/&quot;</span>)</span><br><span class="line">    Page = driver.find_element(by=By.LINK_TEXT, value=catalog)</span><br><span class="line">    <span class="keyword">if</span> debug:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;in &quot;</span>+driver.title+<span class="string">&quot;  at &quot;</span>+driver.current_url)</span><br><span class="line">        <span class="comment"># input(&quot;continue&quot;)</span></span><br><span class="line">    actions = ActionChains(driver)</span><br><span class="line">    actions.key_down(Keys.CONTROL).click(</span><br><span class="line">        Page).key_up(Keys.CONTROL).perform()  <span class="comment"># 进入漏洞库列表</span></span><br><span class="line">    sleep(sleepSecond*<span class="number">1.5</span>)  <span class="comment"># 等待加载</span></span><br><span class="line">    <span class="keyword">if</span> debug:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;sleep finished&quot;</span>)</span><br><span class="line"></span><br><span class="line">    driver.switch_to.window(driver.window_handles[-<span class="number">1</span>])  <span class="comment"># 切换至漏洞库窗口</span></span><br><span class="line"></span><br><span class="line">    links = driver.find_elements(By.TAG_NAME, <span class="string">&quot;a&quot;</span>)</span><br><span class="line">    <span class="comment"># print(len(links))</span></span><br><span class="line">    <span class="keyword">if</span> debug:</span><br><span class="line">        <span class="comment"># print(driver.window_handles)</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;in &quot;</span>+driver.title+<span class="string">&quot;  at &quot;</span>+driver.current_url)</span><br><span class="line">        <span class="comment"># input(&quot;continue&quot;)</span></span><br><span class="line">    total = driver.find_element(</span><br><span class="line">        by=By.CSS_SELECTOR, value=<span class="string">&quot;div.py-3.bg-light &gt; div.container.vuln-list-container &gt; div.py-3 &gt; div.d-flex.justify-content-between.align-items-center &gt; span.text-muted&quot;</span>).text</span><br><span class="line">    <span class="keyword">if</span> debug:</span><br><span class="line">        <span class="built_in">print</span>(total[total.find(<span class="string">&quot;总计 &quot;</span>)+<span class="number">3</span>: total.find(<span class="string">&quot; 条记录&quot;</span>)])</span><br><span class="line">    total = <span class="built_in">int</span>(total[total.find(<span class="string">&quot;总计 &quot;</span>)+<span class="number">3</span>: total.find(<span class="string">&quot; 条记录&quot;</span>)])</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;正在爬取 &#123;&#125;&quot;</span>.<span class="built_in">format</span>(catalog))</span><br><span class="line">    toDo = number</span><br><span class="line">    <span class="keyword">if</span> toDo == <span class="number">0</span>:</span><br><span class="line">        toDo = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;输入要爬取的记录条数，范围为 &lt;=&#123;&#125;\n&quot;</span>.<span class="built_in">format</span>(total)))</span><br><span class="line">    hasNextPage = <span class="number">1</span></span><br><span class="line">    cnt = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> hasNextPage <span class="keyword">and</span> cnt &lt; toDo:</span><br><span class="line">        <span class="keyword">if</span> debug:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;in&quot;</span>+driver.current_url)</span><br><span class="line">        <span class="keyword">for</span> link <span class="keyword">in</span> links:  <span class="comment"># 遍历所有超链接</span></span><br><span class="line">            <span class="keyword">if</span> <span class="string">&quot;detail&quot;</span> <span class="keyword">in</span> link.get_attribute(<span class="string">&quot;href&quot;</span>):</span><br><span class="line">                link.click()  <span class="comment"># 进入cve</span></span><br><span class="line">                sleep(sleepSecond)</span><br><span class="line">                driver.switch_to.window(</span><br><span class="line">                    driver.window_handles[-<span class="number">1</span>])  <span class="comment"># 切换至新窗口</span></span><br><span class="line">                button = driver.find_elements(</span><br><span class="line">                    by=By.CSS_SELECTOR, value=<span class="string">&quot;.btn.btn-link.text-muted&quot;</span>)</span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">len</span>(button):</span><br><span class="line">                    button[<span class="number">0</span>].click()</span><br><span class="line">                genRawDoc(driver, debug)</span><br><span class="line">                cnt += <span class="number">1</span></span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;进度 &#123;&#125; / &#123;&#125;&quot;</span>.<span class="built_in">format</span>(cnt, toDo))</span><br><span class="line">                <span class="keyword">if</span> debug:</span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">&quot;in &quot;</span>+driver.title+<span class="string">&quot;  at &quot;</span>+driver.current_url)</span><br><span class="line">                    <span class="built_in">input</span>(<span class="string">&quot;continue&quot;</span>)</span><br><span class="line">                driver.close()</span><br><span class="line">                <span class="comment"># input(&quot;closed&quot;)</span></span><br><span class="line">                driver.switch_to.window(driver.window_handles[-<span class="number">1</span>])</span><br><span class="line">                <span class="keyword">if</span> debug:</span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">&quot;in &quot;</span>+driver.title+<span class="string">&quot;  at &quot;</span>+driver.current_url)</span><br><span class="line">                    <span class="comment"># input(&quot;continue&quot;)</span></span><br><span class="line">            <span class="keyword">if</span> cnt == toDo:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        nextPageButton = driver.find_elements(</span><br><span class="line">            by=By.CSS_SELECTOR, value=<span class="string">&quot;.px-3.btn.btn-sm.btn-outline-secondary.btn-bd-primary:not(.disabled)&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> debug:</span><br><span class="line">            <span class="built_in">print</span>(<span class="built_in">len</span>(nextPageButton))</span><br><span class="line">        hasNextPage = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> button <span class="keyword">in</span> nextPageButton:</span><br><span class="line">            <span class="keyword">if</span> <span class="string">&quot;下一页&quot;</span> <span class="keyword">in</span> button.text:</span><br><span class="line">                actions.key_down(Keys.CONTROL).click(</span><br><span class="line">                    button).key_up(Keys.CONTROL).perform()</span><br><span class="line">                <span class="comment"># driver.close()</span></span><br><span class="line">                sleep(sleepSecond)</span><br><span class="line">                driver.close()</span><br><span class="line">                driver.switch_to.window(driver.window_handles[-<span class="number">1</span>])</span><br><span class="line">                hasNextPage = <span class="number">1</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">    driver.quit()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这段非常长，因为爬虫定位元素基本靠手工定位，有大量重复代码，我们看关键的部分</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">driver = init_driver(<span class="string">&quot;https://avd.aliyun.com/&quot;</span>)</span><br><span class="line">Page = driver.find_element(by=By.LINK_TEXT, value=catalog)</span><br><span class="line">actions = ActionChains(driver)</span><br><span class="line">actions.key_down(Keys.CONTROL).click(Page).key_up(Keys.CONTROL).perform()  <span class="comment"># 进入漏洞库列表</span></span><br><span class="line">sleep(sleepSecond*<span class="number">1.5</span>)  <span class="comment"># 等待加载</span></span><br></pre></td></tr></table></figure>
<p><img src="/gallery/illustration/selenium0x1/1.jpg"><br>这里我们打开网站，然后网站首页有三个链接分别跳进不同分类的漏洞库，我们直接用文本定位然后在新页面打开，并且等待加载，这里不直接点击在原地跳转的原因是不知道为什么原地跳转会导致加密算法输出不正确，然后等待加载也很重要，如果不等页面完全加载完就跳转也会让加密算法输出不正确，尚不清楚原因</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">driver.switch_to.window(driver.window_handles[-<span class="number">1</span>])  <span class="comment"># 切换至漏洞库窗</span></span><br><span class="line">links = driver.find_elements(By.TAG_NAME, <span class="string">&quot;a&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>这段就是把这个页面里所有的超链接元素都抓下来</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">total = driver.find_element(</span><br><span class="line">        by=By.CSS_SELECTOR, value=<span class="string">&quot;div.py-3.bg-light &gt; div.container.vuln-list-container &gt; div.py-3 &gt; div.d-flex.justify-content-between.align-items-center &gt; span.text-muted&quot;</span>).text</span><br><span class="line">total = <span class="built_in">int</span>(total[total.find(<span class="string">&quot;总计 &quot;</span>)+<span class="number">3</span>: total.find(<span class="string">&quot; 条记录&quot;</span>)])</span><br></pre></td></tr></table></figure>
<p>这段是找下总共有多少条记录，不是很重要</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> hasNextPage <span class="keyword">and</span> cnt &lt; toDo:</span><br><span class="line">        <span class="comment">#....</span></span><br><span class="line">        nextPageButton = driver.find_elements(</span><br><span class="line">            by=By.CSS_SELECTOR, value=<span class="string">&quot;.px-3.btn.btn-sm.btn-outline-secondary.btn-bd-primary:not(.disabled)&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> debug:</span><br><span class="line">            <span class="built_in">print</span>(<span class="built_in">len</span>(nextPageButton))</span><br><span class="line">        hasNextPage = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> button <span class="keyword">in</span> nextPageButton:</span><br><span class="line">            <span class="keyword">if</span> <span class="string">&quot;下一页&quot;</span> <span class="keyword">in</span> button.text:</span><br><span class="line">                actions.key_down(Keys.CONTROL).click(</span><br><span class="line">                    button).key_up(Keys.CONTROL).perform()</span><br><span class="line">                <span class="comment"># driver.close()</span></span><br><span class="line">                sleep(sleepSecond)</span><br><span class="line">                driver.close() <span class="comment">#关闭当前页</span></span><br><span class="line">                driver.switch_to.window(driver.window_handles[-<span class="number">1</span>]) <span class="comment">#前往下一页</span></span><br><span class="line">                hasNextPage = <span class="number">1</span></span><br><span class="line">                <span class="keyword">break</span></span><br></pre></td></tr></table></figure>
<p>因为记录有很多页，我们要一页一页爬，先找到翻页按钮，然后发现能按和不能按的按钮有一个.disable类的区别，我们就一直翻直到”下一页”变成disable为止<br>然后每次点开一个新的就把老的关了</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> link <span class="keyword">in</span> links:  <span class="comment"># 遍历所有超链接</span></span><br><span class="line">            <span class="keyword">if</span> <span class="string">&quot;detail&quot;</span> <span class="keyword">in</span> link.get_attribute(<span class="string">&quot;href&quot;</span>):</span><br><span class="line">                link.click()  <span class="comment"># 进入cve</span></span><br><span class="line">                sleep(sleepSecond)</span><br><span class="line">                driver.switch_to.window(</span><br><span class="line">                    driver.window_handles[-<span class="number">1</span>])  <span class="comment"># 切换至新窗口</span></span><br><span class="line">                button = driver.find_elements(</span><br><span class="line">                    by=By.CSS_SELECTOR, value=<span class="string">&quot;.btn.btn-link.text-muted&quot;</span>)</span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">len</span>(button):</span><br><span class="line">                    button[<span class="number">0</span>].click()</span><br><span class="line">                genRawDoc(driver, debug)</span><br><span class="line">                cnt += <span class="number">1</span></span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;进度 &#123;&#125; / &#123;&#125;&quot;</span>.<span class="built_in">format</span>(cnt, toDo))</span><br><span class="line">                <span class="keyword">if</span> debug:</span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">&quot;in &quot;</span>+driver.title+<span class="string">&quot;  at &quot;</span>+driver.current_url)</span><br><span class="line">                    <span class="built_in">input</span>(<span class="string">&quot;continue&quot;</span>)</span><br><span class="line">                driver.close()</span><br><span class="line">                <span class="comment"># input(&quot;closed&quot;)</span></span><br><span class="line">                driver.switch_to.window(driver.window_handles[-<span class="number">1</span>])</span><br><span class="line">                <span class="keyword">if</span> debug:</span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">&quot;in &quot;</span>+driver.title+<span class="string">&quot;  at &quot;</span>+driver.current_url)</span><br><span class="line">                    <span class="comment"># input(&quot;continue&quot;)</span></span><br><span class="line">            <span class="keyword">if</span> cnt == toDo:</span><br><span class="line">                <span class="keyword">break</span></span><br></pre></td></tr></table></figure>
<p><img src="/gallery/illustration/selenium0x1/2.png"><br>页面里有一堆超链接，我们肯定不能每个都跳进去，发现漏洞详情的超链接里有detail关键字，我们就只找含这个关键字的跳，也是点开，转移焦点，爬数据，关闭，把焦点切回来，同样注意每次等待一会，可以防止访问量过大导致限流或者直接被封ip<br>然后跳进去后发现参考链接如果数量过多会只显示部分，要先点一下 <strong>.btn.btn-link.text-muted</strong> 的按钮把所有东西都展开<br>genRawDoc里的内容就没什么营养了，目前已经进入具体报告界面，直接定位对应内容，保存下来写入文件就行</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2025-02-25T06:47:18.000Z" title="2025/2/25 14:47:18">2025-02-25</time></span><span class="level-item">Updated&nbsp;<time dateTime="2025-04-03T12:56:51.009Z" title="2025/4/3 20:56:51">2025-04-03</time></span><span class="level-item"><a class="link-muted" href="/categories/Reverse/">Reverse</a><span> / </span><a class="link-muted" href="/categories/Reverse/Andorid/">Andorid</a></span><span class="level-item">11 minutes read (About 1612 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/ctf/Andorid/firdaApi/firdaApi/">frida常用api备忘录</a></p><div class="content"><h2 id="javascript-API"><a href="#javascript-API" class="headerlink" title="javascript API"></a>javascript API</h2><h3 id="Process"><a href="#Process" class="headerlink" title="Process"></a>Process</h3><h4 id="Process-id-number"><a href="#Process-id-number" class="headerlink" title="Process.id : number"></a>Process.id : <em>number</em></h4><p>返回目标进程的PID</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;processid = &quot;</span>, <span class="title class_">Process</span>.<span class="property">id</span>);</span><br></pre></td></tr></table></figure>
<figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">python</span> <span class="keyword">launch</span>.py </span><br><span class="line">processid =  <span class="number">3819</span></span><br></pre></td></tr></table></figure>
<h4 id="Process-arch-String"><a href="#Process-arch-String" class="headerlink" title="Process.arch : String"></a>Process.arch : <em>String</em></h4><p>返回目标进程的架构</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;processArch = &quot;</span>, <span class="title class_">Process</span>.<span class="property">arch</span>);</span><br></pre></td></tr></table></figure>
<figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">python</span> <span class="keyword">launch</span>.py </span><br><span class="line">processArch =  x64</span><br></pre></td></tr></table></figure>
<p><strong>get和find系的函数建议使用get系,在查找失败时get抛出错误,而find返回NULL</strong><br><em>Process.getModuleByAddress(address : <em><strong>NativePointer</strong></em>)</em> : <em><strong>Module</strong></em> <strong>address为实际地址</strong><br><em>Process.getModuleByName(name : <em><strong>String</strong></em>)</em> : <em><strong>Module</strong></em></p>
<p>根据地址或名称返回 <strong>已加载的</strong> 目标库(.so库)的对象(Module对象)，地址需提供原生指针</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="attr">lib</span>: <span class="title class_">Module</span> = <span class="title class_">Process</span>.<span class="title function_">getModuleByName</span>(<span class="string">&quot;liba0x9.so&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> <span class="attr">lb</span>: <span class="title class_">Module</span> = <span class="title class_">Process</span>.<span class="title function_">getModuleByAddress</span>(lib.<span class="property">base</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;lbname = &quot;</span>, lb.<span class="property">name</span>);</span><br></pre></td></tr></table></figure>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">python</span> launch.<span class="keyword">py</span></span><br><span class="line">lbname =  liba0x9.<span class="keyword">so</span></span><br></pre></td></tr></table></figure>
<h4 id="Process-enumerateModules-Module"><a href="#Process-enumerateModules-Module" class="headerlink" title="Process.enumerateModules() : Module[]"></a>Process.enumerateModules() : <em>Module[]</em></h4><p>返回所有已加载的.so库，返回内容是Module对象组成的js数组</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ls = <span class="title class_">Process</span>.<span class="title function_">enumerateModules</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; ls.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(ls[i].<span class="property">base</span>);</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(ls[i].<span class="property">name</span>);</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(ls[i].<span class="property">path</span>);</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;------&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">0x768bb30ca000</span><br><span class="line">libgraphicsenv.so</span><br><span class="line"><span class="section">/system/lib64/libgraphicsenv.so</span></span><br><span class="line"><span class="section">------</span></span><br><span class="line">0x768bb6608000</span><br><span class="line">libgui.so</span><br><span class="line">/system/lib64/libgui.so</span><br><span class="line">.....</span><br></pre></td></tr></table></figure>

<h3 id="Thread"><a href="#Thread" class="headerlink" title="Thread"></a>Thread</h3><h4 id="Thread-backtrace-context-backtracer-NativePointer"><a href="#Thread-backtrace-context-backtracer-NativePointer" class="headerlink" title="Thread.backtrace(context, backtracer) : NativePointer[]"></a>Thread.backtrace(context, backtracer) : <em>NativePointer[]</em></h4><p><strong>在java层不如直接调用android.util.log好用，主要用于追踪native层调用栈，通常加上this.context，backtracer有.FUZZY和.ACCURATE两种模式可选</strong><br>返回当前调用栈，返回类型是NativePointer组成的js数组，使用DebugSymbolfromAddress转化为可读符号</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="attr">lib</span>: <span class="title class_">Module</span> = <span class="title class_">Module</span>.<span class="title function_">load</span>(<span class="string">&quot;liba0x9.so&quot;</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(lib.<span class="title function_">enumerateExports</span>()[<span class="number">0</span>].<span class="property">name</span>);</span><br><span class="line">    <span class="title class_">Interceptor</span>.<span class="title function_">attach</span>(lib.<span class="title function_">getExportByName</span>(lib.<span class="title function_">enumerateExports</span>()[<span class="number">0</span>].<span class="property">name</span>), &#123;</span><br><span class="line">        <span class="title function_">onEnter</span>(<span class="params">args</span>) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Thread</span>.<span class="title function_">backtrace</span>(<span class="variable language_">this</span>.<span class="property">context</span>, <span class="title class_">Backtracer</span>.<span class="property">ACCURATE</span>).<span class="title function_">map</span>(<span class="title class_">DebugSymbol</span>.<span class="property">fromAddress</span>).<span class="title function_">join</span>(<span class="string">&#x27;\n&#x27;</span>));</span><br><span class="line">        &#125;, <span class="title function_">onLeave</span>(<span class="params">retval</span>) &#123;</span><br><span class="line">            retval.<span class="title function_">replace</span>(<span class="number">1337</span> <span class="keyword">as</span> <span class="built_in">any</span>);</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ python launch<span class="number">.</span>py</span><br><span class="line">Java_com_ad2001_a0x9_MainActivity_check_1flag</span><br><span class="line"><span class="number">0x768914fa0a2c</span> libart<span class="number">.</span>so!art_quick_generic_jni_trampoline+<span class="number">0xdc</span></span><br><span class="line"><span class="number">0x768914f83912</span> libart<span class="number">.</span>so!MterpHelpers+<span class="number">0x1f5</span></span><br></pre></td></tr></table></figure>

<h3 id="Module"><a href="#Module" class="headerlink" title="Module"></a>Module</h3><p>Module类本身的属性</p>
<table>
<thead>
<tr>
<th>member</th>
<th>use</th>
</tr>
</thead>
<tbody><tr>
<td>name : <em>String</em></td>
<td>库名</td>
</tr>
<tr>
<td>base : <em>NativePointer</em></td>
<td>库基地址</td>
</tr>
<tr>
<td>size : <em>number</em></td>
<td>库大小</td>
</tr>
<tr>
<td>path : <em>String</em></td>
<td>库的绝对路径</td>
</tr>
</tbody></table>
<h4 id="ModuleObj-enumerateImports-ModuleImportDetails"><a href="#ModuleObj-enumerateImports-ModuleImportDetails" class="headerlink" title="ModuleObj.enumerateImports() : ModuleImportDetails[]"></a>ModuleObj.enumerateImports() : <em>ModuleImportDetails[]</em></h4><p>返回这个库的所有导入符号,类型为ModuleImportDetails组成的js数组</p>
<h4 id="ModuleImportDetails"><a href="#ModuleImportDetails" class="headerlink" title="ModuleImportDetails"></a>ModuleImportDetails</h4><p>ModuleImportDetails类的属性</p>
<table>
<thead>
<tr>
<th>member</th>
<th>use</th>
</tr>
</thead>
<tbody><tr>
<td>type : <em>ModuleImportType</em>  (function | variable)</td>
<td>导入符号的类型</td>
</tr>
<tr>
<td>name : <em>String</em></td>
<td>导入符号的名称</td>
</tr>
<tr>
<td>module : <em>String</em></td>
<td>导入符号来自哪个文件</td>
</tr>
<tr>
<td>address : <em>NativePointer</em></td>
<td>导入符号在内存中的地址(绝对地址)，用于直接调用或修改导入函数</td>
</tr>
<tr>
<td>slot : <em>NativePointer</em></td>
<td>导入表中指向导入函数的指针,用于重定向导入函数</td>
</tr>
</tbody></table>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="attr">lib</span>: <span class="title class_">Module</span> = <span class="title class_">Module</span>.<span class="title function_">load</span>(<span class="string">&quot;liba0x9.so&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> ls = lib.<span class="title function_">enumerateImports</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(ls[<span class="number">0</span>].<span class="property">name</span>, <span class="string">&quot;from module :&quot;</span>, ls[<span class="number">0</span>].<span class="property">module</span>);</span><br></pre></td></tr></table></figure>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">python</span> launch.<span class="keyword">py</span> </span><br><span class="line">__cxa_finalize from module : /apex/<span class="keyword">com</span>.android.<span class="keyword">runtime</span>/lib64/bionic/libc.<span class="keyword">so</span></span><br></pre></td></tr></table></figure>

<h4 id="ModuleObj-enumerateExports-ModuleExportDetails"><a href="#ModuleObj-enumerateExports-ModuleExportDetails" class="headerlink" title="ModuleObj.enumerateExports() : ModuleExportDetails[]"></a>ModuleObj.enumerateExports() : <em>ModuleExportDetails[]</em></h4><p>返回这个库的所有导出符号,类型为ModuleExportDetails组成的js数组</p>
<table>
<thead>
<tr>
<th>member</th>
<th>use</th>
</tr>
</thead>
<tbody><tr>
<td>type : <em>ModuleExportType</em>  (function | variable)</td>
<td>导出符号的类型</td>
</tr>
<tr>
<td>name : <em>String</em></td>
<td>导出符号的名称</td>
</tr>
<tr>
<td>address : <em>NativePointer</em></td>
<td>导出符号在内存中的地址(绝对地址)，用于直接调用或修改导出函数</td>
</tr>
</tbody></table>
<h4 id="ModuleObj-getExportByName-exportName-String-NativePointer"><a href="#ModuleObj-getExportByName-exportName-String-NativePointer" class="headerlink" title="ModuleObj.getExportByName(exportName : String) : NativePointer"></a>ModuleObj.getExportByName(exportName : <em>String</em>) : <em>NativePointer</em></h4><p>根据名称返回对应导出符号的指针，是frida hook native层函数的主要方法</p>
<h4 id="Module-load-name-String-Module"><a href="#Module-load-name-String-Module" class="headerlink" title="Module.load(name : String) : Module"></a>Module.load(name : <em>String</em>) : <em>Module</em></h4><p>根据名称(是的就是名称，至少vsc的frida type hint 里提示的是输入名称)返回对应native库的对象，与Process.getModuleByxxx的不同是该方法无需目标库已被加载，且使用该方法可以手动加载目标库</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="attr">lib</span>: <span class="title class_">Module</span> = <span class="title class_">Module</span>.<span class="title function_">load</span>(<span class="string">&quot;libfrida0xa.so&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(lib.<span class="property">name</span>);</span><br></pre></td></tr></table></figure>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">python</span> launch.<span class="keyword">py</span></span><br><span class="line">libfrida0xa.<span class="keyword">so</span></span><br></pre></td></tr></table></figure>

<h4 id="Module-ensureInitialized-name-String-void"><a href="#Module-ensureInitialized-name-String-void" class="headerlink" title="Module.ensureInitialized(name : String) : void"></a>Module.ensureInitialized(name : <em>String</em>) : <em>void</em></h4><p>在目标库加载完成前阻塞程序进行</p>
<h4 id="Module-getBaseAddress-name-String-NativePointer"><a href="#Module-getBaseAddress-name-String-NativePointer" class="headerlink" title="Module.getBaseAddress(name : String) : NativePointer"></a>Module.getBaseAddress(name : <em>String</em>) : <em>NativePointer</em></h4><p>返回目标库的基地址,等同于Module.load(name).base</p>
<h4 id="Module-getExportByName-moduleName-String-null-exportName-String-NativePointer"><a href="#Module-getExportByName-moduleName-String-null-exportName-String-NativePointer" class="headerlink" title="Module.getExportByName(moduleName : String | null, exportName : String) : NativePointer"></a>Module.getExportByName(moduleName : <em>String</em> | null, exportName : <em>String</em>) : <em>NativePointer</em></h4><p>根据库名和符号名查找对应的导出符号，库名可缺省，此时在全局对该符号进行搜索</p>
<h3 id="Memory"><a href="#Memory" class="headerlink" title="Memory"></a>Memory</h3><h4 id="Memory-scan-address-NativePointer-size-number-pattern-String-callbacks-MemoryScanCallbacks-void"><a href="#Memory-scan-address-NativePointer-size-number-pattern-String-callbacks-MemoryScanCallbacks-void" class="headerlink" title="Memory.scan(address : NativePointer, size : number, pattern : String, callbacks : MemoryScanCallbacks) : void"></a>Memory.scan(address : <em>NativePointer</em>, size : <em>number</em>, pattern : <em>String</em>, callbacks : <em>MemoryScanCallbacks</em>) : <em>void</em></h4><p>这是一个异步函数，用于在内存中扫描对应的模式，address指定了起始地址，size指定了扫描的字节数<br>pattern是一个模式串，必须为以下任意的格式之一<br>1.完全匹配 “1F 13 00 2F”<br>2.通配符 “?F 13 00 ??” 其中?在匹配时可以是0~F中的任意一个<br>3.掩码 “”13 37 13 37 : 1F FF FF F1”” 后面的为掩码，掩码中为1的位表示需要匹配，为0的位则可以是任意值</p>
<h4 id="MemoryScanCallbacks"><a href="#MemoryScanCallbacks" class="headerlink" title="MemoryScanCallbacks"></a>MemoryScanCallbacks</h4><p><em><strong>MemoryScanCallbacks</strong></em> 是一个结构体，定义如下</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="title function_">onMatch</span>(address : <span class="title class_">NativePointer</span>, size : <span class="built_in">number</span>) : <span class="keyword">function</span>  <span class="comment">//匹配成功的回调函数，address为成功匹配的地址，size为匹配到的长度</span></span><br><span class="line">                                                                <span class="comment">//该函数可通过 return &#x27;stop&#x27; 提前结束</span></span><br><span class="line">    <span class="title function_">onError</span>(reason : <span class="title class_">String</span>) : <span class="keyword">function</span> <span class="comment">//处理错误的回调函数</span></span><br><span class="line"></span><br><span class="line">    <span class="title function_">onComplete</span>() ： <span class="keyword">function</span> <span class="comment">//匹配结束的回调函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数的同步版本为Memory.scanSync(address, size, pattern),返回由匹配到的address和size组成的对象的数组</p>
<h4 id="Memory-protect-address-NativePointer-size-number-protection-String-boolean"><a href="#Memory-protect-address-NativePointer-size-number-protection-String-boolean" class="headerlink" title="Memory.protect(address : NativePointer, size : number, protection : String) : boolean"></a>Memory.protect(address : <em>NativePointer</em>, size : <em>number</em>, protection : <em>String</em>) : <em>boolean</em></h4><p>修改对应位置内存的权限，返回true表示操作成功，protection为形同”rwx”的字符串</p>
<h4 id="Memory-patchCode-address-NativePointer-size-number-apply-function-void"><a href="#Memory-patchCode-address-NativePointer-size-number-apply-function-void" class="headerlink" title="Memory.patchCode(address : NativePointer, size : number, apply : function) : void"></a>Memory.patchCode(address : <em>NativePointer</em>, size : <em>number</em>, apply : <em>function</em>) : <em>void</em></h4><p>apply里是具体要对内存进行修改的操作，address为起始地址，size为修改区域的字节数</p>
<h3 id="NativeFunction"><a href="#NativeFunction" class="headerlink" title="NativeFunction"></a>NativeFunction</h3><p>获取native层函数的引用</p>
<h4 id="NativeFunction-address-returnType-argTypes-abi"><a href="#NativeFunction-address-returnType-argTypes-abi" class="headerlink" title="NativeFunction(address, returnType, argTypes[, abi])"></a>NativeFunction(address, returnType, argTypes[, abi])</h4><p>创建方法<br>var func &#x3D; new NativeFunction(address, returnType, argTypes[, abi])<br>address : <em>NativePointer</em> 函数地址<br>returnType : [type] 返回类型<br>argTypes : [types…] 参数类型</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> getFlag = <span class="keyword">new</span> <span class="title class_">NativeFunction</span>(getFlagPtr, [<span class="string">&#x27;void&#x27;</span>], [<span class="string">&#x27;int&#x27;</span>, <span class="string">&#x27;int&#x27;</span>]);  <span class="comment">// 用例</span></span><br></pre></td></tr></table></figure>
<p>可用类型</p>
<figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">pointer</span><br><span class="line"><span class="keyword">int</span></span><br><span class="line"><span class="keyword">uint</span></span><br><span class="line"><span class="keyword">long</span></span><br><span class="line"><span class="keyword">ulong</span></span><br><span class="line"><span class="keyword">char</span></span><br><span class="line"><span class="keyword">uchar</span></span><br><span class="line">size_t</span><br><span class="line">ssize_t</span><br><span class="line"><span class="keyword">float</span></span><br><span class="line"><span class="keyword">double</span></span><br><span class="line"><span class="keyword">int8</span></span><br><span class="line"><span class="keyword">uint8</span></span><br><span class="line"><span class="keyword">int16</span></span><br><span class="line"><span class="keyword">uint16</span></span><br><span class="line"><span class="keyword">int32</span></span><br><span class="line"><span class="keyword">uint32</span></span><br><span class="line"><span class="keyword">int64</span></span><br><span class="line"><span class="keyword">uint64</span></span><br><span class="line"><span class="keyword">bool</span></span><br></pre></td></tr></table></figure>

<h3 id="NativeCallback"><a href="#NativeCallback" class="headerlink" title="NativeCallback"></a>NativeCallback</h3><p>创建一个native函数回调并返回其指针，实际上就是由js层创建了一个native函数，可以传给native层<br>与 <strong>NativeFunction</strong> 的区别是 <strong>NativeFunction</strong> 是从native层到js层，而 <strong>NativeCallback</strong> 是创建自己的原生函数<br>创建方法<br>new NativeCallback(func, returnType, argTypes[, abi])<br>func是函数的js实现，其他和 <strong>NativeFunction</strong> 均相同</p>
<h3 id="Interceptor"><a href="#Interceptor" class="headerlink" title="Interceptor"></a>Interceptor</h3><p>frida最重要的模块之一，用于hook native函数，</p>
<h4 id="Interceptor-attach-target-callbacks"><a href="#Interceptor-attach-target-callbacks" class="headerlink" title="Interceptor.attach( target , callbacks )"></a>Interceptor.attach( target , callbacks )</h4><p>target 为 <strong>NativePointer</strong> ,<br>callback为 {onEnter: <em><strong>Function(args)</strong></em> , onLeave: <em><strong>Function (retval)</strong></em> }的经典组合<br>注意此处虽然大多数情况下是hook函数，但是只要访问目标地址就会触发回调，所以也可以用base+offset来跟踪特定位置的内存<br><strong>Interceptor.attach</strong> 同样会返回一个对当前拦截器的引用，可以调用self.detach()方法解除当前拦截器</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 该拦截器在触发第6次hook后会自动解除</span></span><br><span class="line"><span class="keyword">var</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> cnthook = <span class="title class_">Interceptor</span>.<span class="title function_">attach</span>(lib.<span class="property">base</span>.<span class="title function_">add</span>(<span class="number">0x170B8</span>), &#123;</span><br><span class="line">        <span class="attr">onEnter</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;some memory accessed&quot;</span>);</span><br><span class="line">            cnt++;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(cnt)</span><br><span class="line">            <span class="keyword">if</span> (cnt &gt; <span class="number">5</span>) &#123;</span><br><span class="line">                cnthook.<span class="title function_">detach</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure>
<p>TODO:<br>Interceptor<br>Java<br>XXXWriter<br>XXXRelocator<br>hexdump<br>rpc.exports<br>Timing events</p>
<!-- ### Interceptor -->
<h2 id="Python-API"><a href="#Python-API" class="headerlink" title="Python API"></a>Python API</h2><p>frida的python层主要负责拉起进程以及与js通信，涉及的业务逻辑并不多</p>
<h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a target="_blank" rel="noopener" href="https://frida.re/docs/javascript-api/">Frida 官方文档</a><br><a target="_blank" rel="noopener" href="https://github.com/DERE-ad2001/Frida-Labs/tree/main">Frida-Labs</a></p>
</div></article></div><nav class="pagination" role="navigation" aria-label="pagination"><div class="pagination-previous"><a href="/">Previous</a></div><div class="pagination-next is-invisible is-hidden-mobile"><a href="/page/3/">Next</a></div><ul class="pagination-list is-hidden-mobile"><li><a class="pagination-link" href="/">1</a></li><li><a class="pagination-link is-current" href="/page/2/">2</a></li></ul></nav></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar is-rounded" src="/img/avatar.jpg" alt="SGSG"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">SGSG</p><p class="is-size-6 is-block">Security &amp; Development</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Utopia</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">Posts</p><a href="/archives/"><p class="title">16</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Categories</p><a href="/categories/"><p class="title">8</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Tags</p><a href="/tags/"><p class="title">6</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/SGSGsama" target="_blank" rel="me noopener">Follow</a></div></div></div><!--!--><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">Links</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://hexo.io" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Hexo</span></span><span class="level-right"><span class="level-item tag">hexo.io</span></span></a></li></ul></div></div></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">Categories</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/Development/"><span class="level-start"><span class="level-item">Development</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/Reverse/"><span class="level-start"><span class="level-item">Reverse</span></span><span class="level-end"><span class="level-item tag">13</span></span></a><ul><li><a class="level is-mobile" href="/categories/Reverse/Andorid/"><span class="level-start"><span class="level-item">Andorid</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Reverse/LLVM/"><span class="level-start"><span class="level-item">LLVM</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Reverse/basic/"><span class="level-start"><span class="level-item">basic</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/Reverse/ctf-test/"><span class="level-start"><span class="level-item">ctf-test</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/categories/Reverse/%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86-%E7%BC%96%E7%A0%81/"><span class="level-start"><span class="level-item">对称加密&amp;编码</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/%E6%9D%82%E9%A1%B9/"><span class="level-start"><span class="level-item">杂项</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">Tags</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/Andorid/"><span class="tag">Andorid</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Python/"><span class="tag">Python</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Reverse/"><span class="tag">Reverse</span><span class="tag">13</span></a></div><div class="control"><a class="tags has-addons" href="/tags/codeforces/"><span class="tag">codeforces</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/selenium/"><span class="tag">selenium</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%8A%A0%E5%AF%86-%E7%BC%96%E7%A0%81/"><span class="tag">加密&amp;编码</span><span class="tag">4</span></a></div></div></div></div></div><div class="column-right-shadow is-hidden-widescreen"></div></div><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only order-3"><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">Recents</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-04-08T07:31:54.000Z">2025-04-08</time></p><p class="title"><a href="/ctf/%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86/XTEA/">XTEA</a></p><p class="categories"><a href="/categories/Reverse/">Reverse</a> / <a href="/categories/Reverse/%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86-%E7%BC%96%E7%A0%81/">对称加密&amp;编码</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-04-08T06:31:39.000Z">2025-04-08</time></p><p class="title"><a href="/ctf/%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86/TEA/">TEA</a></p><p class="categories"><a href="/categories/Reverse/">Reverse</a> / <a href="/categories/Reverse/%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86-%E7%BC%96%E7%A0%81/">对称加密&amp;编码</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-04-07T11:30:47.000Z">2025-04-07</time></p><p class="title"><a href="/ctf/%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%E7%B2%BE%E8%AF%BB%E7%9B%AE%E5%BD%95/">加密&amp;编码算法精读目录</a></p><p class="categories"><a href="/categories/Reverse/">Reverse</a> / <a href="/categories/Reverse/%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86-%E7%BC%96%E7%A0%81/">对称加密&amp;编码</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-04-07T11:29:59.000Z">2025-04-07</time></p><p class="title"><a href="/ctf/%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86/RC4/">RC4</a></p><p class="categories"><a href="/categories/Reverse/">Reverse</a> / <a href="/categories/Reverse/%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86-%E7%BC%96%E7%A0%81/">对称加密&amp;编码</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-04-07T09:11:59.000Z">2025-04-07</time></p><p class="title"><a href="/ctf/WP/NPCCTF%202025%20base/">NPCCTF 2025 base</a></p><p class="categories"><a href="/categories/Reverse/">Reverse</a> / <a href="/categories/Reverse/ctf-test/">ctf-test</a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">Archives</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2025/04/"><span class="level-start"><span class="level-item">April 2025</span></span><span class="level-end"><span class="level-item tag">9</span></span></a></li><li><a class="level is-mobile" href="/archives/2025/03/"><span class="level-start"><span class="level-item">March 2025</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile" href="/archives/2025/02/"><span class="level-start"><span class="level-item">February 2025</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></div></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="SGSG&#039;s Blog" height="28"></a><p class="is-size-7"><span>&copy; 2025 SGSG</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("en");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script data-pjax src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="Back to top" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script data-pjax src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "This website uses cookies to improve your experience.",
          dismiss: "Got it!",
          allow: "Allow cookies",
          deny: "Decline",
          link: "Learn more",
          policy: "Cookie Policy",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><script type="text/javascript" id="MathJax-script" async>MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']]
      },
      svg: {
        fontCache: 'global'
      },
      chtml: {
        matchFontHeight: false
      }
    };</script><script src="https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js"></script><script src="/js/pjax.js"></script><!--!--><!--!--><!--!--><script data-pjax src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="Type something..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script data-pjax src="/js/insight.js" defer></script><script data-pjax>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"Type something...","untitled":"(Untitled)","posts":"Posts","pages":"Pages","categories":"Categories","tags":"Tags"});
        });</script></body></html>