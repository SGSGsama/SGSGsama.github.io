{"posts":[{"title":"bn脚本笔记","text":"由于BinaryNinja脚本的官方文档完全就是把api按字典序堆在一起，故开一篇随笔存一些常见api的使用方法，随机更新中 笔记中所有的bv均为BinaryView类，即与bn交互的主要接口 bv.instructions返回当前二进制文件的所有指令，返回形式为元组组成的列表，元组的第一个元素为该指令的Token按空格切片形成的列表，第二个元素为指令地址这个token有很多附加的属性(或者说解释的方式，比如token.text就是返回文本,token.value就是把token按数值转换为int (假设这个token是数值))，不只是单纯的text，在简单输出时体现为text 12for instruction in bv.instructions: print(instruction) bv.linear_disassembly和 bv.instructions 很像，但是这个真就是直接把指令文本一条条打出来，返回的是一个迭代器 bv.get_instruction_length(addr : int)返回目标地址指令的长度 1234for instruction in bv.instructions: if instruction[0][0].text == 'jz' or instruction[0][0].text == 'jnz': print(instruction[0][0]) print(&quot;len = &quot;, bv.get_instruction_lengt(instruction[1])) bv.write(addr : int ,data : bytes)直接往目标地址覆写一段数据，patch的主要手段 bv.read(addr : int ,length : int)读取以目标地址为起点一定长度的数据，返回字节流(bytes)","link":"/ctf/BinaryNinjaScript/"},{"title":"反调试笔记","text":"反调试是逆向工程中的常见对抗手段，这篇笔记总结了一些各种平台常见的调试检测手段，随机更新中 IsDebuggerPresent()特征最明显的反调试，因为是windows系统api所以也没法隐藏，直接读NtCurrentPeb上的beingdebugged标志，如果被调试就返回1 *(NtCurrentPeb+0x2) ( beingdebugged Flag )是上面这条的变体，实际上beingdebugged标志就在NtCurrentPeb+0x2的位置上 *(NtCurrentPeb+0x68) ( NtGlobalFlag )当进程被调试器启动时这个标志会被设置为0x70 (实际上是三个堆相关的标志被设置为111) NtCurrentPeb()-&gt;ProcessParameters-&gt;DebugFlags进程启动参数，这个标志为1时说明在被调试 NtCurrentPeb()-&gt;ProcessParameters-&gt;DebugPort调试对象的句柄，如果这个值不为NULL说明有对象在调试该进程 NtCurrentPeb()-&gt;ProcessHeap这个位置有两个标志Flags和ForceFlags用于告诉内核这个堆是否是在调试器中被创建的，正常情况下Flag=2,ForceFlags=032位windows中 Flags位于ProcessHeap+0xC ,ForceFlags位于ProcessHeap+0x1064位windows中 Flags位于ProcessHeap+0x70 ,ForceFlags位于ProcessHeap+0x74 OutputDebugString()这个函数会向调试器中输出一段字符串，如果当前程序没有被调试就会更新当前程序的错误码可以配合SetLastError先将错误码设置为一个预设值，然后调用该函数更新错误码，再用GetLastError获取新的错误码，如果新的错误码和旧的一样说明这个函数没有报错，就说明调试器存在 ZwSetInformationThread(ThreadHideFromDebugger)这个函数可以设置当前线程的一些信息，主要是优先级之类的，他的参数是一个枚举类，其中ThreadHideFromDebugger这个选项会把当前线程从调试器中抹掉，具体实现就是把DebugPort置为NULL(疑似有点草台) 扫描0xCC (int 3 指令)软件断点的工作原理是将断点位置的指令替换为 int 3 指令(编码为0xCC)，当调试器遇到 int 3 时就调用调试异常中断执行在程序执行时扫描全程序是否有0xCC就可以检测到是否存在软件断点该方法无法检测硬件断点，因为硬件断点并不修改程序指令注意到软件断点需要修改指令，所以烧录在rom中的程序无法下软件断点 PS1. 硬件断点硬件断点是用寄存器实现的断点，直接在调试寄存器中保存断点的地址，当PC跑到对应位置时中断执行，断点的数量受限于调试寄存器的数量 GetThreadContext(hThread,lpContext)这个函数可以获取对应线程的上下文信息，如果lpContext中读取的DRx系列寄存器(调试寄存器)的值不为0说明存在硬件断点，可以据此检测硬件断点 哈希校验直接计算整个程序机器码的哈希值，与正常情况下的预设值进行校验，因为软件断点会插入int 3，所以调试状态下哈希值会有不同 rdstcrdstc 可以获取cpu开机起经历的时钟周期，调用两次该函数就可以获取一段操作经历的时间，如果时间过长可以猜测存在调试器，因为调试器会极大影响程序性能 父进程检测一般正常用户态运行的程序只可能是由几个系统服务或者已知的程序启动的(cmd,explorer.exe…..)，可以通过th32ParentProcessID获取父进程的PID，在与系统中所有进程的PID进行比对，如果父进程不在上述的范围内则可以推断进程在被调试 基于VEH，SEH的反调试这个反调试其实还是利用了上述反调试的逻辑，只不过把检测的代码藏在异常处理的逻辑里，然后再手动触发一个异常来进入这段逻辑，一般直接搜索VEH就可以搜到设置veh的地方，进而找到用户自定义的handler,SEH可以去反汇编软件中寻找except包裹的部分。因为异常处理逻辑通常要跳过垃圾代码，所以这种异常通常不会选择传递给调试器(就算传给调试器调试器也会卡在垃圾代码里)，所以也可能会把一些加密的逻辑藏在异常处理中(说白了还是增加翻代码的难度，并没有什么新鲜的) SetUnhandledExceptionFilterSetUnhandledExceptionFilter()函数接受一个winapi的异常过滤器函数作为参数用来设置自定义的异常过滤器，当正常运行时，windows让异常过滤器先接管未处理的异常，此时过滤器内可以做加密相关的操作，也可以做处理异常的操作，但是调试模式下所有的异常就会传递给调试器(现代调试器已经有选择由app处理异常的选项)，此时我们又没有写处理异常的逻辑，调试器就会直接卡住 123456SetUnhandledExceptionFilter(CustomUnhandledExceptionFilter);__try{ int* p = NULL; *p = 1; }//没有 except","link":"/ctf/%E5%8F%8D%E8%B0%83%E8%AF%95/"},{"title":"kotlin备忘录速记","text":"记录一些速查的kotlin高频函数和API，省的太久不写忘了 定义约定常量1val Name : Type = initVal 变量var Name : Type = initVal 函数123(override... 修饰符) fun Name (para:paraType = deafultVal) : return Type{ } 可为null123456789val Name : Type? = initVal/null// 如果显式设置了类型,只有类型名后加?才可设为nullName!!.member // !!后缀表示断言该量一定不为null // 条件表达式也可以智能推断是否为null //val Name : Type = null?:deafultVal// ?:是 Elvis运算符，当运算符左侧的值为null时返回运算符右侧设置的默认值 类1234567891011// 主构造函数，参数前加val/var则无需在类主体中再次定义该成员// open说明该类可被继承// 父类的构造函数的调用接在主构造函数后// 实现的接口接在父构造函数后，用逗号链接(open) class Name(val member:Type,...) : FatherClassConstructor(para),interface{ val member = initVal get() set() // get,set为内置关键字，可选，紧跟在对应成员后 constructor(para):this(para)//重载构造函数，如果需要给主构造函数补参数} 修饰符123456class ClassName(){ public val member1 // 默认修饰符，可以任意访问 private val member2 // 仅可在类内部访问 protected val member3 // 只能被子类访问 internal val member4 // 只能在同一文件中被访问} 定义委托123var Name by delegateObject// 把变量的getter和setter委托给自定义类(即重载变量的getter和setter)// 委托类需实现ReadWriteProperty&lt;Any?, Type&gt;或ReadOnlyProperty&lt;Any?&gt;接口 储存函数1234567fun myFunc(){ ...}fun main(){ val FunctionVal = ::myFunc // 将函数作为变量存储须在函数名前加::} lambda1234567891011121314val Name:(paraType) -&gt; returnType = { para -&gt; body// 后置lambda语法// myFunc(Int,Int,(Int,Int)-&gt;Int)// 当函数的最后一个参数是lambda时可以在调用函数时直接把lambda写在调用后面myFunc(1,2){ x,y -&gt; x+y}}val 函数数据类型约定1(paraType1,ParaType2...) -&gt; returnType 泛型(模板类)约定12345class tempClass&lt;T&gt;(val para:Type,val tempPara:T){}val Name = tempClass&lt;Int&gt;(para1,2) 枚举类约定1234567enum class Name{ enumName1,enumName2}val enumNum:Name = Name.enumName1 数据类约定1234data class Name(val value1:Type,val value2:Type...){}//专用于处理数据的类，没有任何执行操作的方法//编译器会自动实现equals()，hashCode()，toString()，componentN()：component1()、component2() ... ，copy()这些方法 单例对象约定123object Name{}和类相同，但是全局只存在一个实例，且无须自己创建，必须在定义时就初始化 定义拓展属性12345678val typeName.extendPropertyName : dataTypeget()//为拓展属性设置getterfun typeName.extendFunctionName(para...) : returnType{}//拓展属性只能读取不能写入 接口12345interface InterfaceName{ val member:Type fun function(para):return Type //接口只声明不实现，继承接口的类必须实现接口声明的所有内容(override)} 分支约定if-else123456if(condition){}else{} when123456when(para){ condition1 -&gt; {body1} condition2 -&gt; {body2} .....} 特殊约定分支，lambda返回值分支,lambda的最后一个表达式的值会作为整个结构的返回值 123456789x= if(true){ &quot;1&quot;}else{ &quot;0&quot;}// x=&quot;1&quot;x={2} // x=2 字符串中嵌入表达式1&quot;x= ${x.value}&quot; 使用${}向字符串嵌入表达式 帮手函数repeat(times: Int, action: (Int) -&gt; Unit)重复执行某一操作，传入一个lambda，有一个从0开始的迭代器参数 12345678repeat(5){ it -&gt; println(it)}// 0// 1// 2// 3// 4 let()1234567891011//before letprintln(Obj.member1)println(Obj.member2)println(Obj.member3)// after letObj.let{ println(it.member1) println(it.member2) println(it.member3)} let后接一个lambda函数，可以把let前的对象用it关键字简写lambda 最后一条语句的返回值会被作为let的返回值 apply()1234567891011Obj.apply{ this.member= .... this.initFunc()}// hint : 可以实现链式调用Obj.apply{ member1 = ...}.apply{ member2 = ...}..... 对目标对象做一系列操作，通过this访问目标对象，返回操作完的目标对象 forEach(action: (T) -&gt; Unit)forEach传入一个lambda，对目标集(List,set…)中的每一个元素执行该lambda 12345val test1=setOf(1,2,3,4,5) test1.forEach{ println(it) }// 1,2,3,4,5 数据管理数组 array123val array = arrayOf&lt;Type&gt;(elem1,elem2,....) // 使用arrayOf初始化，单一类型，长度不可变println(array[0]) // 使用下标访问val arrry12 = array1+array2 //拼接两个数组 列表(可变长数组) list1234567891011121314val aList=listOf(1,2,true,&quot;123&quot;) // 使用listOf初始化，可以混合类型，不可修改元素，不可增减元素println(aList.size) // 查询长度println(aList[0]) // 下标访问println(aList.indexOf(&quot;123)) // 3 ,若未找到返回-1for (elem in aList) { // 使用 for 遍历}anotherList=mutableListOf(1,2,true,&quot;123&quot;) // 可修改的列表anotherList.add(&quot;4&quot;) // [1,2,true,&quot;123&quot;,&quot;4&quot;] //向末尾添加元素anotherList.add(2,&quot;4&quot;) // [1,2,&quot;4&quot;,true,&quot;123&quot;,&quot;4&quot;] // 向中间插入anotherList.removeAt(0) // [2,&quot;4&quot;,true,&quot;123&quot;,&quot;4&quot;] // 按下标删除anotherList.remove(&quot;123&quot;) // [2,&quot;4&quot;,true,&quot;4&quot;] // 按值删除anotherList.contains(2) //查询是否存在2 in anotherList // 前者的另一写法 集合 setSet / mutableSet 同样 不可修/可修 123val aSet=mutableSetOf(&quot;123&quot;,true,32)// 有add，remove，contain，size，没有下标操作// 基于每个类的hashCode()实现 映射 mapMap / mutableMap 同样 不可修/可修 1234567val aMap=mutableMapOf( &quot;cake&quot; to 10, &quot;cookie&quot; to 5, true to 22)println(aMap[&quot;cake&quot;]) // 10 通过key访问value，不存在的key会返回null// 有size属性 Referencehttps://developer.android.com/courses/android-basics-compose/course","link":"/development/kotlin_beginer/"},{"title":"花指令笔记","text":"花指令是逆向工程中常见的对抗手法，这篇笔记整理了一些常见的花指令样本供参考，随机更新中 基于call-return修改rip的花指令call指令是一种复合指令，它会在跳转至目标地址前将下一条指令对应的地址压栈，然后在return是弹栈恢复rip，如果在return前修改栈上的数据，就可以达到修改rip的效果这是一个经典的样本，通过call跳转后把esp(栈顶)对应的值加上一定偏移，经过计算可以知道return后rip会被修改为0x413A6A+0x8=0x413A72，也就是说从0x413A65到0x413A71的这一段都是垃圾数据所以直接nop这一段可以看到nop完后线性扫描自动分析出了下面的代码 基于jz,jnz的花指令利用两个连续的jz,jnz指令可以构造出必定执行的跳转，然后中间塞垃圾数据，但是静态分析工具无法分析这种跳转，而且线性扫描扫到垃圾数据反汇编就直接炸了，修复方式也很简单，直接吧jz/jnz到跳转地址前的所有指令nop掉就行了，因为肯定不会执行到 基于 xor,cmp,jz的花指令同样是构造必定执行的跳转，以下是一种示例先保存ebx寄存器，然后把ebx寄存器置0，这样jz就必然执行，跳过垃圾数据后再恢复ebx的值 如何编写花指令编写花指令可以通过内联汇编的形式，以下是一种示例(g++) 123456789#include &lt;iostream&gt;int main(){ asm volatile(&quot;jz lable1\\n\\t&quot; &quot;jnz lable1\\n\\t&quot; &quot;.byte 0xE8, 0x23,0x24,0x25,0x26,0x27,0x28\\n\\t&quot; &quot;lable1:\\n\\t&quot;); std::cout &lt;&lt; &quot;test&quot;;} 其中 volatile 参数可以防止编译器把花指令优化掉同时在编译时要加上-fno-asynchronous-unwind-tables-fno-exceptions-fno-rtti等编译参数去除调试信息，否则反编译工具可以借助这些信息提供的控制流信息绕过花指令","link":"/ctf/%E8%8A%B1%E6%8C%87%E4%BB%A4/"},{"title":"selenium爬虫入门","text":"简介selenium是基于浏览器DevTool模拟用户态行为的爬虫框架，与传统爬虫相比selenium最大的优点就是可以通过模拟行为绕过大部分的反爬，同时因为其本身基于浏览器，在对抗加密方面有天然的优势 常用APIwebDriver.Chrome.Options() : Option返回一个 option 对象，用于在之后为浏览器提供选项参数，最常见的用法如下 12options = webdriver.ChromeOptions()options.add_argument(&quot;disable-blink-features=AutomationControlled&quot;) 这段代码为option添加了一个参数将浏览器的 webdriver 属性置为false，该属性常用于检测浏览器是否处于调试模式，常见的反爬会检测该属性，该属性为true则会触发反爬此外还可以添加包括但不限于下列的属性，但用处都不大 123--disable-gpu # 禁用gpu加速--headless # 将浏览器设置为无头浏览器--windows-size=1920,1080 #设置浏览器窗口大小 webdriver.Chrome(options : Option ) : WebDriver创建一个浏览器对象，所有与浏览器的交互都会通过这个对象进行 1driver = webdriver.Chrome(options=options) driver.get(url : str ) : void打开一个页面 driver.find_element(by: str , value : str ) : WebElement在webdriver目前聚焦的页面中寻找对应html元素，并返回一个可以对找到的元素进行交互的对象， by 是 selenium.webdriver.common.by 中的枚举类， value 是搜索对应的值或表达式，这里只介绍 By.CSS_SELECTOR 和 By.LINK_TEXT，个人认为算是最通用的方法。这个方法只返回找到的第一个元素，且找不到则抛出错误，另一个类似的方法是 driver.find_elements 返回所有找到的元素，如果找不到就返回空列表 By.CSS_SELECTOR 利用CSS选择器查找元素，value 应为一个CSS选择器表达式下面是一些示例 12345678910111213value = &quot;div&quot; # 单独的名字表示筛选特定tag的元素value = &quot;.targetClass&quot; # class名前带.表示筛选带特定类的元素value = &quot;#ID&quot; # ID前带#表示筛选含特定id的元素value = &quot;[attribute]&quot; # 筛选带具备特定属性的元素value = '[attribute=&quot;value&quot;]' # 筛选带特定属性且属性值为value的元素，其中&quot;&quot;不可省略和替换value = &quot;div.targetClass#ID&quot; # 选择含多个条件的元素则将所有条件不加空格地组合在一起value = &quot;div#fatherDiv div#sonDiv&quot; # 如果要选择某个元素的后代元素则将两个元素的筛选条件以空格隔开value = &quot;div#faterDiv &gt; div#directSonDiv&quot; # 如果要选择直属于某个元素的子元素则在两个元素的筛选条件之间额外加入 &gt;value = &quot;:not()&quot; # 选择不符合特定条件的元素，()中可以嵌套另一个CSS选择器表达式 # 比如 &quot;div:not(.disabled)&quot; ,选择不为disable类的div元素 By.LINK_TEXT 筛选文本为 value 的&lt;a&gt;元素即超链接元素，执行严格匹配，另一个类似的方法是 By.PARTIAL_LINK_TEXT，只需提供的 value 是目标的子串就行，此方法用于快捷定位特定超链接对应的元素，方便爬虫在页面间进行跳转 1Page = driver.find_element(by=By.LINK_TEXT, value=&quot;下一页&quot;) # 这样我们就定位到了一个翻页按钮，可以用click之类的方法让我们的爬虫翻页 ActionChains(driver : WebDriver ) : ActionChains这是selenium提供的动作链类，用于模拟用户的操作输入 1234567actions = ActionChains(driver) # 指定所属的webdriver，还可以指定duration属性来控制每次操作的时间，用来绕过针对仿真行为的反爬actions.key_down(Keys.CONTROL).click( Page).key_up(Keys.CONTROL).perform() # 这个操作就模拟了ctrl+左键，即在新页面打开对应链接 # 使用连续调用来设计动作链，最后调用perform()执行 # click之类的要指定具体点击的webElement，否则点击鼠标指针所在位置 # 按键类的动作可以用selenium.webdriver.common.keys中的Keys枚举类来模拟按下ctrl之类的功能键，其他按键直接输入对应字符即可 driver.switch_to.window(window_name : str ) : void将浏览器的焦点切换至另一个页面，其中 window_name 可以通过 driver.window_handles 获取，这是webdriver类的一个列表成员，储存了当前浏览器所有窗口的 window_name 12driver.switch_to.window(driver.window_handles[-1]) # 切换至最右边的窗口，事实上这个列表里句柄的排列顺序是按窗口打开顺序排列的 driver.close() : void当一个页面的数据爬完了可能要关闭该页面，用close方法就能把当前页面关掉，但是注意driver并 不会自动切换聚焦到新窗口 ，所以close后要调用switch_to.window把焦点转移到新窗口 driver.quit() : void直接关闭浏览器 项目实战项目地址 =&gt; 基于selenium框架爬取avd.aliyun.com上的漏洞报告 阿里云的漏洞网站用了很恶心的加密算法，把本机的时间戳套了一堆加密做成token放进payload里做验证，如果验证不通过就无法进入漏洞库和漏洞报告，我们直接上selenium，只要我们全程模拟用户态行为就不用管加密，这点和逆向工程中的动态调试非常像，本质上是利用了应用自加密/自解密的性质 下面直接上代码 12345678#utility.pydef init_driver(url: str): options = webdriver.ChromeOptions() options.add_argument(&quot;disable-blink-features=AutomationControlled&quot;) driver = webdriver.Chrome(options=options) driver.get(url) return driver 他的加密算法会在加载时就读取 webdriver 标记的值，并且这个参数会被用于加密过程，如果是undefined或者true加密跑出来就是错的，而且非常恶心的是他并不直接从 navigator.webdriver 实时读取，而是加载时检测到 webdriver 不为false就让加密胡乱输出，所以我们加一个参数在网页加载前就把 webdriver 标记设置成false 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#Crawler.pydef runCrawler(catalog: str, number: int = 0, debug: bool = 0, sleepSecond: float = 1): ''' sleepSecond为每跳转一个页面的等待时长，过短可能会触发限流或反爬\\n 如果cve的命名不符合windows文件命名规范则会转换为url命名输出\\n catalog为要爬取的漏洞库的按钮文本{&quot;CVE 漏洞库&quot;,&quot;非CVE漏洞库&quot;,&quot;高危漏洞&quot;}\\n number为爬取的记录数量，若不指定则在调用函数时提示输入 ''' driver = init_driver(&quot;https://avd.aliyun.com/&quot;) Page = driver.find_element(by=By.LINK_TEXT, value=catalog) if debug: print(&quot;in &quot;+driver.title+&quot; at &quot;+driver.current_url) # input(&quot;continue&quot;) actions = ActionChains(driver) actions.key_down(Keys.CONTROL).click( Page).key_up(Keys.CONTROL).perform() # 进入漏洞库列表 sleep(sleepSecond*1.5) # 等待加载 if debug: print(&quot;sleep finished&quot;) driver.switch_to.window(driver.window_handles[-1]) # 切换至漏洞库窗口 links = driver.find_elements(By.TAG_NAME, &quot;a&quot;) # print(len(links)) if debug: # print(driver.window_handles) print(&quot;in &quot;+driver.title+&quot; at &quot;+driver.current_url) # input(&quot;continue&quot;) total = driver.find_element( by=By.CSS_SELECTOR, value=&quot;div.py-3.bg-light &gt; div.container.vuln-list-container &gt; div.py-3 &gt; div.d-flex.justify-content-between.align-items-center &gt; span.text-muted&quot;).text if debug: print(total[total.find(&quot;总计 &quot;)+3: total.find(&quot; 条记录&quot;)]) total = int(total[total.find(&quot;总计 &quot;)+3: total.find(&quot; 条记录&quot;)]) print(&quot;正在爬取 {}&quot;.format(catalog)) toDo = number if toDo == 0: toDo = int(input(&quot;输入要爬取的记录条数，范围为 &lt;={}\\n&quot;.format(total))) hasNextPage = 1 cnt = 0 while hasNextPage and cnt &lt; toDo: if debug: print(&quot;in&quot;+driver.current_url) for link in links: # 遍历所有超链接 if &quot;detail&quot; in link.get_attribute(&quot;href&quot;): link.click() # 进入cve sleep(sleepSecond) driver.switch_to.window( driver.window_handles[-1]) # 切换至新窗口 button = driver.find_elements( by=By.CSS_SELECTOR, value=&quot;.btn.btn-link.text-muted&quot;) if len(button): button[0].click() genRawDoc(driver, debug) cnt += 1 print(&quot;进度 {} / {}&quot;.format(cnt, toDo)) if debug: print(&quot;in &quot;+driver.title+&quot; at &quot;+driver.current_url) input(&quot;continue&quot;) driver.close() # input(&quot;closed&quot;) driver.switch_to.window(driver.window_handles[-1]) if debug: print(&quot;in &quot;+driver.title+&quot; at &quot;+driver.current_url) # input(&quot;continue&quot;) if cnt == toDo: break nextPageButton = driver.find_elements( by=By.CSS_SELECTOR, value=&quot;.px-3.btn.btn-sm.btn-outline-secondary.btn-bd-primary:not(.disabled)&quot;) if debug: print(len(nextPageButton)) hasNextPage = 0 for button in nextPageButton: if &quot;下一页&quot; in button.text: actions.key_down(Keys.CONTROL).click( button).key_up(Keys.CONTROL).perform() # driver.close() sleep(sleepSecond) driver.close() driver.switch_to.window(driver.window_handles[-1]) hasNextPage = 1 break driver.quit() 这段非常长，因为爬虫定位元素基本靠手工定位，有大量重复代码，我们看关键的部分 12345driver = init_driver(&quot;https://avd.aliyun.com/&quot;)Page = driver.find_element(by=By.LINK_TEXT, value=catalog)actions = ActionChains(driver)actions.key_down(Keys.CONTROL).click(Page).key_up(Keys.CONTROL).perform() # 进入漏洞库列表sleep(sleepSecond*1.5) # 等待加载 这里我们打开网站，然后网站首页有三个链接分别跳进不同分类的漏洞库，我们直接用文本定位然后在新页面打开，并且等待加载，这里不直接点击在原地跳转的原因是不知道为什么原地跳转会导致加密算法输出不正确，然后等待加载也很重要，如果不等页面完全加载完就跳转也会让加密算法输出不正确，尚不清楚原因 12driver.switch_to.window(driver.window_handles[-1]) # 切换至漏洞库窗links = driver.find_elements(By.TAG_NAME, &quot;a&quot;) 这段就是把这个页面里所有的超链接元素都抓下来 123total = driver.find_element( by=By.CSS_SELECTOR, value=&quot;div.py-3.bg-light &gt; div.container.vuln-list-container &gt; div.py-3 &gt; div.d-flex.justify-content-between.align-items-center &gt; span.text-muted&quot;).texttotal = int(total[total.find(&quot;总计 &quot;)+3: total.find(&quot; 条记录&quot;)]) 这段是找下总共有多少条记录，不是很重要 1234567891011121314151617while hasNextPage and cnt &lt; toDo: #.... nextPageButton = driver.find_elements( by=By.CSS_SELECTOR, value=&quot;.px-3.btn.btn-sm.btn-outline-secondary.btn-bd-primary:not(.disabled)&quot;) if debug: print(len(nextPageButton)) hasNextPage = 0 for button in nextPageButton: if &quot;下一页&quot; in button.text: actions.key_down(Keys.CONTROL).click( button).key_up(Keys.CONTROL).perform() # driver.close() sleep(sleepSecond) driver.close() #关闭当前页 driver.switch_to.window(driver.window_handles[-1]) #前往下一页 hasNextPage = 1 break 因为记录有很多页，我们要一页一页爬，先找到翻页按钮，然后发现能按和不能按的按钮有一个.disable类的区别，我们就一直翻直到”下一页”变成disable为止然后每次点开一个新的就把老的关了 123456789101112131415161718192021222324for link in links: # 遍历所有超链接 if &quot;detail&quot; in link.get_attribute(&quot;href&quot;): link.click() # 进入cve sleep(sleepSecond) driver.switch_to.window( driver.window_handles[-1]) # 切换至新窗口 button = driver.find_elements( by=By.CSS_SELECTOR, value=&quot;.btn.btn-link.text-muted&quot;) if len(button): button[0].click() genRawDoc(driver, debug) cnt += 1 print(&quot;进度 {} / {}&quot;.format(cnt, toDo)) if debug: print(&quot;in &quot;+driver.title+&quot; at &quot;+driver.current_url) input(&quot;continue&quot;) driver.close() # input(&quot;closed&quot;) driver.switch_to.window(driver.window_handles[-1]) if debug: print(&quot;in &quot;+driver.title+&quot; at &quot;+driver.current_url) # input(&quot;continue&quot;) if cnt == toDo: break 页面里有一堆超链接，我们肯定不能每个都跳进去，发现漏洞详情的超链接里有detail关键字，我们就只找含这个关键字的跳，也是点开，转移焦点，爬数据，关闭，把焦点切回来，同样注意每次等待一会，可以防止访问量过大导致限流或者直接被封ip然后跳进去后发现参考链接如果数量过多会只显示部分，要先点一下 .btn.btn-link.text-muted 的按钮把所有东西都展开genRawDoc里的内容就没什么营养了，目前已经进入具体报告界面，直接定位对应内容，保存下来写入文件就行","link":"/development/selenium0x1/"},{"title":"ACM刷题日记","text":"想起来去年还在打acm的时候写了一段时间的做题日记，索性放到博客上好了 CF1898D Milena and Admirer贪心 绝对值图像化思想把$ a_i $，$b_i$抽象成线段的端点，|$a_i-b_i$|表示线段长，操作等同于交换两个线段的端点，通过分类讨论求每种情况下产生的贡献 CF1901B Chip and Ribbon思维还算有趣的题，推一下发现每次操作的贡献是当前段数 * 当前剩下的最小的数，如果是第一次操作则后者减一，对于维护段数，考虑对于每个数存它出现的位置，如果删除时左右都有数则标记段数++，如果左右都空则标记段数– CF1901C Add， Divide and Floor推式子找规律让整个序列都相同等价于把最大的和最小的变成相同的假设每次选一个满足$minn \\leq x \\leq maxn$的x$\\Delta maxn=\\lvert \\frac{maxn-x}{2}\\rvert= \\frac{maxn-x}{2}$$\\Delta minn=\\lvert \\frac{minn-x}{2}\\rvert= \\frac{x-minn}{2}$ 发现如果不考虑精度误差则x可以任意选，考虑精度误差，发现当maxn为奇数，minn为偶数时，选x为偶数可以使maxn下降更快，minn上升更快，反之同理 CF1901D Yet Another Monster Fight思维意外的简单，不知道为啥场切人数那么少显然对于每一个$a_j$，答案最差的情况是在到达$a_j$左侧或右侧某个很大的点$a_i$之前多走弯路(浪费威力最多)，可以对这个大点$a_i$按在$a_j$的左侧或是右侧分类讨论，通过手模发现，结果为$ans_{a_j}=max\\begin{cases} n-i+a_i ，\\quad i &lt; j \\ i+a_i，\\quad i &gt;j \\ a_j\\end{cases}$直接开两个multiset L，R，j从左向右扫，每次删掉一个右边的，增加一个左边的，对于每个j统计答案取min即可 数论涉及多个gcd求和 CF1900D有可能是欧拉反演，但是不想学数论 CF1900E Transitive Graph图论tarjan对于随便一个环(强连通分量)，按题意会连成一个完全图，也就是说在这个块里可以任意走要走长度最长且点权和最小的路，因为上面的条件所以随便一个强连通分量我们都可以一笔画走完，显然能走就走是最优的，tarjan跑完写个拓扑跑类似最长路的dp即可 ####CF1896A Jagged Swaps 结论$a_1=1$就是合法的，手模得出 CF1896B AB Flipping结论同样有趣的题，手模发现原序列去掉前导B和后导A后每个点都可以操作(后面的B可以被一路换到前面去)，固答案为$max \\lbrace 0，len-1 \\rbrace$ CF1896D Ones and Twos结论+DS题目里给了$a_i \\in \\lbrace 1，2\\rbrace$是有道理的对于一个左右端点都是1的子串，任意删掉一个端点的1可以改变子串和的奇偶性，连续删去两个1等价于删去一个2(无论两个1是否相连，由分类讨论得)，那么显然对于每个询问，先取出左右端点为1的最长的串L，如果$sum_L\\geq v$那就合法，否则考虑$sum_L$和$v$的奇偶性，奇偶性相同就向两边凑2，不同则删去一侧的1然后取剩下侧的2，左右端点重合的情况也适用 用set存每个1的位置，查询时直接取set的头尾，区间和用树状数组维护 CF1896C Matching Arrays贪心似乎这种题都是大的对大的小的对小的？ constexpr预处理这个关键字放在定义前可以让后面的东西在编译的时候跑，可能初始化素数表之类的挺有用的？ ####重载运算符对于二元运算符重载的时候成员函数作为左边的参数，显式操作数作为右边的参数 move()a=move(b) 把b的资源转移给a，比复制快很多，大概在滚动数组里有用 CF1902C Insert and Equalize贪心还算巧的贪心，选择一个数$x$使得可以通过不断加$x$让$a_{1…n+1}$相等，首先考虑$a_{1…n}$，先从小到大排序然后考虑相邻项的差值，因为只能不断加一个数这个数只能是这些差值的大公因数，不然凑不齐。然后考虑$a_{n+1}$，记之前得出的最大公因数为$g$，则$a_{n+1}$可以由$a_n$加上或减去g得到，我们优先考虑减，如果减了n次都不行就直接令$a_{n+1}=a_n+g$，同时把{a_{1…n}}抬高g CF1902D Robot QueriesDS+前缀和询问执行给定操作后是否经过指定点，先不考虑翻转，可以把经过的点做成一个前缀和，对于每个询问查询前缀和数组里是否有这个点考虑翻转的情况，对于一个原本能到达的点$pre_i=(x，y)$，我们先把它还原到翻转区间的起点，即$pre_i-(pre_i-pre_{l-1})$，然后看他翻转后是什么样，即$pre_i-(pre_i-pre_{l-1})+(pre_r-pre_{i-1})$如果这个反转后到达的点就是所求的$P=(x，y)$，那么整理下得出$pre_{i-1}=pre_{l-1}+pre_r-P$，所以对于翻转过的区间，我们只要在$[l-1，r-1]$里找是否有符合条件的$pre_{i-1}$即可，对于正常的区间就在$[0，l-1]，[r+1，n]$里找是否有询问的点$P$即可，显然翻转后对于翻转区间外的点是没影响的。找点的具体实现用线段树套set，线段树的每个节点上开一个set，添加点就一路insert到叶子，查的时候合并各区间答案即可 CF1907B YetnotherrokenKeoard栈签到题，分大小写开两个栈即可 CF1907C Removal of Unattractive Pairs贪心发现最后肯定只剩一个字母了，而且那个字母肯定是数量最多的，根据出现次数最多的字母的数量和n的大小分类讨论即可 CF1907D Jumping Through Segments二分二分答案，在check的过程中维护每次能到达的点的区间$[a，b]_n$，显然这个$[a，b]n$的更新可以通过分类讨论$[a，b]{n-1}$与$[l_n，r_n]$的相交情况实现，如果不相交就说明k非法 CF1907F Shift and Reverse哈希+结论首先这道题要知道只有以下几种情况可能是最优的：1.一直往前翻2.翻转然后一直往前翻3.翻转一直往前翻然后翻回来4.一直往前翻最后翻转这四种情况1，4等价于把后面的搬到前面去，2，3等价于把前面的搬到后面，然后最后的结果是使序列变成递增或递减的然后我们把原序列复制一遍放在后面，这样扫过去就可以直接得到所有我们可能通过操作产生的序列，然后操作数可以直接算出来，具体通过手模找规律，然后只要扫到某个数$a_i$是最大或是最小的（可以作为单调序列的起点），我们就用哈希判断$a_{i…i+n-1}$是否和排序好的序列一样，如果一样就计算把原序列变成这样需要的最小操作数并更新答案 set使用自定义类型对于自定义类型，劣质的重载&lt;会影响set的行为(大概率导致set出问题) CF1904B Collecting Game双指针双指针板子题，排序后跑双指针即可 CF1904D1 Set To Max (Easy Version)贪心easy version的数据较小，直接跑$n^2$的贪心即可，hard version可能要在原做法上加一个线段树维护区间最大值从小到大依次取$a_i$，然后分别向左右拓展，只要是扫到的数比$a_i$小并且比$b_i$小就可以把他设为$a_i$，最后扫一遍a看和b是否相同即可 CF1904D2 Set To Max (Hard Version)贪心+RMQ还真是原做法随便加一个单次logn或者更优的rmq，对于一个需要set to max的$a_i$显然我们需要找到它左边或右边最近的和$b_i$相等的$a_j$，选最近可以让一次操作对其他数字的影响最小，然后用rmq查$a_{i…j}$里面是否有比$b_i$大的，$b_{i…j}$里面是否有比$b_i$小的，如果都没有显然这次操作是合法的，然后优化下easy version取数的方式，改成从小到大取$b_i$（从结果入手），总的复杂度限制在rmq初始化$nlogn$ CF1904C Array Game分类讨论发现对于k&gt;=3，可以直接先选两次一样的$a_i，a_j$，然后第三次让两次的差互相减，答案肯定为0对于k=1，直接在所有的差和本来就有的数中间选一个最小的即可对于k=2，先$n^2$搞出来所有的差，然后每次在原数组中lower_bound一下去找和这个差最近的数再做差，也是把搞出来的所有数取min求答案，复杂度$n^2logn$ 后缀BIT把前缀树状数组的所有循环顺序倒过来就能实现后缀bit 费马小定理一个数在 mod b下关于a的逆元为 $a^{b-2}$ CF1917B Erase First or Second Letter计数对于一个字符串，如果确定第一个和第二个字符，那就不能继续操作了，可以将最终的字符串拆分成一个后缀和一个字母组合的形式，我们可以不断进行操作2来使一个字母匹配每一个后缀，同时因为我们只能删前两个字母，所以实际上我们最多有n个不同的后缀，且长度分别为1~n，所以我们要统计对于每一个后缀，前面有多少个不同的字母可以与其组合，开一个桶计数即可，把每个后缀的答案求和就是总的答案。 CF1917C Watering an Array贪心一个重要的性质，假设a=[0，0，…，0]，不管b的组成是什么样的，且执行几次添加操作，始终最多有1个$a_i=i$，因为假设$a_x=x$，那么对于$a_x$前面的所有$a_i$肯定有$a_i \\geq a_x$（因为每次是对一个前缀+1），对于后面的同理，所以如果我们进行过一次reset操作，之后最优的做法一定是add一次就reset一次，总贡献为d/2，所以问题转化成确定第一次reset的时间，注意到第一次reset最多也就产生n的贡献，所以如果我们第一次reset的时间晚于2*n+1，则一定不是最优的，即一开始最多add 2n次，直接暴力add 并统计答案取max即可，注意判断操作是否合法 CF1917E Construct Matrix构造非常神秘的构造，答案一半很显然，一半很不显然要求构造一个n*n的矩阵m，n为偶数，要求每行的1的数量同奇或同偶，每列同奇或同偶，且总数等于k首先特判，如果$k = n^2-2 || k=2 $，此时如果k!=2，则无解然后是对于k%4=0的部分，显然我们可以尝试把1组合成2x2的块放进去，一个2x2的块对横纵的奇偶性都是没影响的对于k%4=2的部分(不知道怎么想到的)如果k&lt;6肯定是第一种无解的情况，当$k \\geq 6$，我们先把$m_{1，1}，m_{1，2}，m_{2，1}，m_{3，3}，m_{3，2}，m_{2，3}$这六块变成1，然后剩下k-6的部分在除左上角4x4的范围继续组成2x2的块填进去，然后$k=n^2-6$则正好会有4个1多出来，则在$m_{1，3}，m_{1，4}，m_{4，4}，m_{4，3}$四个位置填上1，对于其他的所有情况，均无解 CF1913B Swap and Delete思维，字符串定义两种操作，从s中删去任意一个字符，代价为1，任意交换一对字符，代价为0记操作任意次后得到的字符串为t，问使t与s对应位置的字符均不相同的最小代价因为交换是无代价的，所以只要让t的1数量和s长度为|t|的前缀的0数量相同，反之亦然即可考虑直接枚举答案，显然答案最大为|s|，删完了肯定都一样了，对于每个答案n，实际上我们可以在合法的前提下任意删除总数为n的0和1，如果s里的0比t里的1多肯定这个答案是不行的，因为我们只能从t里删东西，对于每个可能成为答案的t，一定有$cnt1_t=cnt1_{preS_|t|}$，所以我们只要对于每个可能成为答案的t，统计s的0与t的1的数量差值和s的1与t的0的数量差值，如果两个差值和与我们枚举到的答案相等，则这个答案就是合法的，从小到大枚举找的合法的就退出即可 CF1913C Game with Multiset贪心，二进制很套路的题往一个集合里多次插入$2^x$，多次询问集合里的数是否可以凑出w显然先把w拆成二进制的形式，然后每次询问从低位向高位枚举，如果集合里这位有多的就除二借给下一位，一路枚举到头即可 CF1913E Matrix Problem最小费用最大流板子题，出在div2E估计是科技太高了发现n很小，且是约束问题，考虑网络流要求$i$行要有$a_i$个1，$j$列要有$b_j$个1，可以建超级源超级汇，合法的情况就是每个$a$点有$a_i$的流量，每个$b$点有$b_j$的流量，直接从源点向每个$a$拉流量为$a_i$的边，从每个$b$向汇点拉流量为$b_i$的边，费用均为0然后中间$a，b$直接拉完全图，边代表矩阵里的点，流量都是1，如果这个点本来是0，就拉费用为1的边，如果已经是1了，就拉费用为-1的边，同时先在答案里+1，表示如果这个点最终就是1，则不需要付出代价，所以费用和先加的1抵消，如果这个点最终应该是0，那这个点的流量就不会算进总流量里，也不会计算这个点的费用，按题意需要付出一点代价，而这个代价在拉边时已经加好了建完图跑dinic板子即可，最后如果a，b流量都跑满且相同就是合法答案 CF1914C Quests贪心显然最优答案是前i个先各做一次，然后剩下k-i次全部做b最大的那一个 CF1914D Three Activities贪心假设每次我们都只选a，b，c里前三大的i，最差的情况是这三个都相同，如果随意拿掉一个a，b，c也总还有两个可以选，而且这些选的都是前三大的，答案一定是在这里面产生的，所以直接找三元组里a，b，c分别是前三大的，从这几个(3~9个)里暴力枚举答案 CF1914E Game with Marbles贪心easy version直接爆搜hard version这么考虑，对alice，一次操作产生的贡献是$a_i+b_i$（A取了$a_i-1$，同时B的$b_i-1$不能取了，等价于对总答案的贡献是$(a_i-1)-(b_i-1)$），发现对bob来说也是同理，所以直接按照$a_i+b_i$排序，依次取大的即可 CF1914G1 Light Bulbs (Easy Version)tarjan这题有2100？ 不是很认可mod 998244353不开long long 是存在溢出并且输出不是负数的可能性的(能开long long 尽量开)发现对于一个颜色，显然如果我们先把一个灯点亮，那另一个灯也亮了，然后这两个灯之间的通过操作2也全亮了把灯抽象成线段的两端，如果一条线段被另一条完全覆盖，那只要长的那条点亮就行，如果交叉覆盖，则任意点亮一条即可，考虑对于每条线段u，向他所覆盖到的所有线段v拉单向边，表示点亮u就能点亮v，这样对于完全覆盖就是只能点亮u，对于交叉覆盖就是u，v任意点亮一个，注意到这里产生了强连通的问题，把图建好后跑缩点，缩完点的图中入度为0的点的数量就是S的大小，然后显然这些入度为零的点里被压缩了颜色数*2个灯泡，用乘法原理全乘在一起就是方案数 CF1918A Brick Wall贪心一个砖的大小是$1k$，墙的稳定性是横着的砖的数量减去竖着的砖的数量显然偶数长度就直接全部$12$的砖，奇数长度就一排$13$的砖，其他的就全部继续用$12$的 CF1918B Minimize Inversions思维给定两个序列A，B，可以同时交换$a_i，a_j和b_i，b_j$，要求输出排序后的A，B，使得其中逆序对的数量和最少考虑单独的一对$a_i，a_j，b_i，b_j$可能会有0，1，2对逆序对的情况，对于0的情况，交换产生2组逆序对，对于1的情况，交换消除一组逆序对，并产生一组逆序对，对于2的情况，交换消除两组逆序对发现如果对A排序，那么A中的逆序对数为0，那么对于所有的$a_i，a_j，b_i，b_j$，只会出现1和0的情况，而这两种情况无论怎么交换都无法减少逆序对的总量，所以此时总的逆序对数达到最小 CF1918C XOR-distance思维异或问题拆位考虑假设$a&gt;b$，发现如果我们搞a，b的最高位（对齐情况下），就会搞完后$a &lt; b$，那后面就没法确定怎么搞了，所以考虑不动最高位，从次高位开始搞，这样不管怎么弄都能满足$a&gt;b$，只要尽可能缩小a并增大b就行了对于a，b该位都是0或1的情况显然对答案没影响1：对于a是1，b是0的情况，x这位是1对答案有贡献2：对于a是0，b是1的情况，x这位是0对答案有贡献所以对于每一个情况1，在$x \\leq r$的前提下不断将x这位置1就可得到最终的x CF1918D Blocking Elements二分 单调队列 dp给定一个序列，要求通过删去元素把序列分为的几段，同时删去的元素一起作为一段，要求使所有段中和最大的最小 最大值最小考虑二分答案，在序列头和尾分别设两个值为0的虚点，$dp_i$表示目前到第i个元素，并删除这个元素，此时被删除元素的总和的最小值，我们每次更新$dp_i$最好是选择某一块合法区间内最小的dp值，考虑单调队列维护这个值，当队头不合法时（队头和i之间的元素和超过二分的答案），不断弹出队头，每次使用队头的值更新此时的$dp_i$，并不断弹出比$dp_i$大的队尾元素，并把i插入单调队列，只要$dp_{n+1}$比此时的答案小，就继续更新答案 CF1921D Very Different Array贪心从B里选n个作为数组A，使$A_{1…n}和C_{1…n}$对应位元素差的绝对值之和最大考虑先让B里最大的对应C里最小的数，这样B里会剩下一些最小的数，同时发现这样每次产生的贡献使递减的，同时最后可能会有B中的数比C中的数小的情况，所以我们再倒着用B里最小的数去对应C里最大的数，这样每次更新答案只用变换一个位置的值，不断更新答案的最大值即可 CF1921E Eat the Chip贪心 结论Alice可以往下，左下，右下走，Bob可以往上，左上，右上走，Alice先手，问谁赢或者平局贪心地想，两边同时向左，同时向右，一左一右都不影响横向距离的奇偶性，即不影响最后谁赢，只有纵向距离的奇偶性影响结果，所以纵向距离为奇数时，bob必定会考虑保平，反之同理考虑保平的情况，显然游戏结束的时间时确定的，即双方纵向位置相同的时候，此时不能吃掉对方就一定平局，所以直接考虑不可能赢的那方在结束前最远能到达左边或右边的哪个位置，再看另一方能否也到达那个位置，能到达就赢，否则平局 CF1922A Tricky Template贪心给定一个字符串s，称满足以下条件的小写字符串t是符合题意的1.如果s第i位是小写，t这一位必须和s一样2.如何s第i位是大写，t这一位必须和s不一样给定符合题意的字符串a，b ，和不符合题意得字符串c，问这样的t是否存在如果a，b，c这一位不一样，只要让t这一位和c一样并大写即可如果a，b这一位一样，和c不一样，只要让t这一位和ab一样并小写即可 CF1922B Forming Triangles组合数给定n个木棍，第i根木棍的长度是$2^{a_i}$，问选三根木棍组成三角形有多少种方案首先发现木棍的长度都是2的幂，显然想组成三角形就只能组成等边三角形，找到每种长度的棍的数量求组合数就行了 CF1922C Closest Cities贪心n个城市在数轴上，有两种移动方式1.移动到任意城市，代价为两城市间的距离2.移动到最近的城市，代价为1q次询问，问从a到b的最小代价发现对于每个城市，发现在只考虑往一个方向走的情况下他和离他最近的那个城市的距离可以压成1，然后显然我们每次询问肯定都是往一个方向走的考虑向左和向右走两种情况分开做，预处理出新的位置，然后询问时直接位置相减算答案 CF1922D Berserk Monsters贪心 set 链表每个怪物每轮会被他的邻居攻击，每轮结束时，受到的伤害大于防御的怪物会死亡，问每轮死亡的怪物数每一轮结束后，如果一个怪物这一轮没有死，且他的邻居也没有死，那他下一轮也不会死（受到和这一轮一样的伤害）所以我们考虑每轮结束时，把死亡的怪物加入set，显然下一轮我们只要更新这些怪物的邻居的答案就行了，更新答案的总复杂度最差为O(3n)，找邻居和删除的过程用链表实现 CF1923A Moving Chips贪心一个1可以被移到最左边最近的空格，问把所有1连起来的最小移动次数显然删除前导0，后导0，剩下的0的数量就是我们要移动的次数 CF1923B Monsters Attack!贪心每秒发射k个子弹，任意分配，每发子弹造成1点伤害，数轴上n个怪物，每秒向原点移动一格，如果任意一秒结束时原点上有存活的怪物则失败，问能否杀死全部怪物先把所有怪物按离原点的距离排序，考虑按秒模拟，每秒射出的总子弹数增加k，并减去这一秒到达原点的所有怪物的血量值，如果出现子弹数不够则失败 CF1923C Find B贪心 构造一个长度为m的序列a是好的当且仅当存在一个长度为m的序列b满足1.a的和等于b的和2.a和b每一位均不相等3.b每一位都大于0给定一个序列c，q次询问，每次问c的一个子段是否是好的显然有一种贪心的构造法，我们考虑c的这个子段里有多少个1，对于这些1，我们构造2，对于剩下不是1的，我们全部构造1，然后如过此时总和还不够，就把少的全部任找一个2加进去，如果不能这么做则这个子段就是不是好的 CF1923D Slimes贪心 二分 前缀和n个史莱姆，每秒有且只有一只史莱姆吃掉一个大小严格小于他的邻居，且大小变为两者之和，n次独立询问，问每只史莱姆最早第几秒被吃掉一个重要的性质，假设一个史莱姆i最终被j吃掉，而j在吃i之前一定吃了包含j的一个子段里的所有史莱姆，然后我们发现，找到j等价于找到这个子段，而这个子段一定是在i的左边或右边且与i相邻，且和正好大于i，即不用去考虑j吃掉i的具体过程，$ans_i$就是这个子段的长度，所以问题转化为对于每个i，找到他左边或右边最短的总和大于他的子段，前缀和+二分即可，总复杂度O(nlogn) CF1945B Fireworks结论观察样例发现答案就是$m/a+m/b+2$ CF1945C Left and Right Houses前缀和前缀和统计1的数量，枚举断点即可 CF1945D Seraphim the Owl贪心假设从i交换至j，发现有两种交换途径，一种是每次只前进一格，这样每次代价为$a_{i+1}$，或者前进x格，那么代价为$\\sum_{p=i+1}^{i+x-1}b_p+a_x$，发现这两种前进方式是灵活的，如果这一步不是终点的话，我们的代价是$\\min(a_i，b_i)$，因此从i交换到j的最优解是$\\sum_{p=i+1}^{j-1}\\min(a_p，b_p)+a_j$，倒着累加即可 CF1945E Binary Search结论考察了二分的性质，对于我们瞎跑出来的l，可以发现有$p_l \\leq x$，这是给出的描述决定的，然后发现如果我们把此时的$p_l$换成一个不大于$x$的数，显然对l的位置也没有影响所以我们直接在原序列上跑题目给出的二分，然后把$x$的位置和跑出来的$l$交换即可 CF1945F Kirill and Mushrooms贪心 set首先为了方便处理不能选的情况，把原序列按$i_{s_j}$从小到大排序依次考虑选$k$的个情况假设我们要选$k$个，那么最优的做法肯定是从可以选的$n-(k-1)$个里选$k$个最大的，可以考虑从选$k-1$个的情况转移来，我们考虑开两个set，把没选的扔进unselect里，选了的扔进select个里，当我们准备选第$k$个的时候，根据题意此时排序后的第$k-1$个就不能选了，如果他在unselect里，就把他删了，然后再选unslect里最大的移到select里，如果他在select里，也把他删了，再从unselect里选最大和次大的移到select里，可以发现这样单次更新答案是logn的，unselect空了就结束，每次更新答案时统计最大值即可 gym104090M ICPCHZ2022 M. Please Save Pigeland换根 线段树缝合怪题，给定点集$S$，要求在树上找到一个点$u$，使得$\\frac{\\sum dist(u，S_i)}{gcd(dist(u，S_i))}最小$考虑换根，我们先求出$u$为1的情况，然后以1为根开始换根，发现我们每向经过一条边$E(u，v)$，对答案产生的影响是$v$子树内的所有特殊点的$dist$全部减去$dis_{E(u，v)}$，其余的特殊点全部加上$dis_{E(u，v)}$，考虑记录以1为根的每个点的dfs序，可以发现一个点子树内的点满足$dfn[u]\\leq dfn[v] \\leq dfn[u]+siz[u]-1$，可以把特殊点按dfs序排序并每次通过两次二分求左右端点的方法得到哪段是要被减去距离的，我们需要一个可以维护区间加减和区间gcd的数据结构，考虑线段树，由gcd的性质得知一个序列的gcd等同于这个序列的差分的gcd，问题转化成单点修和区间gcd，所以每次换根的时候，用线段树维护差分数组，并统计整个特殊点序列的gcd计算答案即可，总复杂度$O(nlog(n)log(V))$ CF1956F Nene and the Passing Gameset 思维因为能否传接球的关系是双向的，不妨设$i&gt;j$，把给定的式子化简一下，可以得到 $i-l_i \\geq j+l_j$ $i-r_i \\leq j+r_j$ 可以在保证1式成立的前提下考虑2式，我们可以把n个人拆成权值分别为$i-l_i$和$i+l_i$的2n个点，再把这些点按权值从小到大排序，这样我们就能保证每个点对前面的所有点都满足1式，同时我们可以把权值为$i+l_i$的点视作修改，把权值为$i-l_i$的点视作询问，每当扫到前者时，我们往一个递减的set中插入该点，权值为$i+r_i$，这样当我们扫到代表询问的点x时，只要不断从set头中取出满足$x-r_x \\leq i+r_i$的点i与x组成连通块，并从set中删去该点，连完后再把整个连通块的根塞回set里，最后统计连通块的数量就可以得到答案了同时我们注意到，对于一个连通块，我们只要看他最大的$i+r_i$的值，所以只要把第一个取出的点作为整个连通块的根即可，因为我们保证了set中第一个取出的点一定是全局$i+r_i$值最大的 CF1942A Farmer John’s Challenge结论对于$n=k$ 显然全部输出1就行了对于$k=1$ 显然先输出n，再依次输出1~n-1即可对于$1&lt;k&lt;n$，发现一个有序序列只要平移一次一定会变成无序的，所以这些都是不可能的情况 CF1942B Bessie and MEX贪心由于mex和排列的性质，考虑倒着做对于$ans_n$，显然此时的mex为n，直接可以算出$ans_n$，当知道了ans_n后，$ans_{n-1}$的mex显然就是目前的mex和$ans_n$的值取小的那个，不倒推即可 CF1942C Bessie’s Birthday Cake贪心 思维考虑y=0的情况，把给定的点连成多边形，对于一个多边形，其内部能划分出的三角形个数就是其边数x-2，然后我们发现如果两个给定的点之间夹了一个未给定的点，这种情况也能组成三角形，所以就是统计距离为2的点对的数量ans,最终答案是ans+x-2 当$y \\neq 0$时，我们要不断构造上面所说的距离为2的点对的情况，这也能分两类讨论，当两个相邻的给定点距离大于2时，根据画图找规律可以发现，在把间隔按照中间每隔一格赛一个点的规则填满时，当距离（$a_x-a_y$）为偶数，一共可以填$(a_x-a_y)/2$个点，产生$(a_x-a_y)/+1$个三角形，当填不满时则少一个，当距离为奇数时，可以填$(a_x-a_y-1)/2$个点，产生$(a_x-a_y-1)/2$个三角形，所以我们先填距离为偶数的间隔，并先填短的，注意处理未填满的情况即可 CF1957B A BIT of a Construction贪心直接从低位到高位枚举$a_i$并将k减去$a_i$即可 CF1957D A BIT of an Inequality思维 二进制我们把原式展开，首先可以的到几个结论： 当x=y=z时肯定不符合题意 原问题等价于，对于一个区间的异或和$pre_{l…r}$，问这个区间内有几个数$a_i$满足$a_i \\bigoplus pre_{l..r} &gt;pre $ 进一步分析2，发现2等价于，要求$a_i$的最高位对于$pre_{l..r}$而言，该位为0 发现如果枚举区间复杂度无法接受，考虑对于y寻找可能的x，y，即区间的左右端点，从左往右枚举y，考虑分别记录y左边至0，y右边至n有多少个$pre_i$第j位为0或者1，假设j为$a_i$的最高位，我们只需简单使用乘法原理（cnt0之间相乘,cnt1之间相乘）就可以得到有多少对$pre_r \\bigoplus pre_l$满足题意实现过程中注意，开始应该把所有点都扔进右边的桶里计数在计算$a_i$的答案时，考虑到实际的区间左端点是$l+1$，所以我们先算答案，再把$pre_i$从右边的桶移到左边的桶，这点通过画图可以得知 CF1966A Card Exchange贪心发现我们只关心一次换了k-1张牌，不关心牌具体的情况，所以最优策略就是每次换当前数量最多的，换过来的k-1张牌存进tot里，遇到不够换的时候拿tot补，最后没法换了把剩下的总牌数加上剩下的tot就是答案（注意最后tot和k-1取min）,开个堆瞎搞即可 CF1966B Rectangle Filling思维发现对于一种颜色，我们相当于是选一条对角线代表的矩形涂色，我们考虑看对于每个颜色，显然它在x轴上最多只能涂到x值最大的同色块那么远，然后x轴和y轴的答案显然是不干扰的，所以要全部涂成同一颜色，我们只要看对一个颜色，它最小的x值和y值是否为1，最大的x值和y值是否为n和m即可 CF1966C Everything Nim博弈论对于每轮游戏，选择一个最多不超过最小石子堆石子个数的正整数k，并将每个堆都移去k个石子因为每次移的个数有上限，而且还是对所有的堆都移，考虑每轮最多能移几个，发现问题等价于对原序列排序后的差分数组进行移石子，且遇到0全部跳过（显然），而且只能从左往右移，然后考虑先后手，当目前堆石子数大于1的时候,先手的那个人可以选择全部移走，或者留一个，意味着他可以决定在移下一堆石子是自己是先手还是后手，也就是再之后遇到1时的强制交换先后手对它没有影响（这点手摸可以发现），所以我们只要考虑遇到第一个大于1的数时谁是先手，也就是统计去0后的差分数组里连续的前导1的数量（不包括差分数组最后一位的数），偶数Alice，奇数Bob CF1966D Missing Subsequence Sum构造看到串的长度小于25，考虑二进制分解，我们可以构造一个1,2,4…的串，同时这个串不包含k最高位的1，这样我们就确保了对于这一位是1的所有数都凑不出来然后考虑如何凑出这一位是1的，且不等于k的其他数，假设这一位为i，串中比它低的位的和加起来是$2^i-1$，那我们如果放一个$k-2^i$，它与前面这些数加起来就是k-1，根据二进制分解的原理我们确保了1…k-1都可以凑出来,然后我们可以暴力添加一个k+1，那么这个k+1与我们前面已经构造出来的1…k-1就可以凑出k+2…2k, CF1969A Two Friends贪心有长度为2的环答案就是2，否则是3 CF1969B Shifts and Sorting贪心手玩发现对于1100，我先操作$s_{1…3}$再操作$s_{2…4}$和直接操作$s_{1…4}$结果是一样的问题就化为从左往右，对于每一个1，把他和他后面遇到的第一个0交换位置（以这两个数为端点执行一次右移）注意到我们这么做的实质是不断把1后面的0提到最前面，所以我们只要记录第一个1的位置pos，然后每次操作后pos+1就是下一个1的位置，所有的1是很自然被排到一起的 CF1969C Minimizing the Sumdp一次操作可以把一个数左边或右边的邻居替换为它，问最多操作$k (k \\leq 10)$次后整个序列和的最小值发现k很小，考虑预处理以i为右端点，i-j为左端点,操作j次产生的贡献$v_{i,j}$,以i为右端点可以方便处理后效性的问题自然想到dp数组$dp_{i,k}$代表前i个数操作k次产生的最小贡献考虑如何转移，假设我们在i处操作j次，此时总共操作了k次，$dp_{i,k}$显然就要从$dp_{i-j-1,k-j}$前面的状态转移来，然后我们肯定要从前面里选一个最小的,所以$mindp_{i,j}$表示$dp_{1…i,j}$里最小的值，转移方程就是$dp_{i,k}=min(dp_{i,k},mindp_{i-l-1,k-j}+v_{i,j})$，记得每次转移完后更新$mindp_{i,j}$,并且$mindp_{i,j}$在进入第一次转移前初始化为$mindp_{i-1,j}$，dp入口为$dp_{0,0}$，因为没说一定要选k次，所以dp和mindp初始化全0即可 CF1969D Shop Game贪心选任意个物品，alice可以以$a_i$的价格买入,并以$b_i$的价格卖给bob，bob可以选择不超过k个物品免费拿走，bob希望alice的总收入最少，alice希望最多，问alice的最大收益是多少 对bob来说，显然他会拿走alice的物品里$b_i$最大的k个，所以我们按b从大到小排序，可以将原序列分成两部分，对于一个$i(i&gt;k)$，它左边需要选k个a最小的的让bob拿，并且其他的都不拿，右边则是a&gt;b的全拿，然后我们往右枚举这个断点并每次统计答案，左边拿一个优先队列维护前k个最小的a的和即可，右边先对$b_i-a_i$求和，然后不断减掉即可，对于左边为什么不用选超过k个，我们考虑，因为bob的行为其实是固定的，对于alice一个物品都不移除的情况，bob实际上就是选第1…k个免费拿，当断点移动到k+2的时候，如果我们不移除k+1，实际上bob还是拿1…k，而不移除k+1的情况在断点为k+1时已经计算过答案了，所以只需要保证左边留k个，其他全移除即可 CF1972A Contest Proposal暴力按题意模拟即可，答案最大不会超过n CF1972B Coin Games思维 结论n个硬币排成环，可以对朝上的硬币进行操作，若硬币数小于2则直接删除这个硬币，否则删除这个硬币的同时翻转相邻的两个硬币，无法操作的人输发现对于所有的情况，朝上的硬币数要么一次减少3个，要么减少1个，要么增加1个，所以每次操作都会改变朝上硬币数的奇偶性，最后把数量变成0，即偶数的那个人赢，所以开始朝上硬币数为奇数时alice赢，否则bob","link":"/%E6%9D%82%E9%A1%B9/acm-log/"},{"title":"从零开始的LLVM-pass （一） 环境搭建和第一个demo","text":"为什么有这篇文章前段时间看了点LLVM的博客，学的非常痛苦，所以打算写一篇文章记录一下基本的框架搭建过程，省的一段时间后又忘了 Demo实现一个 FunctionPass ，遍历所有函数，如果函数不是main函数就修改混淆函数的名字 关于环境开发环境是win，至于为什么不选linux，主要是没有物理机实在不方便，后续如果被win恶心到了可能会迁移到linux win-gnu-llvm下载 非常神奇的找到了兼容win-gnu ABI的llvm工具链，试了下能跑，索性先这样g++用的是MinGW，网上随便下一个新一点的都行 直接下载完就是编译完的二进制文件，把bin加到环境目录就能识别clang和opt了 框架搭建目录结构如图所示build是Cmake的输出路径，最终编译好的pass就存在里面test里是测试文件，用来测试pass的混淆效果transforms里是pass的源码 /transforms/CMakelists.txt12345678910111213141516171819202122232425# /transforms/CMakelists.txtcmake_minimum_required(VERSION 3.13)project(MyPass)set(CMAKE_C_COMPILER &quot;gcc&quot;)set(CMAKE_CXX_COMPILER &quot;g++&quot;)set(LLVM_DIR &quot;C://llvm-19.1.6-1/lib/cmake/llvm&quot;)find_package(LLVM REQUIRED CONFIG)include_directories(${LLVM_INCLUDE_DIRS})link_directories(${LLVM_LIBRARY_DIRS})add_definitions(${LLVM_DEFINITIONS})add_library(MyPass MODULE MyPass.cpp)target_link_libraries(MyPass LLVMCore LLVMSupport LLVMIRReader LLVMPasses LLVMAnalysis LLVMTransformUtils) CMakelist如上设置，要手动导入LLVM的cmake路径，然后中间这些宏都是LLVM的.cmake文件里自带的，直接抄就行之后就和正常cmake项目一样，设置链接库源文件，输出和依赖 test.sh123456789101112# test.shcd ./build cmake -G &quot;Ninja&quot; ../transforms cmake --build .cd ../testg++ test.cpp -o beforeLLVM_testclang++ -S -emit-llvm test.cpp -o test.llopt -load-pass-plugin=../build/libMyPass.dll -passes=encode-func -S test.ll -o test.out.llllc test.out.ll -filetype=obj -o test.og++ test.o -o test ./testcd .. 使用g++编译一份未加pass的二进制文件方便以后对比，使用clang++配合-S -emit-llvm参数输出llvm-IR文件，这是llvm的中间语言文件，之后pass所有的处理都在该文件上进行-load-pass-plugin=${filePath} 是opt新版的api，我们生成的是类似于插件库的dll，之后还要加上 -passes={passName} 指定具体用哪个pass，之后讲如何注册pas时会具体讲这个passName是怎么来的 处理好后用llc把中间文件编译成目标文件，再用g++把中间文件编译成可执行文件就完事了 MyPass.cpp1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &quot;llvm/IR/PassManager.h&quot;#include &quot;llvm/Passes/PassBuilder.h&quot;#include &quot;llvm/Passes/PassPlugin.h&quot;#include &quot;llvm/Support/raw_ostream.h&quot;#include &lt;string&gt;using namespace llvm;namespace{ class EncodeFunctionName : public PassInfoMixin&lt;EncodeFunctionName&gt; { private: static int functionCnt; public: PreservedAnalyses run(Function &amp;F, FunctionAnalysisManager &amp;FAM) { if (F.getName() != &quot;main&quot;) { errs() &lt;&lt; &quot;Old name: &quot; &lt;&lt; F.getName() &lt;&lt; &quot;\\n&quot;; F.setName(&quot;114514func&quot; + std::to_string(++functionCnt)); errs() &lt;&lt; &quot;New name: &quot; &lt;&lt; F.getName() &lt;&lt; &quot;\\n&quot;; } else { errs() &lt;&lt; &quot;function is &quot; &lt;&lt; F.getName() &lt;&lt; &quot;\\n&quot;; } return PreservedAnalyses::all(); } static bool isRequired() { return true; } };}int EncodeFunctionName::functionCnt = 0;extern &quot;C&quot; LLVM_ATTRIBUTE_WEAK ::llvm::PassPluginLibraryInfollvmGetPassPluginInfo(){ return { LLVM_PLUGIN_API_VERSION, &quot;encode-func&quot;, LLVM_VERSION_STRING, [](PassBuilder &amp;PB) { errs() &lt;&lt; &quot;\\n=== Registering EncodeFunctionName Pass ===\\n&quot;; PB.registerPipelineParsingCallback( [](StringRef Name, FunctionPassManager &amp;FPM, ArrayRef&lt;PassBuilder::PipelineElement&gt;) { if (Name == &quot;encode-func&quot;) { errs() &lt;&lt; &quot;Adding EncodeFunctionName pass to manager\\n&quot;; FPM.addPass(EncodeFunctionName()); return true; } return false; }); }};} llvm的所有实现都定义在llvm空间中，因为是个demo所以干脆直接using namespace llvm要实现一个自己的pass，我们要从 PassInfoMixin&lt;&gt; 这个基类模板继承，这是LLVM的新版API，区别于旧版的是我们不用指定pass的类型，而是依靠下面的 run 方法的实现区分pass类型，我们要实现一个functionPAss，所以 run 的参数就是 llvm:Function 和 llvm:FunctionAnalysisManager run 是pass中最关键的方法，一个pass所有的业务都是在run中完成的，这是一个回调，会对所有的函数执行，我们直接用getName获取名字，然后用setName重设名字就行，返回 PreservedAnalyses::all() 表示这个pass不会对其他任何pass产生影响，反正我们也只跑这一个pass，返回all即可 isRequired() 编译器可能会跳过我们的pass，因为实际上pass没做优化，所以要实现 isRequired 返回ture强制要求编译器执行我们的pass extern “C” LLVM_ATTRIBUTE_WEAK ::llvm::PassPluginLibraryInfo llvmGetPassPluginInfo()这是新版LLVM注册pass的惯用约定，这部分基本没什么好改的，返回一个四元组 {LLVM插件API版本号，插件名，插件版本号，注册回调函数} ，其中插件名就是我们用-pass时传递的名字，opt会解析这个名字并并调用相关回调，插件版本号随便写就行 回调会传入一个PassBuilder,我们往里面注册一个解析回调，每次opt解析我们的命令时都会执行这个回调，这个回调的格式也基本是固定的，最重要的是 Name ，这是解析得到的 passName ，我们调用 FPM.FPM.addPass(EncodeFunctionName()) 来完成注册 test.cpp123456789101112131415161718192021222324// test.cpp#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;void testFunctionA(){ std::cout &lt;&lt; &quot;testA&quot;;}void testFunctionB(){ std::cout &lt;&lt; &quot;testB&quot;;}void testFunctionC(){ std::cout &lt;&lt; &quot;testC&quot;;}int main(){ testFunctionA(); testFunctionB(); testFunctionC(); return 0;} 我们声明了三个函数，预期这三个函数的名字都会被改成114514funcxxx 输出根据pass输出的调试信息可以发现opt按照从上到下的顺序对每个函数执行了pass 然后再打开ida看看二进制文件是否真的被修改了 可以看到确实被修改了 下一篇文章可能会写一下怎么修改基本块和怎么混淆运算符","link":"/ctf/llvm/llvm0x1/"},{"title":"[NPCCTF 2025]babyVM","text":"ida打开main函数看到进入就是vm虚拟机 点进去发现是一个巨大的switch case循环，结构非常明显，有四个32位寄存器，其他和题目关系不大 二十多个case全部写handle去解析opcode的话难度很大，而且还要指令长度之类的问题，可以采用在指令入口点下条件断点的方式，然后动态执行整个vm，在执行指令的同时输出执行的操作，这样就可以获取vm指令的伪代码了 然后跑一遍就能拿到执行的指令了可以看到非常长，这里我同时在指令前输出了执行前寄存器的值，同时这里的下标也是处理过的，如果直接输出寄存器的值下标会非常大，用了一个python脚本对下标做了偏移让伪代码好看点 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354import reimport sysdef process_text(text): # 找出所有以 heap[938 开头的模式 pattern1 = r'heap\\[(938\\d+)\\]' matches1 = re.findall(pattern1, text) # 找出所有以 heap[1844 开头的模式 pattern2 = r'heap\\[(1844\\d+)\\]' matches2 = re.findall(pattern2, text) # 如果存在匹配项，找出最小索引值 if matches1: indices1 = [int(idx) for idx in matches1] base1 = min(indices1) # 替换heap[938...]为heap_1[offset] for idx in sorted(set(indices1), reverse=True): # 去重并从大到小替换 offset = idx - base1 text = text.replace(f'heap[{idx}]', f'heap_1[{offset}]') if matches2: indices2 = [int(idx) for idx in matches2] base2 = min(indices2) # 替换heap[1844...]为heap_2[offset] for idx in sorted(set(indices2), reverse=True): # 去重并从大到小替换 offset = idx - base2 text = text.replace(f'heap[{idx}]', f'heap_2[{offset}]') return textdef main(): # 如果有命令行参数，则读取文件 if len(sys.argv) &gt; 1: input_file = sys.argv[1] with open(input_file, 'r') as f: text = f.read() else: # 否则从标准输入读取 text = sys.stdin.read() processed_text = process_text(text) # 输出到标准输出 print(processed_text)if __name__ == &quot;__main__&quot;: main() 然后看cmp xx 48可以看出来明显有一个循环，结合各种左右移操作，猜测是tea系列的加密，于是截取一段循环抄算法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475// ------------cmp 4 48------------- // r1= 2984982102 r2= 0 r3= 4 r4= 4207947599 // r1= 2984982102 r2= 0 r3= 4 r4= 4207947599 reg3 = heap_2[56]; // heap_2[56] = 2984982102 // r1= 2984982102 r2= 0 r3= 4 r4= 2984982102 reg3 &gt;&gt;= 6; // r1= 2984982102 r2= 0 r3= 4 r4= 46640345 reg0 = heap_2[56]; // heap_2[56] = 2984982102 // r1= 2984982102 r2= 0 r3= 4 r4= 46640345 reg0 &lt;&lt;= 5; // r1= 1030146752 r2= 0 r3= 4 r4= 46640345 reg3 ^= reg0; // reg0 = 1030146752 // r1= 1030146752 r2= 0 r3= 4 r4= 1067542041 reg3 += heap_2[56]; // heap_2[56] = 2984982102 // r1= 1030146752 r2= 0 r3= 4 r4= 4052524143 reg2 = heap_2[64]; // heap_2[64] = 2610559960 // r1= 1030146752 r2= 0 r3= 2610559960 r4= 4052524143 reg2 &amp;= 3; // r1= 1030146752 r2= 0 r3= 0 r4= 4052524143 reg0 = heap_2[68]; // heap_2[68] = 164 // r1= 164 r2= 0 r3= 0 r4= 4052524143 reg2 = heap_1[0]; // heap_1[0] = 1987012675 // r1= 164 r2= 0 r3= 1987012675 r4= 4052524143 reg2 += heap_2[64]; // heap_2[64] = 2610559960 // r1= 164 r2= 0 r3= 302605339 r4= 4052524143 reg3 ^= reg2; // reg2 = 302605339 // r1= 164 r2= 0 r3= 302605339 r4= 3817207924 reg3 += heap_2[60]; // heap_2[60] = 1830509707 // r1= 164 r2= 0 r3= 302605339 r4= 1352750335 heap_2[60] = 1352750335; // r1= 164 r2= 0 r3= 302605339 r4= 1352750335 reg3 = heap_2[64]; // heap_2[64] = 2610559960 // r1= 164 r2= 0 r3= 302605339 r4= 2610559960 reg3 -= heap_2[32]; // heap_2[32] = 421101834 // r1= 164 r2= 0 r3= 302605339 r4= 2189458126 heap_2[64] = 2189458126; // r1= 164 r2= 0 r3= 302605339 r4= 2189458126 reg0 = heap_2[60]; // heap_2[60] = 1352750335 // r1= 1352750335 r2= 0 r3= 302605339 r4= 2189458126 reg0 &gt;&gt;= 7; // r1= 10568361 r2= 0 r3= 302605339 r4= 2189458126 reg2 = heap_2[60]; // heap_2[60] = 1352750335 // r1= 10568361 r2= 0 r3= 1352750335 r4= 2189458126 reg2 &lt;&lt;= 3; // r1= 10568361 r2= 0 r3= 2232068088 r4= 2189458126 reg0 ^= reg2; // reg2 = 2232068088 // r1= 2242635089 r2= 0 r3= 2232068088 r4= 2189458126 reg0 += heap_2[60]; // heap_2[60] = 1352750335 // r1= 3595385424 r2= 0 r3= 2232068088 r4= 2189458126 reg3 = heap_2[64]; // heap_2[64] = 2189458126 // r1= 3595385424 r2= 0 r3= 2232068088 r4= 2189458126 reg3 &gt;&gt;= 11; // r1= 3595385424 r2= 0 r3= 2232068088 r4= 1069071 reg3 &amp;= 3; // r1= 3595385424 r2= 0 r3= 2232068088 r4= 3 reg2 = heap_2[68]; // heap_2[68] = 164 // r1= 3595385424 r2= 0 r3= 164 r4= 3 reg3 = heap_1[12]; // heap_1[12] = 1597387639 // r1= 3595385424 r2= 0 r3= 164 r4= 1597387639 reg3 += heap_2[64]; // heap_2[64] = 2189458126 // r1= 3595385424 r2= 0 r3= 164 r4= 3786845765 reg0 ^= reg3; // reg3 = 3786845765 // r1= 939234325 r2= 0 r3= 164 r4= 3786845765 reg0 += heap_2[56]; // heap_2[56] = 2984982102 // r1= 3924216427 r2= 0 r3= 164 r4= 3786845765 heap_2[56] = 3924216427; // r1= 3924216427 r2= 0 r3= 164 r4= 3786845765 // r1= 3924216427 r2= 0 r3= 164 r4= 3786845765 reg2 = heap_2[44]; // heap_2[44] = 4 // r1= 3924216427 r2= 0 r3= 4 r4= 3786845765 reg2 += 1; // r1= 3924216427 r2= 0 r3= 5 r4= 3786845765 heap_2[44] = 5; // r1= 3924216427 r2= 0 r3= 5 r4= 3786845765 // ------------cmp 5 48------------- 123456789101112131415// key = Chovy_inkey_w36_void enc(unsigned int v0, unsigned int v1, unsigned int *key){ // heap_2[56] = v0 // heap_2[60] = v1 // heap_2[64] = sum unsigned int sum = 0; unsigned int tmp_reg3 = 0, tmp_reg2 = 0, tmp_reg0 = 0; for (int i = 0; i &lt; 48; i++) { v0 += (((v1 &gt;&gt; 6) ^ (v1 &lt;&lt; 5) )+ v1) ^ (key[sum &amp; 3] + sum); sum -= 421101834; v1 += (((v0 &gt;&gt; 7) ^ (v0 &lt;&lt; 3)) + v0) ^ (key[(sum &gt;&gt; 11) &amp; 3] + sum); }} key 的来源是 12345678910111213141516171819202122232425262728293031heap_2[0] = 67;// r1= 512 r2= 0 r3= 32 r4= 512heap_2[1] = 104;// r1= 512 r2= 0 r3= 32 r4= 512heap_2[2] = 111;// r1= 512 r2= 0 r3= 32 r4= 512heap_2[3] = 118;// r1= 512 r2= 0 r3= 32 r4= 512heap_2[4] = 121;// r1= 512 r2= 0 r3= 32 r4= 512heap_2[5] = 95;// r1= 512 r2= 0 r3= 32 r4= 512heap_2[6] = 105;// r1= 512 r2= 0 r3= 32 r4= 512heap_2[7] = 110;// r1= 512 r2= 0 r3= 32 r4= 512heap_2[8] = 107;// r1= 512 r2= 0 r3= 32 r4= 512heap_2[9] = 101;// r1= 512 r2= 0 r3= 32 r4= 512heap_2[10] = 121;// r1= 512 r2= 0 r3= 32 r4= 512heap_2[11] = 95;// r1= 512 r2= 0 r3= 32 r4= 512heap_2[12] = 119;// r1= 512 r2= 0 r3= 32 r4= 512heap_2[13] = 51;// r1= 512 r2= 0 r3= 32 r4= 512heap_2[14] = 54;// r1= 512 r2= 0 r3= 32 r4= 512heap_2[15] = 95; 其中可能在整理heap时脚本出了点问题，储存key的被错误命名成了heap2，但是还是能辨别出key 于是写解密 12345678910111213141516171819202122232425262728void dec(unsigned int *v, unsigned int *key){ unsigned int v0 = v[0]; unsigned int v1 = v[1]; unsigned int delta = 421101834; unsigned int sum = 0; for (int i = 0; i &lt; 48; i++) sum -= delta; for (int i = 0; i &lt; 48; i++) { v1 -= (((v0 &gt;&gt; 7) ^ (v0 &lt;&lt; 3)) + v0) ^ (key[(sum &gt;&gt; 11) &amp; 3] + sum); sum += delta; v0 -= (((v1 &gt;&gt; 6) ^ (v1 &lt;&lt; 5)) + v1) ^ (key[sum &amp; 3] + sum); } for (int i = 0; i &lt; 4; i++) printf(&quot;%c&quot;, ((unsigned char *)&amp;v0)[i]); for (int i = 0; i &lt; 4; i++) printf(&quot;%c&quot;, ((unsigned char *)&amp;v1)[i]);}int main(){ unsigned char key[] = &quot;Chovy_inkey_w36_&quot;; unsigned char cipher[] = &quot;\\xE5\\xDF\\xF0\\xA1\\xF4\\xBD\\x6A\\xDB\\x1B\\xE9\\xDD\\x20\\r\\x9D!YгY)\\xB9\\xEC\\x2F\\xC0\\&quot;~\\xAD\\xE1\\xB0\\x15\\xB6)&quot;; for (int i = 0; i &lt; 32; i += 8) dec((unsigned int *)&amp;cipher[i], (unsigned int *)key); return 0;} flag{D0_yOu_l1k3_VmmmmMMMMMmmm?}","link":"/ctf/WP/NPCCTF%202025%20babyVM/"},{"title":"NPCCTF 2025 base","text":"坑点非常多的题，基本涵盖了大部分windows逆向常见的对抗手法进来先是一堆花，有jz,jnz和call-ret两种，还算常规，修复完后显示main看汇编时发现有try_except块，然后发现他手动触发了一个div0错误，怀疑错误处理里藏了加密，故nop掉错误处理的jmp部分，反编译except里的代码这样就显现出了完整的main然后这道题发现不能动调，进入main后调试器就失去与程序的链接，所以去查初始化部分仔细看这个api后发现这个api并不是遇到0就截止，而是完整遍历整个区域所有的数据，遇到无效地址跳过，出题人把0x411840这个反调试函数地址藏在了下面点进去那个函数里面也有很多花，并且多了 xor ebx 后cmp ebx 再走jnz的第三种花去完后如下所示下面两个字符串是做过简单加密的，动调打在这里看解密结果(因为此时反调还没初始化完所以可以调)两个字符串解开，ntdll和ZwSetInformationThread，这样就很明显了，手动调用线程信息设置函数，看了下下面参数0x11，就是将当前线程对调试器隐藏，nop掉这个call就行，注意因为vc添加了很多栈平衡校验，所以nop时要把前面的push传参都nop干净，不然运行会报错 主函数其实思路很清晰，先魔改rc4去初始化一个映射表，然后enc进去先用映射表对输入做置换，然后又是魔改的rc4，下面三个rc4根据会根据分支的不同在加密完再和某个数进行一次异或最后暴露出的except块里的代码就是一个循环异或，直接解就行，注意到rc4虽然加了一次异或但仍是可逆的，所以可以在进入rc4前下断点，把循环异或解出的数据用patch的方式写入rc4的参数里，这样rc4跑完后就自动解开了dest同样可以动调拿到，之后只要写脚本把映射重新改回去就行了 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include &lt;bits/stdc++.h&gt;using namespace std;unsigned char dest[] = { 0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76, 0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0, 0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15, 0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75, 0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84, 0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF, 0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8, 0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2, 0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73, 0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB, 0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79, 0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08, 0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A, 0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E, 0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF, 0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16};unsigned char enc[] = { 0x78, 0xD4, 0xD5, 0x92, 0x98, 0x62, 0x14, 0x14, 0xA5, 0x0F, 0x29, 0xAE, 0x9B, 0x58, 0x14, 0x21, 0x0D, 0x7D, 0xA4, 0x66, 0x48, 0x83, 0x79, 0x30, 0xF3, 0x21, 0xD1, 0xCD, 0xE2, 0x02, 0x8D, 0xAC, 0xBC, 0x4A, 0x81, 0xC1, 0x9C, 0xF5, 0xC2, 0xC8, 0x3F, 0x0A};unsigned char ida_chars[] = { 0x33, 0x50, 0xEF, 0x85, 0x21, 0x23, 0xEF, 0x33, 0x18, 0xC7, 0x04, 0xC7, 0xEF, 0xD8, 0x23, 0x04, 0xC7, 0xEF, 0xD8, 0x18, 0xEF, 0xAA, 0x12, 0xD8, 0xEF, 0x05, 0x05, 0x18, 0xD8, 0x12, 0x04, 0xC3, 0x96, 0x9A, 0x9A, 0xFB, 0xAA, 0x12, 0x33, 0x33, 0x04, 0xFF};int main(){ for (int i = 0; i &lt; 7; i++) { enc[6 * i] ^= enc[6 * i + 5]; for (int j = 5; j &gt;= 1; j--) { enc[6 * i + j] ^= enc[6 * i + j - 1]; } } for (int i = 0; i &lt; 42; i++) { if (i % 16 == 0) printf(&quot;\\n&quot;); printf(&quot;%02X &quot;, enc[i]); } for (int i = 0; i &lt; 42; i++) { for (int j = 0; j &lt; 256; j++) { if (dest[j] == ida_chars[i]) { printf(&quot;%c&quot;, j); break; } } } return 0;} flag{2af4101a-201a-4ab9-a664-903577cb9ff0}","link":"/ctf/WP/NPCCTF%202025%20base/"},{"title":"NPCCTF 2025 randomXor","text":"打开看了下main，看起来是很简单的伪随机，但是随机数算法是出题人自制的，而且是arm架构题目，不能用frida hook，所以考虑用模拟执行获取rand的结果我们在调用srand的代码块进入，然后随便找一个加密完的位置作为结束的位置因为bn有非常方便的读取段数据的api，所以直接把所有段都读进去 12345678910111213141516171819202122232425262728293031323334353637383940414243444546from unicorn import *from unicorn.arm64_const import *from binaryninja import *def hook_code(uc, address, size, user_data): bv = user_data[&quot;bv&quot;] assert isinstance(bv, BinaryView) if address == 0xbc8: print(&quot;w0 = {} w1 ={}&quot;.format(uc.reg_read( UC_ARM64_REG_W0), uc.reg_read(UC_ARM64_REG_W1))) global rd rd.append(uc.reg_read(UC_ARM64_REG_W0)) if address == 0xbdc: print(&quot;addr = {}&quot;.format(uc.reg_read(UC_ARM64_REG_X0) + uc.reg_read(UC_ARM64_REG_X1)))CODE_BASE = 0x0CODE_SIZE = 0x20000STACK_BASE = 0x10000000STACK_SIZE = 0x10000uc = Uc(UC_ARCH_ARM64, UC_MODE_ARM)uc.mem_map(CODE_BASE, CODE_SIZE, UC_PROT_ALL)uc.mem_map(STACK_BASE, STACK_SIZE, UC_PROT_ALL)uc.hook_add(UC_HOOK_CODE, hook_code, user_data={&quot;bv&quot;: bv})rd = []for segment in bv.segments: if segment.readable: start = segment.start end = segment.end size = end-start print(&quot;[+] Mapping segment: [{}]&quot;.format(hex(segment.start))) content = bv.read(start, size) uc.mem_write(start, content)addr = 0xb98addrEnd = 0xc18stack_top = STACK_BASE + STACK_SIZE - 0x100uc.reg_write(UC_ARM64_REG_SP, stack_top)uc.mem_write(stack_top, b&quot;\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00&quot;)uc.emu_start(addr, addrEnd)print(rd)uc.emu_stop() 0xbc8执行的了xor操作，我们在这个位置设置hook，读取w0就能直接拿到随机数 之后直接解密即可 123456789101112131415161718192021rd = [171, 171, 131, 225, 65, 75, 141, 216, 149, 238, 40, 235, 196, 132, 99, 176, 132, 203, 140, 159, 82, 45, 47, 112, 202, 233, 239, 208, 231, 132, 45, 46, 58, 242, 229, 224, 106, 121, 228, 112, 174, 107, 227, 40, 64, 239, 178, 108, 13, 68, 255, 143, 243, 74, 108, 95, 141, 203, 193, 122, 195, 218, 187, 40, 108, 174, 244, 32, 167, 107, 104, 52, 90, 201, 121, 99, 142, 99, 227, 128, 118, 224, 188, 142, 131, 33, 128, 109, 35, 105, 191, 19, 47, 225, 46, 183, 46, 200, 18, 38, 243, 17, 216, 185, 181, 68, 240, 165, 25, 104, 56, 165, 154, 91, 88, 2, 209, 171, 137, 112, 59, 9, 149, 238, 1, 40, 165, 243]cipher = [0xCD, 0xC7, 0xE2, 0x86, 0x3A, 0x19, 0xB9, 0xB6, 0xF1, 0x81, 0x45, 0xB4, 0xB6, 0xE5, 0x0D, 0xD4, 0xB4, 0xA6, 0xD3, 0xF7, 0x33, 0x5D, 0x5F, 0x09, 0x95, 0xAF, 0x9A, 0xBE, 0x89, 0xEA, 0x54, 0x71, 0x68, 0xC6, 0x8B, 0x84, 0x05, 0x14, 0xBB, 0x41, 0xDD, 0x34, 0x91, 0x1B, 0x21, 0x83, 0xDE, 0x15, 0x52, 0x22, 0x8A, 0xE1, 0xBD, 0x33, 0x4D, 0x7E, 0xD2, 0xA3, 0xA9, 0x12, 0xF1, 0xE9, 0x88, 0x60, 0x24, 0xE6, 0xAB, 0x54, 0xCF, 0x02, 0x1B, 0x6B, 0x6B, 0xBA, 0x26, 0x09, 0xFB, 0x10, 0x97, 0xDF, 0x17, 0xBF, 0xCC, 0xE7, 0xB0, 0x42, 0xE5, 0x32, 0x4C, 0x0F, 0xE0, 0x60, 0x47, 0xD0, 0x5A, 0xE8, 0x48, 0xAE, 0x74, 0x4D, 0x98, 0x7A, 0xB3, 0xD2, 0xDE, 0x1B, 0x96, 0x91, 0x7A, 0x03, 0x67, 0xCF, 0xF0, 0x31, 0x32, 0x49, 0x9A, 0xE0, 0xC2, 0x3B, 0x51, 0x63, 0xFF, 0x84, 0x60, 0x5B, 0xC1, 0x8E]print(len(rd))for i in range(0, 128): print(chr(cipher[i] ^ rd[i]), end='') flag{R4ndom_rand0m_happy_Funnny_R4ndom_1s_r3ally_funNy!!_hhh233HHH_this_1s_just_a_pi3ce_of_sh1t_fffkkkkkk_f4ck_jjjjKKKKKjjjjasd}","link":"/ctf/WP/NPCCTF%202025%20randomXor/"},{"title":"DES","text":"简介DES加密是经典的基于Feistel网络结构的块加密，DES标准中字节的处理方式为大端序，DES接受一个64位（64bit）的明文和一个64位的key，返回64位的密文在DES流程的开始，64位的key被传入PC1函数生成56位的真正密钥，因为原密钥中有8位是校验位而这56位的密钥会再被拆分成左右两个各28位的密钥 123456789101112131415161718pair&lt;uint32_t, uint32_t&gt; PC1(uint64_t key){ uint8_t pc1L[] = {57, 49, 41, 33, 25, 17, 9, 1, 58, 50, 42, 34, 26, 18, 10, 2, 59, 51, 43, 35, 27, 19, 11, 3, 60, 52, 44, 36}; uint8_t pc1R[] = {63, 55, 47, 39, 31, 23, 15, 7, 62, 54, 46, 38, 30, 22, 14, 6, 61, 53, 45, 37, 29, 21, 13, 5, 28, 20, 12, 4}; pair&lt;uint32_t, uint32_t&gt; keyPair{0, 0}; for (int i = 0; i &lt; 28; i++) { keyPair.first |= ((key &gt;&gt; (64 - pc1L[i])) &amp; 1) &lt;&lt; (27 - i); keyPair.second |= ((key &gt;&gt; (64 - pc1R[i])) &amp; 1) &lt;&lt; (27 - i); } return keyPair;} 两个28位密钥分别左旋特定位数后进入PC2用于生成16个48位子密钥，PC2中有一个盒用于决定选择哪48位来作为密钥 123456789101112131415161718192021222324252627void keyGen(pair&lt;uint32_t, uint32_t&gt; keyPair){ uint8_t offsets[] = {1, 1, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 1}; for (int i = 0; i &lt; 16; i++) { keyPair.first = leftRotate(keyPair.first, offsets[i]); keyPair.second = leftRotate(keyPair.second, offsets[i]); Keys[i] = PC2(((uint64_t)keyPair.first &lt;&lt; 28) | keyPair.second); }}uint64_t PC2(uint64_t key){ uint8_t pc2[] = {14, 17, 11, 24, 1, 5, 3, 28, 15, 6, 21, 10, 23, 19, 12, 4, 26, 8, 16, 7, 27, 20, 13, 2, 41, 52, 31, 37, 47, 55, 30, 40, 51, 45, 33, 48, 44, 49, 39, 56, 34, 53, 46, 42, 50, 36, 29, 32}; uint64_t subKey = 0; for (int i = 0; i &lt; 48; i++) { subKey |= ((key &gt;&gt; (56 - pc2[i])) &amp; 1) &lt;&lt; (47 - i); } return subKey;} 至此为止密钥全部准备完毕，明文被分为左右各32位进入Feistel网络循环流程 1234567891011121314void desEncrypt(uint64_t *plain, uint64_t key){ keyGen(PC1(key)); uint64_t afterIP = IP(*plain); uint32_t l = afterIP &gt;&gt; 32, r = afterIP &amp; 0xFFFFFFFF; for (int i = 0; i &lt; 16; i++) { pair&lt;uint32_t, uint32_t&gt; lr = goRound(l, r, Keys[i]); l = lr.first; r = lr.second; } *plain = ((uint64_t)r &lt;&lt; 32) | l; *plain = FP(*plain);} 明文在进入和结束加密时还要经历IP,FP两次置换，这两次置换只是简单映射 12345678910111213141516171819202122232425262728293031323334uint64_t IP(uint64_t messagge){ uint64_t afterIP = 0; uint8_t ip[] = {58, 50, 42, 34, 26, 18, 10, 2, 60, 52, 44, 36, 28, 20, 12, 4, 62, 54, 46, 38, 30, 22, 14, 6, 64, 56, 48, 40, 32, 24, 16, 8, 57, 49, 41, 33, 25, 17, 9, 1, 59, 51, 43, 35, 27, 19, 11, 3, 61, 53, 45, 37, 29, 21, 13, 5, 63, 55, 47, 39, 31, 23, 15, 7}; for (int i = 0; i &lt; 64; i++) { afterIP |= ((messagge &gt;&gt; (64 - ip[i])) &amp; 1) &lt;&lt; (63 - i); } return afterIP;}uint64_t FP(uint64_t messagge){ uint64_t afterFP = 0; uint8_t fp[] = {40, 8, 48, 16, 56, 24, 64, 32, 39, 7, 47, 15, 55, 23, 63, 31, 38, 6, 46, 14, 54, 22, 62, 30, 37, 5, 45, 13, 53, 21, 61, 29, 36, 4, 44, 12, 52, 20, 60, 28, 35, 3, 43, 11, 51, 19, 59, 27, 34, 2, 42, 10, 50, 18, 58, 26, 33, 1, 41, 9, 49, 17, 57, 25}; for (int i = 0; i &lt; 64; i++) { afterFP |= ((messagge &gt;&gt; (64 - fp[i])) &amp; 1) &lt;&lt; (63 - i); } return afterFP;} Feistel轮函数如下所示 1234567891011uint32_t feistel(uint32_t a, uint64_t key){ uint64_t t = expand(a) ^ key; uint32_t afterS = S(t); afterS = P(afterS); return afterS;}pair&lt;uint32_t, uint32_t&gt; goRound(uint32_t l, uint32_t r, uint64_t key){ return {r, l ^ feistel(r, key)};} 数据先经过E盒拓展为48位后与48位密钥异或，然后进入S盒重新映射为32位，最后由P盒再进行一轮置换后输出 1234567891011121314151617uint64_t expand(uint32_t a){ uint8_t e[] = {32, 1, 2, 3, 4, 5, 4, 5, 6, 7, 8, 9, 8, 9, 10, 11, 12, 13, 12, 13, 14, 15, 16, 17, 16, 17, 18, 19, 20, 21, 20, 21, 22, 23, 24, 25, 24, 25, 26, 27, 28, 29, 28, 29, 30, 31, 32, 1}; uint64_t afterE = 0; for (int i = 0; i &lt; 48; i++) { afterE |= ((a &gt;&gt; (32 - e[i])) &amp; 1) &lt;&lt; (47 - i); } return afterE;} S盒有8个，每个S盒是一个4*16的结构，48位的输出被分为8个6位的块分别进入对应的S盒，每块的第1和第6个位用于索引行(0x00 ~ 0x11)，其余四位用于索引列(0x0000 ~ 0x1111)，S盒中的数都是4位的，最后合起来得到一个32位的输出 1234567891011uint64_t S(uint64_t a){ uint32_t res = 0; for (int i = 0; i &lt; 8; i++) { uint8_t row = ((((a &gt;&gt; (i * 6)) &amp; 0x20)) &gt;&gt; 4) | ((a &gt;&gt; (i * 6)) &amp; 1); uint8_t col = ((a &gt;&gt; (i * 6)) &amp; 0x1E) &gt;&gt; 1; res |= S_box[i][row * 16 + col] &lt;&lt; (i * 4); } return res;} P置换就是再次打乱S盒的输出 1234567891011121314151617uint32_t P(uint64_t a){ uint8_t p[] = {16, 7, 20, 21, 29, 12, 28, 17, 1, 15, 23, 26, 5, 18, 31, 10, 2, 8, 24, 14, 32, 27, 3, 9, 19, 13, 30, 6, 22, 11, 4, 25}; uint32_t afterP = 0; for (int i = 0; i &lt; 32; i++) { afterP |= ((a &gt;&gt; (32 - p[i])) &amp; 1) &lt;&lt; (31 - i); } return afterP;} 至此DES的流程全部结束，按照图例的话如下图所示 特征因为DES的代码过于庞大，且涉及大量位操作，在反编译器中观察DES的特征非常困难，但是DES有非常多的盒，其中部分盒是精心设计的，修改这部分盒会严重影响DES在对抗暴力破解时的安全性，所以我们可以通过这些一般不会修改的盒识别DES S盒S盒引入了非线性操作，且S盒的每一位都设计过用以抵抗差分和线性密码分析，一般不会修改S盒 123456789101112131415161718192021222324252627282930313233uint8_t S_box[8][64] = {{14, 4, 13, 1, 2, 15, 11, 8, 3, 10, 6, 12, 5, 9, 0, 7, 0, 15, 7, 4, 14, 2, 13, 1, 10, 6, 12, 11, 9, 5, 3, 8, 4, 1, 14, 8, 13, 6, 2, 11, 15, 12, 9, 7, 3, 10, 5, 0, 15, 12, 8, 2, 4, 9, 1, 7, 5, 11, 3, 14, 10, 0, 6, 13},{15, 1, 8, 14, 6, 11, 3, 4, 9, 7, 2, 13, 12, 0, 5, 10, 3, 13, 4, 7, 15, 2, 8, 14, 12, 0, 1, 10, 6, 9, 11, 5, 0, 14, 7, 11, 10, 4, 13, 1, 5, 8, 12, 6, 9, 3, 2, 15, 13, 8, 10, 1, 3, 15, 4, 2, 11, 6, 7, 12, 0, 5, 14, 9},{10, 0, 9, 14, 6, 3, 15, 5, 1, 13, 12, 7, 11, 4, 2, 8, 13, 7, 0, 9, 3, 4, 6, 10, 2, 8, 5, 14, 12, 11, 15, 1, 13, 6, 4, 9, 8, 15, 3, 0, 11, 1, 2, 12, 5, 10, 14, 7, 1, 10, 13, 0, 6, 9, 8, 7, 4, 15, 14, 3, 11, 5, 2, 12},{7, 13, 14, 3, 0, 6, 9, 10, 1, 2, 8, 5, 11, 12, 4, 15, 13, 8, 11, 5, 6, 15, 0, 3, 4, 7, 2, 12, 1, 10, 14, 9, 10, 6, 9, 0, 12, 11, 7, 13, 15, 1, 3, 14, 5, 2, 8, 4, 3, 15, 0, 6, 10, 1, 13, 8, 9, 4, 5, 11, 12, 7, 2, 14},{2, 12, 4, 1, 7, 10, 11, 6, 8, 5, 3, 15, 13, 0, 14, 9, 14, 11, 2, 12, 4, 7, 13, 1, 5, 0, 15, 10, 3, 9, 8, 6, 4, 2, 1, 11, 10, 13, 7, 8, 15, 9, 12, 5, 6, 3, 0, 14, 11, 8, 12, 7, 1, 14, 2, 13, 6, 15, 0, 9, 10, 4, 5, 3},{12, 1, 10, 15, 9, 2, 6, 8, 0, 13, 3, 4, 14, 7, 5, 11, 10, 15, 4, 2, 7, 12, 9, 5, 6, 1, 13, 14, 0, 11, 3, 8, 9, 14, 15, 5, 2, 8, 12, 3, 7, 0, 4, 10, 1, 13, 11, 6, 4, 3, 2, 12, 9, 5, 15, 10, 11, 14, 1, 7, 6, 0, 8, 13},{4, 11, 2, 14, 15, 0, 8, 13, 3, 12, 9, 7, 5, 10, 6, 1, 13, 0, 11, 7, 4, 9, 1, 10, 14, 3, 5, 12, 2, 15, 8, 6, 1, 4, 11, 13, 12, 3, 7, 14, 10, 15, 6, 8, 0, 5, 9, 2, 6, 11, 13, 8, 1, 4, 10, 7, 9, 5, 0, 15, 14, 2, 3, 12},{13, 2, 8, 4, 6, 15, 11, 1, 10, 9, 3, 14, 5, 0, 12, 7, 1, 15, 13, 8, 10, 3, 7, 4, 12, 5, 6, 11, 0, 14, 9, 2, 7, 11, 4, 1, 9, 12, 14, 2, 0, 6, 10, 13, 15, 3, 5, 8, 2, 1, 14, 7, 4, 10, 8, 13, 15, 12, 9, 0, 3, 5, 6, 11}}; P盒P盒的特殊设计使得每一轮由同一个S盒输出的4个bit在下一轮都被分散到另外4个不同S盒中进行处理（增强扩散性） 123456789uint8_t p[] = {16, 7, 20, 21, 29, 12, 28, 17, 1, 15, 23, 26, 5, 18, 31, 10, 2, 8, 24, 14, 32, 27, 3, 9, 19, 13, 30, 6, 22, 11, 4, 25}; E盒E盒负责将32位的输入扩展到48位，对混淆能力由很大影响 123456789uint8_t e[] = {32, 1, 2, 3, 4, 5,4, 5, 6, 7, 8, 9,8, 9, 10, 11, 12, 13,12, 13, 14, 15, 16, 17,16, 17, 18, 19, 20, 21,20, 21, 22, 23, 24, 25,24, 25, 26, 27, 28, 29,28, 29, 30, 31, 32, 1}; 实现考虑到DES现在已经被证明不安全，且其加密过程严重依赖系统端序，DES标准为大端序，而现代计算机大多数为小端序，故不给出完整实现，如果遇到需要手动解密的DES，只需要根据Feistel网络的性质，将16个子密钥倒着使用即可解密 referenceDES-wikipedia","link":"/ctf/%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86/DES/"},{"title":"RC4","text":"简介RC4是一种比较简单的流加密算法，流加密的特点是逐字节加密，相邻字节间相互独立RC4的密钥不能超过256个字节，这点从初始化密钥流的部分也能看出，因为初始化密钥流使用了swap，整个操作失去线性，所以可以保证密钥流一定的随机性RC4大部分的操作都是在初始化密钥盒，最后只是进行了异或，可以说拿到了密钥盒就是破解了RC4 特征虽然说本文的重点不在特征，但还是指出RC4的一些比较明显的特征，一个是置换盒初始化算法，一个就是最后密钥流对输入的异或 实现1234567891011121314151617181920212223242526272829#include &lt;bits/stdc++.h&gt;using namespace std;int main(){ uint8_t initBox[256]; for (int i = 0; i &lt; 256; i++) initBox[i] = i; // 初始化向量 int j = 0; char key[] = &quot;Eleven&quot;; for (int i = 0; i &lt; 256; i++) { j = (j + initBox[i] + key[i % strlen(key)]) % 256; // 初始化密钥流向量 swap(initBox[i], initBox[j]); } char rawInput[] = &quot;thisIsASecretMessage&quot;; int len = strlen(rawInput); int i = 0; j = 0; for (int k = 0; k &lt; len; k++) { i = (i + 1) % 256; j = (j + initBox[i]) % 256; swap(initBox[i], initBox[j]); int t = (initBox[i] + initBox[j]) % 256; int K = initBox[t]; // 密钥流 rawInput[k] = rawInput[k] ^ K; // 将密钥与输入异或 } return 0;} 破解逐字节异或，一般逆向中其实怎么都能破解，可以动调获取box,或者直接把密文输进去，或者在RC4入口点把输入的内容patch成密文，根据异或的性质RC4的加密算法就是解密算法，跑两遍等于没跑，一般题目会在key上做文章，或者在每轮异或后额外异或一个常数之类的，防止直接拿到key后一把梭继续观察源码注意到这个t其实还能加入偏移，K也能加入常数或偏移，初始化向量也可能事先打乱而不是0,1,2,3…，甚至向量的位数也可以魔改，实战中要具体观察实现 referencewikipedia","link":"/ctf/%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86/RC4/"},{"title":"TEA","text":"简介TEA加密是一种经典的块加密，使用64位密文和128位(4个uint_32t)密钥，并使用Feistel框架进行加密Feistel框架指的是将密文分成两个等长块，每轮加密对两个块分别施加轮加密函数并进行交换，这点在TEA中体现为v0的累加值由v1计算得到，反之亦然注意使用TEA加密时如果密文小于64位(bit)要填充0字节占位，否则由于指针类型转换会将垃圾数据引入加密，当密文大于64位时要将密文分块分别执行TEA加密 特征应主要关注其Feistel网络结构而不是关注常量，因为TEA加密的加密计算方式，计算轮次，累加常量均可以魔改，但是密文被分为两个块并在每轮加密中采用相似的加密函数这个特点是不会变的，同时关注每轮中v0,v1分别由v1,v0计算得到，密钥通常为128位即4个uint_32t 实现12345678910111213void teaEncrypt(uint32_t *v, uint32_t *k){ uint32_t sum = 0, v0 = v[0], v1 = v[1]; // 将输入分为两个32位的块 uint32_t delta = 0x9E3779B9; //初始常量，可以为任何数 for (int i = 0; i &lt; 32; i++) { v0 += ((v1 &lt;&lt; 4) + k[0]) ^ (v1 + sum) ^ ((v1 &gt;&gt; 5) + k[1]); // 轮加密函数 sum += delta; v1 += ((v0 &lt;&lt; 4) + k[2]) ^ (v0 + sum) ^ ((v0 &gt;&gt; 5) + k[3]); // 轮加密函数 } v[0] = v0; // 应用修改 v[1] = v1;} 解密因为TEA加密是由Feistel框架设计来的，所以解密Feistel密码的方式对TEA也适用，我们只需根据加密完的最后状态，反向执行同样轮次的轮加密，就能解出明文 1234567891011121314void teaDecrypt(uint32_t *v, uint32_t *k){ uint32_t sum = 0, v0 = v[0], v1 = v[1]; uint32_t delta = 0x9E3779B9; sum = delta * 32; // 获取最终状态的累加和 for (int i = 0; i &lt; 32; i++) { v1 -= ((v0 &lt;&lt; 4) + k[2]) ^ (v0 + sum) ^ ((v0 &gt;&gt; 5) + k[3]); // 因为v1是最后被计算的，所以解密时要先计算v1 sum -= delta; // 累加改为递减 v0 -= ((v1 &lt;&lt; 4) + k[0]) ^ (v1 + sum) ^ ((v1 &gt;&gt; 5) + k[1]); } v[0] = v0; v[1] = v1;} 完整代码12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;bits/stdc++.h&gt;using namespace std;void teaEncrypt(uint32_t *v, uint32_t *k){ uint32_t sum = 0, v0 = v[0], v1 = v[1]; uint32_t delta = 0x9E3779B9; for (int i = 0; i &lt; 32; i++) { v0 += ((v1 &lt;&lt; 4) + k[0]) ^ (v1 + sum) ^ ((v1 &gt;&gt; 5) + k[1]); sum += delta; v1 += ((v0 &lt;&lt; 4) + k[2]) ^ (v0 + sum) ^ ((v0 &gt;&gt; 5) + k[3]); } v[0] = v0; v[1] = v1;}void teaDecrypt(uint32_t *v, uint32_t *k){ uint32_t sum = 0, v0 = v[0], v1 = v[1]; uint32_t delta = 0x9E3779B9; sum = delta * 32; for (int i = 0; i &lt; 32; i++) { v1 -= ((v0 &lt;&lt; 4) + k[2]) ^ (v0 + sum) ^ ((v0 &gt;&gt; 5) + k[3]); sum -= delta; v0 -= ((v1 &lt;&lt; 4) + k[0]) ^ (v1 + sum) ^ ((v1 &gt;&gt; 5) + k[1]); } v[0] = v0; v[1] = v1;}int main(){ uint32_t key[4] = {0x01234567, 0x89ABCDEF, 0xFEDCBA98, 0x76543210}; char plaintext[] = &quot;Eleven11&quot;; teaEncrypt((uint32_t *)plaintext, key); for (int i = 0; i &lt; 8; i++) printf(&quot;%02X &quot;, plaintext[i] &amp; 0xFF); printf(&quot;\\n&quot;); teaDecrypt((uint32_t *)plaintext, key); for (int i = 0; i &lt; 8; i++) printf(&quot;%c&quot;, plaintext[i]); return 0;} refernceTEA-wikipediaFeistel network-wikipedia","link":"/ctf/%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86/TEA/"},{"title":"XTEA","text":"简介因为TEA加密有密钥调度算法过于简单(直接调用),密钥之间等价(每个密钥都被平均的使用)这两个缺陷，所以有了XTEA加密，XTEA将密钥调度的算法改为非线性的，并且略微修改了轮加密计算方法 特征XTEA最大的特征就是每次加密使用的密钥由当前sum的累加值决定，通常是sum经过计算后&amp;3，其余的特征和TEA加密基本相同 实现12345678910111213void xteaEncrypt(uint32_t *v, uint32_t *k){ uint32_t sum = 0, v0 = v[0], v1 = v[1]; uint32_t delta = 0x9E3779B9; for (int i = 0; i &lt; 32; i++) { v0 += (((v1 &lt;&lt; 4) ^ (v1 &gt;&gt; 5)) + v1) ^ (sum + k[sum &amp; 3]); // 使用非线性方式调用key sum += delta; v1 += (((v0 &lt;&lt; 4) ^ (v0 &gt;&gt; 5)) + v0) ^ (sum + k[(sum &gt;&gt; 11) &amp; 3]); } v[0] = v0; v[1] = v1;} 解密虽然XTEA针对TEA进行了很多改进，但是对于逆向工程来说，我们并不是进行黑盒分析，所以XTEA和TEA并没有很大不同，直接使用Feistel密码的解法把运算过程反过来即可 1234567891011121314void xteaDecrypt(uint32_t *v, uint32_t *k){ uint32_t sum = 0, v0 = v[0], v1 = v[1]; uint32_t delta = 0x9E3779B9; sum = delta * 32; for (int i = 0; i &lt; 32; i++) { v1 -= (((v0 &lt;&lt; 4) ^ (v0 &gt;&gt; 5)) + v0) ^ (sum + k[(sum &gt;&gt; 11) &amp; 3]); sum -= delta; v0 -= (((v1 &lt;&lt; 4) ^ (v1 &gt;&gt; 5)) + v1) ^ (sum + k[sum &amp; 3]); } v[0] = v0; v[1] = v1;} 完整代码123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;bits/stdc++.h&gt;using namespace std;void xteaEncrypt(uint32_t *v, uint32_t *k){ uint32_t sum = 0, v0 = v[0], v1 = v[1]; uint32_t delta = 0x9E3779B9; for (int i = 0; i &lt; 32; i++) { v0 += (((v1 &lt;&lt; 4) ^ (v1 &gt;&gt; 5)) + v1) ^ (sum + k[sum &amp; 3]); sum += delta; v1 += (((v0 &lt;&lt; 4) ^ (v0 &gt;&gt; 5)) + v0) ^ (sum + k[(sum &gt;&gt; 11) &amp; 3]); } v[0] = v0; v[1] = v1;}void xteaDecrypt(uint32_t *v, uint32_t *k){ uint32_t sum = 0, v0 = v[0], v1 = v[1]; uint32_t delta = 0x9E3779B9; sum = delta * 32; for (int i = 0; i &lt; 32; i++) { v1 -= (((v0 &lt;&lt; 4) ^ (v0 &gt;&gt; 5)) + v0) ^ (sum + k[(sum &gt;&gt; 11) &amp; 3]); sum -= delta; v0 -= (((v1 &lt;&lt; 4) ^ (v1 &gt;&gt; 5)) + v1) ^ (sum + k[sum &amp; 3]); } v[0] = v0; v[1] = v1;}int main(){ uint32_t key[4] = {0x01234567, 0x89ABCDEF, 0xFEDCBA98, 0x76543210}; char plaintext[] = &quot;Eleven11&quot;; xteaEncrypt((uint32_t *)plaintext, key); for (int i = 0; i &lt; 8; i++) printf(&quot;%02X &quot;, plaintext[i] &amp; 0xFF); printf(&quot;\\n&quot;); xteaDecrypt((uint32_t *)plaintext, key); for (int i = 0; i &lt; 8; i++) printf(&quot;%c&quot;, plaintext[i]); return 0;} refernceXTEA-wikipediaFeistel network-wikipedia","link":"/ctf/%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86/XTEA/"},{"title":"frida常用api备忘录","text":"javascript APIProcessProcess.id : number返回目标进程的PID 1console.log(&quot;processid = &quot;, Process.id); 12$ python launch.py processid = 3819 Process.arch : String返回目标进程的架构 1console.log(&quot;processArch = &quot;, Process.arch); 12$ python launch.py processArch = x64 get和find系的函数建议使用get系,在查找失败时get抛出错误,而find返回NULLProcess.getModuleByAddress(address : NativePointer) : Module address为实际地址Process.getModuleByName(name : String) : Module 根据地址或名称返回 已加载的 目标库(.so库)的对象(Module对象)，地址需提供原生指针 123var lib: Module = Process.getModuleByName(&quot;liba0x9.so&quot;);var lb: Module = Process.getModuleByAddress(lib.base);console.log(&quot;lbname = &quot;, lb.name); 12$ python launch.pylbname = liba0x9.so Process.enumerateModules() : Module[]返回所有已加载的.so库，返回内容是Module对象组成的js数组 1234567var ls = Process.enumerateModules(); for (let i = 0; i &lt; ls.length; i++) { console.log(ls[i].base); console.log(ls[i].name); console.log(ls[i].path); console.log(&quot;------&quot;); } 123456780x768bb30ca000libgraphicsenv.so/system/lib64/libgraphicsenv.so------0x768bb6608000libgui.so/system/lib64/libgui.so..... ThreadThread.backtrace(context, backtracer) : NativePointer[]在java层不如直接调用android.util.log好用，主要用于追踪native层调用栈，通常加上this.context，backtracer有.FUZZY和.ACCURATE两种模式可选返回当前调用栈，返回类型是NativePointer组成的js数组，使用DebugSymbolfromAddress转化为可读符号 123456789var lib: Module = Module.load(&quot;liba0x9.so&quot;); console.log(lib.enumerateExports()[0].name); Interceptor.attach(lib.getExportByName(lib.enumerateExports()[0].name), { onEnter(args) { console.log(Thread.backtrace(this.context, Backtracer.ACCURATE).map(DebugSymbol.fromAddress).join('\\n')); }, onLeave(retval) { retval.replace(1337 as any); }, }) 1234$ python launch.pyJava_com_ad2001_a0x9_MainActivity_check_1flag0x768914fa0a2c libart.so!art_quick_generic_jni_trampoline+0xdc0x768914f83912 libart.so!MterpHelpers+0x1f5 ModuleModule类本身的属性 member use name : String 库名 base : NativePointer 库基地址 size : number 库大小 path : String 库的绝对路径 ModuleObj.enumerateImports() : ModuleImportDetails[]返回这个库的所有导入符号,类型为ModuleImportDetails组成的js数组 ModuleImportDetailsModuleImportDetails类的属性 member use type : ModuleImportType (function | variable) 导入符号的类型 name : String 导入符号的名称 module : String 导入符号来自哪个文件 address : NativePointer 导入符号在内存中的地址(绝对地址)，用于直接调用或修改导入函数 slot : NativePointer 导入表中指向导入函数的指针,用于重定向导入函数 123var lib: Module = Module.load(&quot;liba0x9.so&quot;);var ls = lib.enumerateImports();console.log(ls[0].name, &quot;from module :&quot;, ls[0].module); 12$ python launch.py __cxa_finalize from module : /apex/com.android.runtime/lib64/bionic/libc.so ModuleObj.enumerateExports() : ModuleExportDetails[]返回这个库的所有导出符号,类型为ModuleExportDetails组成的js数组 member use type : ModuleExportType (function | variable) 导出符号的类型 name : String 导出符号的名称 address : NativePointer 导出符号在内存中的地址(绝对地址)，用于直接调用或修改导出函数 ModuleObj.getExportByName(exportName : String) : NativePointer根据名称返回对应导出符号的指针，是frida hook native层函数的主要方法 Module.load(name : String) : Module根据名称(是的就是名称，至少vsc的frida type hint 里提示的是输入名称)返回对应native库的对象，与Process.getModuleByxxx的不同是该方法无需目标库已被加载，且使用该方法可以手动加载目标库 12var lib: Module = Module.load(&quot;libfrida0xa.so&quot;);console.log(lib.name); 12$ python launch.pylibfrida0xa.so Module.ensureInitialized(name : String) : void在目标库加载完成前阻塞程序进行 Module.getBaseAddress(name : String) : NativePointer返回目标库的基地址,等同于Module.load(name).base Module.getExportByName(moduleName : String | null, exportName : String) : NativePointer根据库名和符号名查找对应的导出符号，库名可缺省，此时在全局对该符号进行搜索 MemoryMemory.scan(address : NativePointer, size : number, pattern : String, callbacks : MemoryScanCallbacks) : void这是一个异步函数，用于在内存中扫描对应的模式，address指定了起始地址，size指定了扫描的字节数pattern是一个模式串，必须为以下任意的格式之一1.完全匹配 “1F 13 00 2F”2.通配符 “?F 13 00 ??” 其中?在匹配时可以是0~F中的任意一个3.掩码 “”13 37 13 37 : 1F FF FF F1”” 后面的为掩码，掩码中为1的位表示需要匹配，为0的位则可以是任意值 MemoryScanCallbacksMemoryScanCallbacks 是一个结构体，定义如下 1234567{ onMatch(address : NativePointer, size : number) : function //匹配成功的回调函数，address为成功匹配的地址，size为匹配到的长度 //该函数可通过 return 'stop' 提前结束 onError(reason : String) : function //处理错误的回调函数 onComplete() ： function //匹配结束的回调函数} 这个函数的同步版本为Memory.scanSync(address, size, pattern),返回由匹配到的address和size组成的对象的数组 Memory.protect(address : NativePointer, size : number, protection : String) : boolean修改对应位置内存的权限，返回true表示操作成功，protection为形同”rwx”的字符串 Memory.patchCode(address : NativePointer, size : number, apply : function) : voidapply里是具体要对内存进行修改的操作，address为起始地址，size为修改区域的字节数 NativeFunction获取native层函数的引用 NativeFunction(address, returnType, argTypes[, abi])创建方法var func = new NativeFunction(address, returnType, argTypes[, abi])address : NativePointer 函数地址returnType : [type] 返回类型argTypes : [types…] 参数类型 1const getFlag = new NativeFunction(getFlagPtr, ['void'], ['int', 'int']); // 用例 可用类型 123456789101112131415161718192021voidpointerintuintlongulongcharucharsize_tssize_tfloatdoubleint8uint8int16uint16int32uint32int64uint64bool NativeCallback创建一个native函数回调并返回其指针，实际上就是由js层创建了一个native函数，可以传给native层与 NativeFunction 的区别是 NativeFunction 是从native层到js层，而 NativeCallback 是创建自己的原生函数创建方法new NativeCallback(func, returnType, argTypes[, abi])func是函数的js实现，其他和 NativeFunction 均相同 Interceptorfrida最重要的模块之一，用于hook native函数， Interceptor.attach( target , callbacks )target 为 NativePointer ,callback为 {onEnter: Function(args) , onLeave: Function (retval) }的经典组合注意此处虽然大多数情况下是hook函数，但是只要访问目标地址就会触发回调，所以也可以用base+offset来跟踪特定位置的内存Interceptor.attach 同样会返回一个对当前拦截器的引用，可以调用self.detach()方法解除当前拦截器 123456789101112// 该拦截器在触发第6次hook后会自动解除var cnt = 0; let cnthook = Interceptor.attach(lib.base.add(0x170B8), { onEnter: function () { console.log(&quot;some memory accessed&quot;); cnt++; console.log(cnt) if (cnt &gt; 5) { cnthook.detach(); } } }) TODO:InterceptorJavaXXXWriterXXXRelocatorhexdumprpc.exportsTiming events Python APIfrida的python层主要负责拉起进程以及与js通信，涉及的业务逻辑并不多 参考链接Frida 官方文档Frida-Labs","link":"/ctf/Andorid/firdaApi/firdaApi/"},{"title":"XXTEA","text":"简介XXTEA是XTEA的改进版，与它的前身不同，XXTEA大量魔改了原来的加密结构，首先是采用了非对称Feistel网络结构，数据不再被分为两个32位块，同时也不再一次只处理64位的数据，而是直接把所有数据分为多个32位块，然后用CBC模式循环加密，令块数为n，则一轮加密指的是将这n个块的数据各变换一次，总的加密轮次由round=6+52/n给出，注意这个公式仅仅是为了在安全性和性能之间做出平衡，理论上加密的轮次并没有要求。加密函数MX也进行了修改，更换了计算方式和密钥选择方式。 特征标准版本的XXTEA加密循环轮次由数据规模n绝定，当然rounds=6+52/n这个公式完全可以魔改，然后是每轮加密中的CBC结构特征，以及128位密钥 实现12345678910111213141516171819202122#define MX ((z &gt;&gt; 5 ^ y &lt;&lt; 2) + (y &gt;&gt; 3 ^ z &lt;&lt; 4) ^ (sum ^ y) + (k[p &amp; 3 ^ e] ^ z))void xxteaEncrtpy(uint32_t *v, size_t n, uint32_t *k){ uint32_t y, z, sum; uint32_t p, rounds, e; uint32_t delta = 0x9E3779B9; rounds = 6 + 52 / n; sum = 0; z = v[n - 1]; do { sum += delta; e = (sum &gt;&gt; 2) &amp; 3; // 引入非线性计算，使得每次取出的key值缺少规律 for (p = 0; p &lt; n - 1; p++) { y = v[p + 1]; z = v[p] += MX; // 每个块加密是增加的偏移量实际上由上一个块(z)和下一个块(y)的值和sum共同决定 } y = v[0]; // 此处其实是循环加密的端点，当然可以对下标取模把这部分写进循环里 z = v[n - 1] += MX; } while (--rounds); // 实际上是把相同的操作重复round轮} 解密虽然整个结构进行了大程度魔改，但仍是Fesitel网络，所以只要想办法把运算逆转过来就能解密 123456789101112131415161718192021void xxteaDecrypt(uint32_t *v, size_t n, uint32_t *k){ uint32_t y, z, sum; uint32_t p, rounds, e; uint32_t delta = 0x9E3779B9; rounds = 6 + 52 / n; sum = rounds * delta; y = v[0]; // n-1号块的下一个块是0号块 do { e = (sum &gt;&gt; 2) &amp; 3; for (p = n - 1; p &gt; 0; p--) // 反向循环 { z = v[p - 1]; // 因为是反着循环，所以这里是上一个块 y = v[p] -= MX; // 这里是也是取上一个和下一个块的值作为参数 } z = v[n - 1]; // 0号块的上一个块是n-1号块 y = v[0] -= MX; sum -= delta; } while (--rounds);} 完整代码代码中加密数据长度正好为64位，注意当长度不为32位的倍数时记得占位填充 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;bits/stdc++.h&gt;using namespace std;#define MX ((z &gt;&gt; 5 ^ y &lt;&lt; 2) + (y &gt;&gt; 3 ^ z &lt;&lt; 4) ^ (sum ^ y) + (k[p &amp; 3 ^ e] ^ z))void xxteaEncrtpy(uint32_t *v, size_t n, uint32_t *k){ uint32_t y, z, sum; uint32_t p, rounds, e; uint32_t delta = 0x9E3779B9; rounds = 6 + 52 / n; sum = 0; z = v[n - 1]; do { sum += delta; e = (sum &gt;&gt; 2) &amp; 3; // 引入非线性计算，使得每次取出的key值缺少规律 for (p = 0; p &lt; n - 1; p++) { y = v[p + 1]; z = v[p] += MX; // 每个块加密是增加的偏移量实际上由上一个块(z)和下一个块(y)的值和sum共同决定 } y = v[0]; // 此处其实是循环加密的端点，当然可以对下标取模写进循环里 z = v[n - 1] += MX; } while (--rounds); // 实际上是把相同的操作重复round轮}void xxteaDecrypt(uint32_t *v, size_t n, uint32_t *k){ uint32_t y, z, sum; uint32_t p, rounds, e; uint32_t delta = 0x9E3779B9; rounds = 6 + 52 / n; sum = rounds * delta; y = v[0]; // n-1号块的下一个块是0号块 do { e = (sum &gt;&gt; 2) &amp; 3; for (p = n - 1; p &gt; 0; p--) // 反向循环 { z = v[p - 1]; // 因为是反着循环，所以这里是上一个块 y = v[p] -= MX; // 这里是也是取上一个和下一个块的值作为参数 } z = v[n - 1]; // 0号块的上一个块是n-1号块 y = v[0] -= MX; sum -= delta; } while (--rounds);}int main(){ uint32_t k[4] = {0x01234567, 0x89abcdef, 0xfedcba98, 0x76543210}; char v[] = &quot;Eleven11&quot;; xxteaEncrtpy((uint32_t *)v, strlen(v) / 4, k); for (int i = 0; i &lt; 8; i++) printf(&quot;%c&quot;, v[i] &amp; 0xFF); printf(&quot;\\n&quot;); xxteaDecrypt((uint32_t *)v, strlen(v) / 4, k); for (int i = 0; i &lt; 8; i++) printf(&quot;%c&quot;, v[i]); printf(&quot;\\n&quot;); return 0;} referenceXXTEA-wikipedia","link":"/ctf/%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86/XXTEA/"},{"title":"加密&amp;编码算法精读目录","text":"对称加密是逆向工程中重要的知识点，这部分笔记对常见的对称加密算法和一些编码算法进行了精读，力求完全剖析加密的具体流程和实现，而不是止步于特征判断 目录 RC4TEAXTEAXXTEADESTODO：普通AES白盒AESBASE64","link":"/ctf/%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%E7%B2%BE%E8%AF%BB%E7%9B%AE%E5%BD%95/"},{"title":"[GWCTF 2019]babyvm","text":"提示是vm题 打开修复下符号，确实是vm题进去修复下结构体，结构还是很明显的修完后基本知道在干什么了，直接去看text段，指令有五百多个byte，写个脚本解析 123456789101112131415161718192021222324252627282930313233343536373839404142434445i = 0f = open(&quot;output.txt&quot;, &quot;w&quot;, encoding=&quot;utf-8&quot;)cnt = 0while i &lt; len(text) and cnt &lt; 2: if text[i] == 0xF1: print(&quot;mov &quot;, end=&quot;&quot;, file=f) op = text[i+1] i += 2 num = text[i]+text[i+1]*256+text[i+2]*256*256+text[i+3]*256*256 if op == 0xE1: print(&quot;r0 = input[{}]&quot;.format(num), file=f) elif op == 0xE2: print(&quot;r1 = input[{}]&quot;.format(num), file=f) elif op == 0xE3: print(&quot;r2 = input[{}]&quot;.format(num), file=f) elif op == 0xE4: print(&quot;input[{}] = r0&quot;.format(num), file=f) elif op == 0xE5: print(&quot;r3 = input[{}]&quot;.format(num), file=f) elif op == 0xE7: print(&quot;input[{}] = r1&quot;.format(num), file=f) i += 4 elif text[i] == 0xF2: print(&quot;r0 ^= r1&quot;, file=f) i += 1 elif text[i] == 0xF5: print(&quot;readInput&quot;, file=f) i += 1 elif text[i] == 0xF4: print(&quot;rip++&quot;, file=f) i += 1 elif text[i] == 0xF7: print(&quot;r0 *= r3&quot;, file=f) i += 1 elif text[i] == 0xF8: print(&quot;swap r0 r3&quot;, file=f) i += 1 elif text[i] == 0xF6: print(&quot;r0 = r2 + 2*r1 + 3*r0&quot;, file=f) i += 1 elif text[i] == 0xF4: i += 1 cnt += 1 # print(i, hex(text[i]))f.close() 这题有个很恶心的地方，他text段有两段逻辑，并不是rip到0xF4就停止了，前一段是假flag，要用类似栈溢出的方法去第二段逻辑最后手动逆出真正的加密逻辑如下 123456789for i 1 ~ 5 input[i] ^= [i+1]input[6]=(input[8]+2*input[7]+3*input[6])*input[12]input[7]=(input[9]+2*input[8]+3*input[7])*input[12]input[8]=(input[10]+2*input[9]+3*input[8])*input[12]swap input[13] input[19]swap input[14] input[18]swap input[15] input[17] 直接逆即可注意到密文也是假的，真正的密文在一个没有交叉引用的函数里 12345678910111213141516171819202122sec = [0x69, 0x45, 0x2A, 0x37, 0x09, 0x17, 0xC5, 0x0B, 0x5C, 0x72, 0x33, 0x76, 0x33, 0x21, 0x74, 0x31, 0x5F, 0x33, 0x73, 0x72]for i in range(30, 127): if sec[8] == ((sec[10]+2*sec[9]+3*i)*sec[12]) &amp; 0xFF: sec[8] = i breakfor i in range(30, 127): if sec[7] == ((sec[9]+2*sec[8]+3*i)*sec[12]) &amp; 0xFF: sec[7] = i breakfor i in range(30, 127): if sec[6] == ((sec[8]+2*sec[7]+3*i)*sec[12]) &amp; 0xFF: sec[6] = i breaksec[15], sec[17] = sec[17], sec[15]sec[14], sec[18] = sec[18], sec[14]sec[13], sec[19] = sec[19], sec[13]for i in range(5, -1, -1): sec[i] ^= sec[i+1]for i in sec: print(hex(i), end=&quot; &quot;)","link":"/ctf/WP/buu/GWCTF%202019%20babyvm/"},{"title":"NPCCTF 2025 ezMobile","text":"进来主类里直接看到一个经典dex壳，这个壳是吧加密过的dex扔进native函数里解密，然后用InMemoryDexClassLoader动态加载我们直接hook这个change,拿到返回值后直接写进入文件获得dex 12345678910def onMessage(message, data): if message['type'] == 'send': print(&quot;[!!] Message from target: &quot;, message['payload']) for i in range(len(message['payload'])): if message['payload'][i] &lt; 0: message['payload'][i] += 256 with open(&quot;class.dex&quot;, &quot;wb&quot;) as f: f.write(bytes(message['payload'])) else: print(&quot;Not a send type Message&quot;, message['stack']) 123456let MainActivity = Java.use(&quot;ctf.myapplication.MainActivity&quot;);MainActivity[&quot;change&quot;].implementation = function (bArr) { let result = this[&quot;change&quot;](bArr); send(result) return result;}; 拿到dex后打开看加密就是一个xxtea加一个base64，base64检查过后发现就是默认表，xxtea魔改了MX和delta，所以手动写xxtea脚本，key是放在native里的，可以直接hook encrypt的参数获取 1FlagChecker.encrypt is called: data=qweery, key=882059e204adefc5 xxtea脚本如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#include &lt;bits/stdc++.h&gt;using namespace std;#define MX (((z &gt;&gt; 5) ^ (y &lt;&lt; 2)) + ((y &gt;&gt; 3) ^ (z &lt;&lt; 4))) ^ ((sum ^ y) + (k[(p &amp; 3) ^ e] ^ z))void xxteaEncrtpy(uint32_t *v, size_t n, uint32_t *k){ uint32_t y, z, sum; uint32_t p, rounds, e; uint32_t delta = -1640531527; rounds = 6 + 52 / n; sum = 0; z = v[n - 1]; do { sum += delta; e = (sum &gt;&gt; 2) &amp; 3; // 引入非线性计算，使得每次取出的key值缺少规律 for (p = 0; p &lt; n - 1; p++) { y = v[p + 1]; z = v[p] += MX; // 每个块加密是增加的偏移量实际上由上一个块(z)和下一个块(y)的值和sum共同决定 } y = v[0]; // 此处其实是循环加密的端点，当然可以对下标取模写进循环里 z = v[n - 1] += MX; } while (--rounds); // 实际上是把相同的操作重复round轮}void xxteaDecrypt(uint32_t *v, size_t n, uint32_t *k){ uint32_t y, z, sum; uint32_t p, rounds, e; uint32_t delta = -1640531527; rounds = 6 + 52 / n; sum = rounds * delta; y = v[0]; // n-1号块的下一个块是0号块 do { e = (sum &gt;&gt; 2) &amp; 3; for (p = n - 1; p &gt; 0; p--) // 反向循环 { z = v[p - 1]; // 因为是反着循环，所以这里是上一个块 y = v[p] -= MX; // 这里是也是取上一个和下一个块的值作为参数 } z = v[n - 1]; // 0号块的上一个块是n-1号块 y = v[0] -= MX; sum -= delta; } while (--rounds);}int main(){ // 882059e204adefc5 char k[] = &quot;882059e204adefc5&quot;; // uint32_t k[4] = {0x01234567, 0x89abcdef, 0xfedcba98, 0x76543210}; unsigned char v[] = {0x61, 0x80, 0x8a, 0x2d, 0x69, 0x52, 0x27, 0xdc, 0x78, 0x95, 0x85, 0x66, 0xee, 0x2a, 0xa5, 0x1e, 0xdf, 0xc4, 0x5e, 0xf8, 0x1a, 0x84, 0x4a, 0x0a, 0x11, 0xed, 0x9d, 0x97, 0x40, 0x67, 0x46, 0x61, 0xa1, 0x35, 0x0f, 0x4a, 0x84, 0xf5, 0xd8, 0x79, 0xfd, 0xc4, 0xa9, 0xb8}; xxteaDecrypt((uint32_t *)v, 11, (uint32_t *)k); for (int i = 0; i &lt; 44; i++) printf(&quot;%c&quot;, v[i]); printf(&quot;\\n&quot;); return 0;} flag{AnDr01d_r3v3rs3_jUcYuWzBSSOwKxbMD}","link":"/ctf/WP/NPCCTF%202025%20ezMobile/"}],"tags":[{"name":"Reverse","slug":"Reverse","link":"/tags/Reverse/"},{"name":"Andorid","slug":"Andorid","link":"/tags/Andorid/"},{"name":"Python","slug":"Python","link":"/tags/Python/"},{"name":"selenium","slug":"selenium","link":"/tags/selenium/"},{"name":"codeforces","slug":"codeforces","link":"/tags/codeforces/"},{"name":"加密&amp;编码","slug":"加密-编码","link":"/tags/%E5%8A%A0%E5%AF%86-%E7%BC%96%E7%A0%81/"}],"categories":[{"name":"Reverse","slug":"Reverse","link":"/categories/Reverse/"},{"name":"Development","slug":"Development","link":"/categories/Development/"},{"name":"basic","slug":"Reverse/basic","link":"/categories/Reverse/basic/"},{"name":"杂项","slug":"杂项","link":"/categories/%E6%9D%82%E9%A1%B9/"},{"name":"LLVM","slug":"Reverse/LLVM","link":"/categories/Reverse/LLVM/"},{"name":"ctf-test","slug":"Reverse/ctf-test","link":"/categories/Reverse/ctf-test/"},{"name":"对称加密&amp;编码","slug":"Reverse/对称加密-编码","link":"/categories/Reverse/%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86-%E7%BC%96%E7%A0%81/"},{"name":"Andorid","slug":"Reverse/Andorid","link":"/categories/Reverse/Andorid/"}],"pages":[]}