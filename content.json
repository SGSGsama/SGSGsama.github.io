{"posts":[{"title":"bn脚本笔记","text":"由于BinaryNinja脚本的官方文档完全就是把api按字典序堆在一起，故开一篇随笔存一些常见api的使用方法，随机更新中 笔记中所有的bv均为BinaryView类，即与bn交互的主要接口 bv.instructions返回当前二进制文件的所有指令，返回形式为元组组成的列表，元组的第一个元素为该指令的Token按空格切片形成的列表，第二个元素为指令地址这个token有很多附加的属性(或者说解释的方式，比如token.text就是返回文本,token.value就是把token按数值转换为int (假设这个token是数值))，不只是单纯的text，在简单输出时体现为text 12for instruction in bv.instructions: print(instruction) bv.linear_disassembly和 bv.instructions 很像，但是这个真就是直接把指令文本一条条打出来，返回的是一个迭代器 get_disassembly(addr: int)返回目标地址指令的文本(str) bv.get_instruction_length(addr : int)返回目标地址指令的长度 1234for instruction in bv.instructions: if instruction[0][0].text == 'jz' or instruction[0][0].text == 'jnz': print(instruction[0][0]) print(&quot;len = &quot;, bv.get_instruction_lengt(instruction[1])) bv.write(addr : int ,data : bytes)直接往目标地址覆写一段数据，patch的主要手段 bv.read(addr : int ,length : int)读取以目标地址为起点一定长度的数据，返回字节流(bytes)","link":"/ctf/BinaryNinjaScript/"},{"title":"反调试笔记","text":"反调试是逆向工程中的常见对抗手段，这篇笔记总结了一些各种平台常见的调试检测手段，随机更新中 IsDebuggerPresent()特征最明显的反调试，因为是windows系统api所以也没法隐藏，直接读NtCurrentPeb上的beingdebugged标志，如果被调试就返回1 *(NtCurrentPeb+0x2) ( beingdebugged Flag )是上面这条的变体，实际上beingdebugged标志就在NtCurrentPeb+0x2的位置上 *(NtCurrentPeb+0x68) ( NtGlobalFlag )当进程被调试器启动时这个标志会被设置为0x70 (实际上是三个堆相关的标志被设置为111) NtCurrentPeb()-&gt;ProcessParameters-&gt;DebugFlags进程启动参数，这个标志为1时说明在被调试 NtCurrentPeb()-&gt;ProcessParameters-&gt;DebugPort调试对象的句柄，如果这个值不为NULL说明有对象在调试该进程 NtCurrentPeb()-&gt;ProcessHeap这个位置有两个标志Flags和ForceFlags用于告诉内核这个堆是否是在调试器中被创建的，正常情况下Flag=2,ForceFlags=032位windows中 Flags位于ProcessHeap+0xC ,ForceFlags位于ProcessHeap+0x1064位windows中 Flags位于ProcessHeap+0x70 ,ForceFlags位于ProcessHeap+0x74 OutputDebugString()这个函数会向调试器中输出一段字符串，如果当前程序没有被调试就会更新当前程序的错误码可以配合SetLastError先将错误码设置为一个预设值，然后调用该函数更新错误码，再用GetLastError获取新的错误码，如果新的错误码和旧的一样说明这个函数没有报错，就说明调试器存在 ZwSetInformationThread(ThreadHideFromDebugger)这个函数可以设置当前线程的一些信息，主要是优先级之类的，他的参数是一个枚举类，其中ThreadHideFromDebugger这个选项会把当前线程从调试器中抹掉，具体实现就是把DebugPort置为NULL(疑似有点草台) 扫描0xCC (int 3 指令)软件断点的工作原理是将断点位置的指令替换为 int 3 指令(编码为0xCC)，当调试器遇到 int 3 时就调用调试异常中断执行在程序执行时扫描全程序是否有0xCC就可以检测到是否存在软件断点该方法无法检测硬件断点，因为硬件断点并不修改程序指令注意到软件断点需要修改指令，所以烧录在rom中的程序无法下软件断点 PS1. 硬件断点硬件断点是用寄存器实现的断点，直接在调试寄存器中保存断点的地址，当PC跑到对应位置时中断执行，断点的数量受限于调试寄存器的数量 GetThreadContext(hThread,lpContext)这个函数可以获取对应线程的上下文信息，如果lpContext中读取的DRx系列寄存器(调试寄存器)的值不为0说明存在硬件断点，可以据此检测硬件断点 哈希校验直接计算整个程序机器码的哈希值，与正常情况下的预设值进行校验，因为软件断点会插入int 3，所以调试状态下哈希值会有不同 rdstcrdstc 可以获取cpu开机起经历的时钟周期，调用两次该函数就可以获取一段操作经历的时间，如果时间过长可以猜测存在调试器，因为调试器会极大影响程序性能 父进程检测一般正常用户态运行的程序只可能是由几个系统服务或者已知的程序启动的(cmd,explorer.exe…..)，可以通过th32ParentProcessID获取父进程的PID，在与系统中所有进程的PID进行比对，如果父进程不在上述的范围内则可以推断进程在被调试 基于VEH，SEH的反调试这个反调试其实还是利用了上述反调试的逻辑，只不过把检测的代码藏在异常处理的逻辑里，然后再手动触发一个异常来进入这段逻辑，一般直接搜索VEH就可以搜到设置veh的地方，进而找到用户自定义的handler,SEH可以去反汇编软件中寻找except包裹的部分。因为异常处理逻辑通常要跳过垃圾代码，所以这种异常通常不会选择传递给调试器(就算传给调试器调试器也会卡在垃圾代码里)，所以也可能会把一些加密的逻辑藏在异常处理中(说白了还是增加翻代码的难度，并没有什么新鲜的) SetUnhandledExceptionFilterSetUnhandledExceptionFilter()函数接受一个winapi的异常过滤器函数作为参数用来设置自定义的异常过滤器，当正常运行时，windows让异常过滤器先接管未处理的异常，此时过滤器内可以做加密相关的操作，也可以做处理异常的操作，但是调试模式下所有的异常就会传递给调试器(现代调试器已经有选择由app处理异常的选项)，此时我们又没有写处理异常的逻辑，调试器就会直接卡住 123456SetUnhandledExceptionFilter(CustomUnhandledExceptionFilter);__try{ int* p = NULL; *p = 1; }//没有 except","link":"/ctf/%E5%8F%8D%E8%B0%83%E8%AF%95/"},{"title":"kotlin备忘录速记","text":"记录一些速查的kotlin高频函数和API，省的太久不写忘了 定义约定常量1val Name : Type = initVal 变量var Name : Type = initVal 函数123(override... 修饰符) fun Name (para:paraType = deafultVal) : return Type{ } 可为null123456789val Name : Type? = initVal/null// 如果显式设置了类型,只有类型名后加?才可设为nullName!!.member // !!后缀表示断言该量一定不为null // 条件表达式也可以智能推断是否为null //val Name : Type = null?:deafultVal// ?:是 Elvis运算符，当运算符左侧的值为null时返回运算符右侧设置的默认值 类1234567891011// 主构造函数，参数前加val/var则无需在类主体中再次定义该成员// open说明该类可被继承// 父类的构造函数的调用接在主构造函数后// 实现的接口接在父构造函数后，用逗号链接(open) class Name(val member:Type,...) : FatherClassConstructor(para),interface{ val member = initVal get() set() // get,set为内置关键字，可选，紧跟在对应成员后 constructor(para):this(para)//重载构造函数，如果需要给主构造函数补参数} 修饰符123456class ClassName(){ public val member1 // 默认修饰符，可以任意访问 private val member2 // 仅可在类内部访问 protected val member3 // 只能被子类访问 internal val member4 // 只能在同一文件中被访问} 定义委托123var Name by delegateObject// 把变量的getter和setter委托给自定义类(即重载变量的getter和setter)// 委托类需实现ReadWriteProperty&lt;Any?, Type&gt;或ReadOnlyProperty&lt;Any?&gt;接口 储存函数1234567fun myFunc(){ ...}fun main(){ val FunctionVal = ::myFunc // 将函数作为变量存储须在函数名前加::} lambda1234567891011121314val Name:(paraType) -&gt; returnType = { para -&gt; body// 后置lambda语法// myFunc(Int,Int,(Int,Int)-&gt;Int)// 当函数的最后一个参数是lambda时可以在调用函数时直接把lambda写在调用后面myFunc(1,2){ x,y -&gt; x+y}}val 函数数据类型约定1(paraType1,ParaType2...) -&gt; returnType 泛型(模板类)约定12345class tempClass&lt;T&gt;(val para:Type,val tempPara:T){}val Name = tempClass&lt;Int&gt;(para1,2) 枚举类约定1234567enum class Name{ enumName1,enumName2}val enumNum:Name = Name.enumName1 数据类约定1234data class Name(val value1:Type,val value2:Type...){}//专用于处理数据的类，没有任何执行操作的方法//编译器会自动实现equals()，hashCode()，toString()，componentN()：component1()、component2() ... ，copy()这些方法 单例对象约定123object Name{}和类相同，但是全局只存在一个实例，且无须自己创建，必须在定义时就初始化 定义拓展属性12345678val typeName.extendPropertyName : dataTypeget()//为拓展属性设置getterfun typeName.extendFunctionName(para...) : returnType{}//拓展属性只能读取不能写入 接口12345interface InterfaceName{ val member:Type fun function(para):return Type //接口只声明不实现，继承接口的类必须实现接口声明的所有内容(override)} 分支约定if-else123456if(condition){}else{} when123456when(para){ condition1 -&gt; {body1} condition2 -&gt; {body2} .....} 特殊约定分支，lambda返回值分支,lambda的最后一个表达式的值会作为整个结构的返回值 123456789x= if(true){ &quot;1&quot;}else{ &quot;0&quot;}// x=&quot;1&quot;x={2} // x=2 字符串中嵌入表达式1&quot;x= ${x.value}&quot; 使用${}向字符串嵌入表达式 帮手函数repeat(times: Int, action: (Int) -&gt; Unit)重复执行某一操作，传入一个lambda，有一个从0开始的迭代器参数 12345678repeat(5){ it -&gt; println(it)}// 0// 1// 2// 3// 4 let()1234567891011//before letprintln(Obj.member1)println(Obj.member2)println(Obj.member3)// after letObj.let{ println(it.member1) println(it.member2) println(it.member3)} let后接一个lambda函数，可以把let前的对象用it关键字简写lambda 最后一条语句的返回值会被作为let的返回值 apply()1234567891011Obj.apply{ this.member= .... this.initFunc()}// tips : 可以实现链式调用Obj.apply{ member1 = ...}.apply{ member2 = ...}..... 对目标对象做一系列操作，通过this访问目标对象，返回操作完的目标对象 forEach(action: (T) -&gt; Unit)forEach传入一个lambda，对目标集(List,set…)中的每一个元素执行该lambda 12345val test1=setOf(1,2,3,4,5) test1.forEach{ println(it) }// 1,2,3,4,5 map对一个集合使用map，会返回一个数量相同的新集合，集合中的每个元素是原集合对应元素经过map中传入的lambda函数映射后所产生的 1234567var aList=listOf(1,2,3,4,5,6,7,8)var aAnotherList=aList.map{ it*2}fun main() { println(aAnotherList) // [2, 4, 6, 8, 10, 12, 14, 16]} filter与map类似返回一个新集合，filter接受一个lambda，这个lambda以集合中的单个元素为参数，如果lambda返回值为true则在新集合中保留该元素，否则不保留 1234567var aList=listOf(1,2,3,4,5,6,7,8)var aAnotherList=aList.filter{ it%2==0}fun main() { println(aAnotherList) // [2, 4, 6, 8]} fold()累加器或叫求和函数，但并不局限于加法，这个函数的第一个参数是一个初始值，第二个参数是一个lambda表达式需要确保lambda表达式的返回值和初始值的类型相同，lambda表达式接受两个参数，第一个参数被称作累加器，每次执行lambda初始值会被传进累加器，第二个参数是集合中的一个元素，用户可以自定义集合中的元素和累加器进行什么计算，最后fold会用lambda的返回值更新初始值，实现求和 1234567891011var aList=listOf(1,2,3,4,5,6,7,8,9,10)var sum=aList.fold(0){ tot,cur-&gt; val tmp=cur*2 tot+tmp}fun main() { println(aList) // [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] println(sum) // 110} sortedBy()返回一个集合经过排序的结果，接受一个lambda作为参数，要求lambda的返回值是可排序的（字符串或数值），会把每个元素在lambda中计算出的返回值作为排序的依据 123456789var aList=listOf(1,2,3,4,5,6,7,8,9,10)var reversedList=aList.sortedBy{ num -&gt; -num}fun main() { println(aList) // [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] println(reversedList) // [10, 9, 8, 7, 6, 5, 4, 3, 2, 1]} 数据管理数组 array123val array = arrayOf&lt;Type&gt;(elem1,elem2,....) // 使用arrayOf初始化，单一类型，长度不可变println(array[0]) // 使用下标访问val arrry12 = array1+array2 //拼接两个数组 列表(可变长数组) list1234567891011121314val aList=listOf(1,2,true,&quot;123&quot;) // 使用listOf初始化，可以混合类型，不可修改元素，不可增减元素println(aList.size) // 查询长度println(aList[0]) // 下标访问println(aList.indexOf(&quot;123)) // 3 ,若未找到返回-1for (elem in aList) { // 使用 for 遍历}anotherList=mutableListOf(1,2,true,&quot;123&quot;) // 可修改的列表anotherList.add(&quot;4&quot;) // [1,2,true,&quot;123&quot;,&quot;4&quot;] //向末尾添加元素anotherList.add(2,&quot;4&quot;) // [1,2,&quot;4&quot;,true,&quot;123&quot;,&quot;4&quot;] // 向中间插入anotherList.removeAt(0) // [2,&quot;4&quot;,true,&quot;123&quot;,&quot;4&quot;] // 按下标删除anotherList.remove(&quot;123&quot;) // [2,&quot;4&quot;,true,&quot;4&quot;] // 按值删除anotherList.contains(2) //查询是否存在2 in anotherList // 前者的另一写法 集合 setSet / mutableSet 同样 不可修/可修 123val aSet=mutableSetOf(&quot;123&quot;,true,32)// 有add，remove，contain，size，没有下标操作// 基于每个类的hashCode()实现 映射 mapMap / mutableMap 同样 不可修/可修 1234567val aMap=mutableMapOf( &quot;cake&quot; to 10, &quot;cookie&quot; to 5, true to 22)println(aMap[&quot;cake&quot;]) // 10 通过key访问value，不存在的key会返回null// 有size属性 Referencehttps://developer.android.com/courses/android-basics-compose/course","link":"/development/kotlin_beginer/"},{"title":"selenium爬虫入门","text":"记录一下写的一个简单爬虫 简介selenium是基于浏览器DevTool模拟用户态行为的爬虫框架，与传统爬虫相比selenium最大的优点就是可以通过模拟行为绕过大部分的反爬，同时因为其本身基于浏览器，在对抗加密方面有天然的优势 常用APIwebDriver.Chrome.Options() : Option返回一个 option 对象，用于在之后为浏览器提供选项参数，最常见的用法如下 12options = webdriver.ChromeOptions()options.add_argument(&quot;disable-blink-features=AutomationControlled&quot;) 这段代码为option添加了一个参数将浏览器的 webdriver 属性置为false，该属性常用于检测浏览器是否处于调试模式，常见的反爬会检测该属性，该属性为true则会触发反爬此外还可以添加包括但不限于下列的属性，但用处都不大 123--disable-gpu # 禁用gpu加速--headless # 将浏览器设置为无头浏览器--windows-size=1920,1080 #设置浏览器窗口大小 webdriver.Chrome(options : Option ) : WebDriver创建一个浏览器对象，所有与浏览器的交互都会通过这个对象进行 1driver = webdriver.Chrome(options=options) driver.get(url : str ) : void打开一个页面 driver.find_element(by: str , value : str ) : WebElement在webdriver目前聚焦的页面中寻找对应html元素，并返回一个可以对找到的元素进行交互的对象， by 是 selenium.webdriver.common.by 中的枚举类， value 是搜索对应的值或表达式，这里只介绍 By.CSS_SELECTOR 和 By.LINK_TEXT，个人认为算是最通用的方法。这个方法只返回找到的第一个元素，且找不到则抛出错误，另一个类似的方法是 driver.find_elements 返回所有找到的元素，如果找不到就返回空列表 By.CSS_SELECTOR 利用CSS选择器查找元素，value 应为一个CSS选择器表达式下面是一些示例 12345678910111213value = &quot;div&quot; # 单独的名字表示筛选特定tag的元素value = &quot;.targetClass&quot; # class名前带.表示筛选带特定类的元素value = &quot;#ID&quot; # ID前带#表示筛选含特定id的元素value = &quot;[attribute]&quot; # 筛选带具备特定属性的元素value = '[attribute=&quot;value&quot;]' # 筛选带特定属性且属性值为value的元素，其中&quot;&quot;不可省略和替换value = &quot;div.targetClass#ID&quot; # 选择含多个条件的元素则将所有条件不加空格地组合在一起value = &quot;div#fatherDiv div#sonDiv&quot; # 如果要选择某个元素的后代元素则将两个元素的筛选条件以空格隔开value = &quot;div#faterDiv &gt; div#directSonDiv&quot; # 如果要选择直属于某个元素的子元素则在两个元素的筛选条件之间额外加入 &gt;value = &quot;:not()&quot; # 选择不符合特定条件的元素，()中可以嵌套另一个CSS选择器表达式 # 比如 &quot;div:not(.disabled)&quot; ,选择不为disable类的div元素 By.LINK_TEXT 筛选文本为 value 的&lt;a&gt;元素即超链接元素，执行严格匹配，另一个类似的方法是 By.PARTIAL_LINK_TEXT，只需提供的 value 是目标的子串就行，此方法用于快捷定位特定超链接对应的元素，方便爬虫在页面间进行跳转 1Page = driver.find_element(by=By.LINK_TEXT, value=&quot;下一页&quot;) # 这样我们就定位到了一个翻页按钮，可以用click之类的方法让我们的爬虫翻页 ActionChains(driver : WebDriver ) : ActionChains这是selenium提供的动作链类，用于模拟用户的操作输入 1234567actions = ActionChains(driver) # 指定所属的webdriver，还可以指定duration属性来控制每次操作的时间，用来绕过针对仿真行为的反爬actions.key_down(Keys.CONTROL).click( Page).key_up(Keys.CONTROL).perform() # 这个操作就模拟了ctrl+左键，即在新页面打开对应链接 # 使用连续调用来设计动作链，最后调用perform()执行 # click之类的要指定具体点击的webElement，否则点击鼠标指针所在位置 # 按键类的动作可以用selenium.webdriver.common.keys中的Keys枚举类来模拟按下ctrl之类的功能键，其他按键直接输入对应字符即可 driver.switch_to.window(window_name : str ) : void将浏览器的焦点切换至另一个页面，其中 window_name 可以通过 driver.window_handles 获取，这是webdriver类的一个列表成员，储存了当前浏览器所有窗口的 window_name 12driver.switch_to.window(driver.window_handles[-1]) # 切换至最右边的窗口，事实上这个列表里句柄的排列顺序是按窗口打开顺序排列的 driver.close() : void当一个页面的数据爬完了可能要关闭该页面，用close方法就能把当前页面关掉，但是注意driver并 不会自动切换聚焦到新窗口 ，所以close后要调用switch_to.window把焦点转移到新窗口 driver.quit() : void直接关闭浏览器 项目实战项目地址 =&gt; 基于selenium框架爬取avd.aliyun.com上的漏洞报告 阿里云的漏洞网站用了很恶心的加密算法，把本机的时间戳套了一堆加密做成token放进payload里做验证，如果验证不通过就无法进入漏洞库和漏洞报告，我们直接上selenium，只要我们全程模拟用户态行为就不用管加密，这点和逆向工程中的动态调试非常像，本质上是利用了应用自加密/自解密的性质 下面直接上代码 12345678#utility.pydef init_driver(url: str): options = webdriver.ChromeOptions() options.add_argument(&quot;disable-blink-features=AutomationControlled&quot;) driver = webdriver.Chrome(options=options) driver.get(url) return driver 他的加密算法会在加载时就读取 webdriver 标记的值，并且这个参数会被用于加密过程，如果是undefined或者true加密跑出来就是错的，而且非常恶心的是他并不直接从 navigator.webdriver 实时读取，而是加载时检测到 webdriver 不为false就让加密胡乱输出，所以我们加一个参数在网页加载前就把 webdriver 标记设置成false 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#Crawler.pydef runCrawler(catalog: str, number: int = 0, debug: bool = 0, sleepSecond: float = 1): ''' sleepSecond为每跳转一个页面的等待时长，过短可能会触发限流或反爬\\n 如果cve的命名不符合windows文件命名规范则会转换为url命名输出\\n catalog为要爬取的漏洞库的按钮文本{&quot;CVE 漏洞库&quot;,&quot;非CVE漏洞库&quot;,&quot;高危漏洞&quot;}\\n number为爬取的记录数量，若不指定则在调用函数时提示输入 ''' driver = init_driver(&quot;https://avd.aliyun.com/&quot;) Page = driver.find_element(by=By.LINK_TEXT, value=catalog) if debug: print(&quot;in &quot;+driver.title+&quot; at &quot;+driver.current_url) # input(&quot;continue&quot;) actions = ActionChains(driver) actions.key_down(Keys.CONTROL).click( Page).key_up(Keys.CONTROL).perform() # 进入漏洞库列表 sleep(sleepSecond*1.5) # 等待加载 if debug: print(&quot;sleep finished&quot;) driver.switch_to.window(driver.window_handles[-1]) # 切换至漏洞库窗口 links = driver.find_elements(By.TAG_NAME, &quot;a&quot;) # print(len(links)) if debug: # print(driver.window_handles) print(&quot;in &quot;+driver.title+&quot; at &quot;+driver.current_url) # input(&quot;continue&quot;) total = driver.find_element( by=By.CSS_SELECTOR, value=&quot;div.py-3.bg-light &gt; div.container.vuln-list-container &gt; div.py-3 &gt; div.d-flex.justify-content-between.align-items-center &gt; span.text-muted&quot;).text if debug: print(total[total.find(&quot;总计 &quot;)+3: total.find(&quot; 条记录&quot;)]) total = int(total[total.find(&quot;总计 &quot;)+3: total.find(&quot; 条记录&quot;)]) print(&quot;正在爬取 {}&quot;.format(catalog)) toDo = number if toDo == 0: toDo = int(input(&quot;输入要爬取的记录条数，范围为 &lt;={}\\n&quot;.format(total))) hasNextPage = 1 cnt = 0 while hasNextPage and cnt &lt; toDo: if debug: print(&quot;in&quot;+driver.current_url) for link in links: # 遍历所有超链接 if &quot;detail&quot; in link.get_attribute(&quot;href&quot;): link.click() # 进入cve sleep(sleepSecond) driver.switch_to.window( driver.window_handles[-1]) # 切换至新窗口 button = driver.find_elements( by=By.CSS_SELECTOR, value=&quot;.btn.btn-link.text-muted&quot;) if len(button): button[0].click() genRawDoc(driver, debug) cnt += 1 print(&quot;进度 {} / {}&quot;.format(cnt, toDo)) if debug: print(&quot;in &quot;+driver.title+&quot; at &quot;+driver.current_url) input(&quot;continue&quot;) driver.close() # input(&quot;closed&quot;) driver.switch_to.window(driver.window_handles[-1]) if debug: print(&quot;in &quot;+driver.title+&quot; at &quot;+driver.current_url) # input(&quot;continue&quot;) if cnt == toDo: break nextPageButton = driver.find_elements( by=By.CSS_SELECTOR, value=&quot;.px-3.btn.btn-sm.btn-outline-secondary.btn-bd-primary:not(.disabled)&quot;) if debug: print(len(nextPageButton)) hasNextPage = 0 for button in nextPageButton: if &quot;下一页&quot; in button.text: actions.key_down(Keys.CONTROL).click( button).key_up(Keys.CONTROL).perform() # driver.close() sleep(sleepSecond) driver.close() driver.switch_to.window(driver.window_handles[-1]) hasNextPage = 1 break driver.quit() 这段非常长，因为爬虫定位元素基本靠手工定位，有大量重复代码，我们看关键的部分 12345driver = init_driver(&quot;https://avd.aliyun.com/&quot;)Page = driver.find_element(by=By.LINK_TEXT, value=catalog)actions = ActionChains(driver)actions.key_down(Keys.CONTROL).click(Page).key_up(Keys.CONTROL).perform() # 进入漏洞库列表sleep(sleepSecond*1.5) # 等待加载 这里我们打开网站，然后网站首页有三个链接分别跳进不同分类的漏洞库，我们直接用文本定位然后在新页面打开，并且等待加载，这里不直接点击在原地跳转的原因是不知道为什么原地跳转会导致加密算法输出不正确，然后等待加载也很重要，如果不等页面完全加载完就跳转也会让加密算法输出不正确，尚不清楚原因 12driver.switch_to.window(driver.window_handles[-1]) # 切换至漏洞库窗links = driver.find_elements(By.TAG_NAME, &quot;a&quot;) 这段就是把这个页面里所有的超链接元素都抓下来 123total = driver.find_element( by=By.CSS_SELECTOR, value=&quot;div.py-3.bg-light &gt; div.container.vuln-list-container &gt; div.py-3 &gt; div.d-flex.justify-content-between.align-items-center &gt; span.text-muted&quot;).texttotal = int(total[total.find(&quot;总计 &quot;)+3: total.find(&quot; 条记录&quot;)]) 这段是找下总共有多少条记录，不是很重要 1234567891011121314151617while hasNextPage and cnt &lt; toDo: #.... nextPageButton = driver.find_elements( by=By.CSS_SELECTOR, value=&quot;.px-3.btn.btn-sm.btn-outline-secondary.btn-bd-primary:not(.disabled)&quot;) if debug: print(len(nextPageButton)) hasNextPage = 0 for button in nextPageButton: if &quot;下一页&quot; in button.text: actions.key_down(Keys.CONTROL).click( button).key_up(Keys.CONTROL).perform() # driver.close() sleep(sleepSecond) driver.close() #关闭当前页 driver.switch_to.window(driver.window_handles[-1]) #前往下一页 hasNextPage = 1 break 因为记录有很多页，我们要一页一页爬，先找到翻页按钮，然后发现能按和不能按的按钮有一个.disable类的区别，我们就一直翻直到”下一页”变成disable为止然后每次点开一个新的就把老的关了 123456789101112131415161718192021222324for link in links: # 遍历所有超链接 if &quot;detail&quot; in link.get_attribute(&quot;href&quot;): link.click() # 进入cve sleep(sleepSecond) driver.switch_to.window( driver.window_handles[-1]) # 切换至新窗口 button = driver.find_elements( by=By.CSS_SELECTOR, value=&quot;.btn.btn-link.text-muted&quot;) if len(button): button[0].click() genRawDoc(driver, debug) cnt += 1 print(&quot;进度 {} / {}&quot;.format(cnt, toDo)) if debug: print(&quot;in &quot;+driver.title+&quot; at &quot;+driver.current_url) input(&quot;continue&quot;) driver.close() # input(&quot;closed&quot;) driver.switch_to.window(driver.window_handles[-1]) if debug: print(&quot;in &quot;+driver.title+&quot; at &quot;+driver.current_url) # input(&quot;continue&quot;) if cnt == toDo: break 页面里有一堆超链接，我们肯定不能每个都跳进去，发现漏洞详情的超链接里有detail关键字，我们就只找含这个关键字的跳，也是点开，转移焦点，爬数据，关闭，把焦点切回来，同样注意每次等待一会，可以防止访问量过大导致限流或者直接被封ip然后跳进去后发现参考链接如果数量过多会只显示部分，要先点一下 .btn.btn-link.text-muted 的按钮把所有东西都展开genRawDoc里的内容就没什么营养了，目前已经进入具体报告界面，直接定位对应内容，保存下来写入文件就行","link":"/development/selenium0x1/"},{"title":"花指令笔记","text":"花指令是逆向工程中常见的对抗手法，这篇笔记整理了一些常见的花指令样本供参考，随机更新中 基于call-return修改rip的花指令call指令是一种复合指令，它会在跳转至目标地址前将下一条指令对应的地址压栈，然后在return是弹栈恢复rip，如果在return前修改栈上的数据，就可以达到修改rip的效果这是一个经典的样本，通过call跳转后把esp(栈顶)对应的值加上一定偏移，经过计算可以知道return后rip会被修改为0x413A6A+0x8=0x413A72，也就是说从0x413A65到0x413A71的这一段都是垃圾数据所以直接nop这一段可以看到nop完后线性扫描自动分析出了下面的代码 基于jz,jnz的花指令利用两个连续的jz,jnz指令可以构造出必定执行的跳转，然后中间塞垃圾数据，但是静态分析工具无法分析这种跳转，而且线性扫描扫到垃圾数据反汇编就直接炸了，修复方式也很简单，直接吧jz/jnz到跳转地址前的所有指令nop掉就行了，因为肯定不会执行到 基于 xor,cmp,jz的花指令同样是构造必定执行的跳转，以下是一种示例先保存ebx寄存器，然后把ebx寄存器置0，这样jz就必然执行，跳过垃圾数据后再恢复ebx的值 如何编写花指令编写花指令可以通过内联汇编的形式，以下是一种示例(g++) 123456789#include &lt;iostream&gt;int main(){ asm volatile(&quot;jz lable1\\n\\t&quot; &quot;jnz lable1\\n\\t&quot; &quot;.byte 0xE8, 0x23,0x24,0x25,0x26,0x27,0x28\\n\\t&quot; &quot;lable1:\\n\\t&quot;); std::cout &lt;&lt; &quot;test&quot;;} 其中 volatile 参数可以防止编译器把花指令优化掉同时在编译时要加上-fno-asynchronous-unwind-tables-fno-exceptions-fno-rtti等编译参数去除调试信息，否则反编译工具可以借助这些信息提供的控制流信息绕过花指令","link":"/ctf/%E8%8A%B1%E6%8C%87%E4%BB%A4/"},{"title":"腾讯游戏安全大赛2023安卓初赛","text":"不算非常难的题，但是对于没有app逆向经验的新人来说是挺好的上手题目 dump libli2cpp.so进来先随便看看，unity题先看看c#的东西，il2cpp被加密过，ida里解析不出来，考虑运行时dump直接用frida读，注意到对frida默认的端口做了检测，所以要转发到别的端口上 1234567891011121314151617181920212223242526272829/*如何使用设置一个倒计时后dump指定的so文件，timeout单位是ms，默认为3000ms*/function dump(soName: string, timeout: number = 3000) { setTimeout(() =&gt; { let libSo = Process.getModuleByName(soName); let base = libSo.base; let size = libSo.size; let sectionRanges = libSo.enumerateRanges(&quot;&quot;); for (let i = 0; i &lt; sectionRanges.length; i++) { console.log(sectionRanges[i].base.sub(base), sectionRanges[i].size, sectionRanges[i].base.add(sectionRanges[i].size).sub(base), sectionRanges[i].protection); Memory.protect(sectionRanges[i].base, sectionRanges[i].size, 'rwx'); let buffer = sectionRanges[i].base.readByteArray(sectionRanges[i].size); console.log(`write ${sectionRanges[i].size} bytes sections`); send([&quot;dumpso&quot;, soName], buffer); if (i + 1 &lt; sectionRanges.length &amp;&amp; sectionRanges[i].base.add(sectionRanges[i].size).compare(sectionRanges[i + 1].base) !== 0) { let gap = Memory.alloc(sectionRanges[i + 1].base.sub(sectionRanges[i].base.add(sectionRanges[i].size)).toUInt32()); let buffer = gap.readByteArray(sectionRanges[i + 1].base.sub(sectionRanges[i].base.add(sectionRanges[i].size)).toUInt32()); console.log(`write ${sectionRanges[i + 1].base.sub(sectionRanges[i].base.add(sectionRanges[i].size)).toUInt32()} bytes gap`); send([&quot;dumpso&quot;, soName], buffer); } } console.log(&quot;base: &quot;, base); console.log(&quot;size: &quot;, size); console.log(&quot;base + size: &quot;, base.add(size)); }, timeout);}dump(&quot;libil2cpp.so&quot;); 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354import fridaimport sysimport timedef handleResigerNatives(message): print(&quot;----------------------------------------&quot;) print(&quot;Native Method in class: {}&quot;.format(message['payload'][1])) print(&quot;Native Method name: {}&quot;.format(message['payload'][2])) print(&quot;Native Method signature: {}&quot;.format(message['payload'][3])) print(&quot;Native Method address: {}&quot;.format(message['payload'][4])) print(&quot;Which file register It: {}&quot;.format(message['payload'][5]))def handleDumpSo(message, data): with open(&quot;dump_&quot;+message['payload'][1], &quot;ab&quot;) as f: f.write(data)def onMessage(message, data): if message['type'] == 'send': if message['payload'][0] == &quot;registerNatives&quot;: handleResigerNatives(message) elif message['payload'][0] == &quot;dumpso&quot;: handleDumpSo(message, data) else: print(&quot;[!!] Message from target: &quot;, message['payload']) else: print(&quot;Not a send type Message&quot;, message['stack'])with open('dumpso.js', &quot;r&quot;, encoding=&quot;utf-8&quot;) as f: jscode = f.read()targetProcessPackName = &quot;com.com.sec2023.rocketmouse.mouse&quot;device = frida.get_device_manager().add_remote_device(&quot;127.0.0.1:12345&quot;)try: pid = device.spawn(targetProcessPackName) session = device.attach(pid) print(pid)except frida.ProcessNotFoundError: print(&quot;No such process&quot;) sys.exit(0)# device.resume(pid)# input(&quot;continue&quot;)script = session.create_script(jscode)script.on('message', onMessage)script.load()device.resume(pid)sys.stdin.read() 这样so基本都出来了，再结合ll2cppDumper和apk里找到的global-metadata修复一下c#符号信息但是因为是dump的，所以偏移和节符号之类的多少有些损坏，这样直接扔进ida里是无法识别的，所以要修复elf，如果手动修的话就是把so扔进010里先跑一遍elf模板识别关键字段，然后把progame_table段里的物理地址值改成虚拟地址对应的值，把文件中的段大小改成内存中的段大小，具体原理就是因为dump下来的elf中数据的偏移都是还在内存中的偏移，同时因为内存中的elf会把一些像stack_segment之类只有在运行时才会占据实际空间的段拓展，所以有些段的位置会被挤歪，也就是物理地址和虚拟地址不符，而ida只识别物理地址，所以要把物理地址的值改成虚拟地址对应的值，还有把在文件中的大小改为在内存中的大小，这样才能定位真实的偏移节表的部分在dump时都会损坏，要去未解密的so里把节表的部分复制过来同理对节表（section_table）里的元素也做修正偏移的操作注意到节表里有个储存各字段名称的部分由elf头里的string_table_index定位这个值是节表的索引，对应的节表元素里储存了所有表头的名称，这个部分在dump的时候是会丢失的，手动修复就要去原来apk里的so中把对应的部分复制出来（因为表头名称是不加密的）这些都修完后按理就修好了，修的过程中发现有些elf的部分没识别出来是正常情况，因为没修好010模板无法识别，边修边f5就会逐渐把符号表，节表之类的都显示出来 但是主播主播，你的操作太麻烦了，有没有一把梭的方法有的有的，直接上soFixer,修之前记得先用ll2cpp dumper提取符号，然后在用soFixer修，不然修完后的ll2cpp dumper就不识别符号了，用soFixer只要输入dump时的基址就能一键修正偏移了 修完后就是用ll2cppdumper自带的ida脚本把符号信息导入ida，在ida的script file里选择ida_with_struct_py3.py这个脚本，然后按照提示依次选择script.json和il2cpp.h两个文件导入脚本，就可以在ida里恢复符号记得ida里也要设定基址，在edit-&gt;segment-&gt;rebase一栏中填入dump时的基址这样跑完后该有的符号就都有了，因为题目要求做注册机，token是用小键盘输入的，所以先搜下keyboard试试看能不能找到相关函数 分析注册机输入可以看到还是找到了，拿frida hook一下看看调用 这里虽然做的时候软件一直崩溃，但还是拿到了hook数据这里是按了一下1按了一下enter，可以看到最后都调用了SmallKeyboard__iI1Ii,看看这个函数什么情况可以看到这里针对keyType的三种不同情况做不同处理，其中type=2的情况又调用了别的函数，所以重点hook SmallKeyboard__iI1Ii_469567457968看看这个v23是什么，怀疑是我们的输入hook结果如下，这个0x7b就是我们输入的123，点进这个函数看，发现最终调用了一个导入函数，如果跳过去是jumpout就手动c一下把数据转成代码，可能是ida误判没有把代码反编译出来那么这里很有可能是加密了，我们得跳到sec2023这个so的导出表里找这个函数，这里指的是导出表的第十个元素上文的hook脚本如下 12345678910111213141516171819202122232425262728293031323334353637383940setTimeout(() =&gt; { let lib = Process.getModuleByName(&quot;libil2cpp.so&quot;); console.log(lib.base); let offset = 0x6EF9C28000; let addr = [0x0000006EFA08E300, 0x0000006EFA08E18C, 0x0000006EFA08D880, 0x0000006EFA08DAB0, 0x0000006EFA08DFDC, 0x0000006EFA08DE90, 0x0000006EFA08E184, 0x0000006EFA08E2F8, 0x0000006EFA08E3B0, 0x0000006EFA08E3A8 ] var name = [&quot;SmallKeyboard___ctor(SmallKeyboard_o *this, const MethodInfo *method)&quot;, &quot;SmallKeyboard__Start(SmallKeyboard_o *this, const MethodInfo *method)&quot;, &quot;void SmallKeyboard__iI1Ii(SmallKeyboard_o *this, SmallKeyboard_iII1i_o *info, const MethodInfo *method)&quot;, &quot;SmallKeyboard__iI1Ii_469567457968(SmallKeyboard_o *this, uint64_t i1I, const MethodInfo *method)&quot;, &quot;void SmallKeyboard__iI1Ii_476641288156(SmallKeyboard_o *this, UnityEngine_GameObject_o *go, const MethodInfo *method&quot;, &quot;SmallKeyboard__oO0oOo0(SmallKeyboard_o *this, const MethodInfo *method)&quot;, &quot;SmallKeyboard__oO0oOoO(SmallKeyboard_o *this, const MethodInfo *method)&quot;, &quot;SmallKeyboard___c__DisplayClass14_0___ctor(SmallKeyboard___c__DisplayClass14_0_o *this, const MethodInfo *method)&quot;, &quot;SmallKeyboard___c__DisplayClass14_0___Start_b__0(SmallKeyboard___c__DisplayClass14_0_o *this, const MethodInfo *method)&quot;, &quot;SmallKeyboard_iII1i___ctor(SmallKeyboard_iII1i_o *this, const MethodInfo *method)&quot; ] for (let i = 0; i &lt; addr.length; i++) { console.log(&quot;hook &quot; + name[i]); Interceptor.attach(lib.base.add(addr[i]).sub(offset), { onEnter: function () { console.log(&quot;called &quot; + name[i]); } }) } Interceptor.attach(lib.base.add(0x0000006EFA4839C4).sub(offset), { onLeave(retval) { console.log(retval); }, })}, 3000); 这里有间接跳转，可以把so的data段改成只读，这样bn会自动计算部分跳转地址，当然还是不怎么可看，最好结合trace分析控制流 CRC校验绕过我们hook sub_3b8cc这个函数时会发现app会跳出，可能是crc校验检测到了inline hook，去hook open，openat等都没有发现相关调用，感觉可能是使用svc来避免相关函数被frida hook，使用stackplz对内核跟踪后发现调用了openat这个时候根据调用栈去找检测的位置，基本上每个调用下面都紧跟一个cmp，我们hook 参数看看是否像是在判断检测的最终结果，不断排查可以往前跳到sub_353e0这个函数可以看到这个sleep其实就已经很说明问题了，因为app不是马上跳出，而是过一会再跳出的这个时候我们把0x3649c这个位置的w0给hook成0，app就不跳出了，说明找对位置了，继续分析加密 加密1第一处加密的参数是输入的高32位，点进去看看像是对每个字节分别做了两次计算可以hook下验证下想法 就是些计算，hook下看下具体计算流程，然后就可以写解密了 1234567891011# enc = [0x17, 0x6d, 0x22, 0x89]enc = [0x89, 0x22, 0x6d, 0x17]enc[0] = enc[0]+0x1cenc[1] = (enc[1]+8) ^ 0xd3 ^ 1enc[2] = ((enc[2]+16)+0x5e) ^ 2enc[3] = (enc[3]+24) ^ 0x86 ^ 3for i in range(0, 4): print(hex(enc[i] &amp; 0xFF)) 然后是一个byteswap宏，就是把加密完的部分的字节序反过来 加密2在下面是sub_3a924是调用native调用dex加密，hook GetStaticMethodID这个函数去找加密函数在dex中的位置 1234567891011121314151617181920212223242526272829303132333435/*如何使用这个gadget通过hook libart.so中的getStaticMethodID函数来获取so层获取的dex函数信息一般直接运行即可，注意本gadget依赖libart.so的加载配套python解析message的函数def handleGetStaticMethodID(message): print(&quot;----------------------------------------&quot;) print(&quot;JAVA method name: {}&quot;.format(message['payload'][1])) print(&quot;JAVA method signature: {}&quot;.format(message['payload'][2])) print(&quot;Which file get It: {}&quot;.format(message['payload'][3]))*/function hookJNIgetStaticMethodID() { console.log(&quot;hook JNIgetStaticMethodID&quot;); let symbols = Module.load(&quot;libart.so&quot;).enumerateSymbols(); for (let i = 0; i &lt; symbols.length; i++) { let symbol = symbols[i]; if (symbol.name.indexOf(&quot;art&quot;) &gt;= 0 &amp;&amp; symbol.name.indexOf(&quot;JNI&quot;) &gt;= 0 &amp;&amp; symbol.name.indexOf(&quot;GetStaticMethodID&quot;) &gt;= 0 &amp;&amp; symbol.name.indexOf(&quot;CheckJNI&quot;) &lt; 0) { console.log(symbol.name); Interceptor.attach(symbol.address, { onEnter: function (args) { var Name = args[2].readUtf8String(); var sig = args[3].readUtf8String(); let whoCallIt = DebugSymbol.fromAddress(this.returnAddress).toString(); send([&quot;getStaticMethodID&quot;, Name, sig, whoCallIt]); } }) } }}setTimeout(hookJNIgetStaticMethodID, 3000); 用frida-dexdump把dex dump下来，然后可以都扔进jeb里了，加密部分加了平坦化混淆，jeb效果好一点就是循环右移后进行异或和加法，可以写解密了 12345678910111213key = [50, -51, -1, -104, 25, -78, 0x7C, -102]b1 = [0xf8, 0xd0, 0x17, 0x96]b1 = list(reversed(b1))for i in range(0, 4): b1[i] = (b1[i]-i) &amp; 0xFF b1[i] = (b1[i] ^ key[i]) &amp; 0xFFv = (b1[0] &lt;&lt; 24) | (b1[1] &lt;&lt; 16) | (b1[2] &lt;&lt; 8) | b1[3]v = v &amp; 0xFFFFFFFFv1 = ((v &lt;&lt; 7) | (v &gt;&gt; 25)) &amp; 0xFFFFFFFFprint(hex(v1))# ret: 6d98b6d2# [dexcall] f8d01796 低32位注意虽然反编译没有直接显示低32位被扔进了enc1里，但其实低32位也经历了一次enc1，应该是类型识别导致的问题然后是把低32位字节序反过来，再一样扔进那个dexcall里最后是把高32位放在低位，低32位放在高位拼起来返回 跨文件跳转看到这里还根据一个全局导出变量做了跳转，但是静态不好算这个变量，hook一下看看位置 12345Interceptor.attach(lib.base.add(0x311a0), { onEnter: function () { console.log(DebugSymbol.fromAddress(this.context.x2)); }}) 跳回libil2cpp了，和基址算一下偏移再去找跳到哪了再跳过去发现其实就是之前跳到sec2023.so的加密的下面也就是说加密完的64位数被弄到这个函数里处理了 il2cpp中的加密前面搞了一大坨初始化，传入输入也被分为高低各两份放进了v21这个结构体里，跟踪这个结构体,最后是走到了一个vm加密里，至于为什么断定这是vm因为里面进去就是一个大while(1),而且看着也不像其他加密vm里面这一大坨重点关注那个get_Item的库函数,hook他的第二个参数看看下标都是什么看到种类不多，接下来该去找handle的实现了 123456Interceptor.attach(ll2.base.add(0x46AE1C), { onEnter: function () { console.log(&quot;[handle]&quot;, ptr(this.context.x9).sub(ll2.base).add(0x6D54207000)) }}) 这里简单trace下拿下handle的函数地址 vm分析handle里面有些和数值计算相关的地方用了mba算式混淆，ida9.0内置了解mba混淆的插件拿完handle后一个个写trace，把指令和参数拿下来 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111function main() { var ll2 = Process.getModuleByName(&quot;libil2cpp.so&quot;); var idabase = 0x6D54207000; var basePtr = ll2.base.sub(idabase); Interceptor.attach(basePtr.add(0x6D5466CBD0), { onEnter() { console.log(&quot;low32 of input: &quot;, this.context.x0); } }) Interceptor.attach(basePtr.add(0x6D5466CBF4), { onEnter() { console.log(&quot;hig32 of input: &quot;, this.context.x0); } }) Interceptor.attach(basePtr.add(0x6D5466CC3C), { onEnter() { console.log(&quot;ret: &quot;, this.context.x21, this.context.x22); } }) Interceptor.attach(basePtr.add(0x6D546725CC), { // pushU16toStack onEnter() { console.log(`stack[${this.context.x10}] = ${this.context.x8}`); } }) var heapIdx = 0, stackIdx = 0; // popStacktoHeap Interceptor.attach(basePtr.add(0x6D54672548), { onEnter() { stackIdx = this.context.x9; heapIdx = this.context.x8; let value = ptr(this.context.x10).add(this.context.x9 * 4 + 0x20).readU32(); console.log(`heap[${heapIdx}] = stack[${stackIdx}] // stack[${stackIdx}] = ${value}`) } }) // pushHeaptoStack Interceptor.attach(basePtr.add(0x6D54672438), { onEnter() { heapIdx = this.context.x8; } }) Interceptor.attach(basePtr.add(0x6D54672460), { onEnter() { stackIdx = this.context.x10; console.log(`stack[${stackIdx}] = heap[${heapIdx}] // heap[${heapIdx}] = ${this.context.x8}`) } }) // shiftR Interceptor.attach(basePtr.add(0x6D54672088), { onEnter() { console.log(`push ${this.context.x10} &gt;&gt; ${this.context.x11} to stack // ${this.context.x10 &gt;&gt; this.context.x11}`) } }) // and Interceptor.attach(basePtr.add(0x6D54672104), { onEnter() { console.log(`push ${this.context.x10} &amp; ${this.context.x11} to stack // ${this.context.x10 &amp; this.context.x11}`) } }) // sub Interceptor.attach(basePtr.add(0x6D54671F14), { onEnter() { console.log(`push ${this.context.x10} - ${this.context.x11} to stack // ${this.context.x10 - this.context.x11}`) } }) // less Interceptor.attach(basePtr.add(0x6D5467220C), { onEnter() { console.log(`push ${this.context.x10} &lt; ${this.context.x11} to stack // ${this.context.x10 &lt; this.context.x11}`) } }) // xor Interceptor.attach(basePtr.add(0x6D54672180), { onEnter() { console.log(`push ${this.context.x10} ^ ${this.context.x12} to stack // ${this.context.x10 ^ this.context.x12}`) } }) // loadi32toStack Interceptor.attach(basePtr.add(0x6D546723D8), { onEnter() { heapIdx = this.context.x10; let value = ptr(this.context.x11).add(this.context.x10 * 4 + 0x20).readU32(); console.log(`load heap[${heapIdx}] to stack // heap[${heapIdx}] = ${value}`) } }) // shiftL Interceptor.attach(basePtr.add(0x6D54672008), { onEnter() { console.log(`push ${this.context.x10} &lt;&lt; ${this.context.x11} to stack // ${this.context.x10 &lt;&lt; this.context.x11}`) } }) // add Interceptor.attach(basePtr.add(0x6D54671E98), { onEnter() { console.log(`push ${this.context.x10} + ${this.context.x11} to stack // ${this.context.x10 + this.context.x11}`) } }) Interceptor.attach(basePtr.add(0x6D5467232C), { onEnter() { console.log(&quot;jmp if zero&quot;); } }) Interceptor.attach(basePtr.add(0x6D546722C4), { onEnter() { console.log(&quot;jmp if not zero&quot;); } })}setTimeout(main, 1000); 这里注意有有几条指令(比如load i32 to stack) 执行操作的位置离ret非常近，如果frida inline hook的点选的不好会导致程序直接崩溃，因为注入点没有足够的空间容纳跳转指令 trace完大概长这样，大约350条 然后就可以手撕了，能复原出来加密算法如下 123456789101112131415161718192021222324252627low32 = 0x038217c2hig32 = 0xae869c8aa1 = [0, 0, 0, 0]for i in range(24, -1, -8): a1[i//8] = (low32 &gt;&gt; i) &amp; 0xffa2 = [0, 0, 0, 0]a2[0] = a1[0]-0x1ba2[1] = a1[1] ^ 0xc2a2[2] = a1[2]+0xa8a2[3] = a2[3] ^ 0x36res1 = 0for i in range(0, 25, 8): res1 |= (((a2[i//8] ^ i) &amp; 0xFF) &lt;&lt; i)a3 = [0, 0, 0, 0]for i in range(24, -1, -8): a3[i//8] = (hig32 &gt;&gt; i) &amp; 0xffa4 = [0, 0, 0, 0]a4[0] = a3[0]-0x2fa4[1] = a3[1] ^ 0xb6a4[2] = a3[2]+0x37a4[3] = a3[3] ^ 0x98res2 = 0for i in range(0, 25, 8): res2 |= (((a4[i//8] + i) &amp; 0xFF) &lt;&lt; i) 然后解密如下 12345678910111213141516171819202122232425262728def decodeVM(ret1, ret2): a1 = [0, 0, 0, 0] a2 = [0, 0, 0, 0] a3 = [0, 0, 0, 0] a4 = [0, 0, 0, 0] for i in range(0, 25, 8): a4[i//8] = (ret2 &gt;&gt; i) &amp; 0xff a4[i//8] = a4[i//8]-i a3[0] = a4[0]+0x2f a3[1] = a4[1] ^ 0xb6 a3[2] = a4[2]-0x37 a3[3] = a4[3] ^ 0x98 for i in range(0, 25, 8): a2[i//8] = (ret1 &gt;&gt; i) &amp; 0xff a2[i//8] = a2[i//8] ^ i a1[0] = a2[0]+0x1b a1[1] = a2[1] ^ 0xc2 a1[2] = a2[2]-0xa8 a1[3] = a2[3] ^ 0x36 res1 = 0 res2 = 0 for i in range(0, 25, 8): res1 |= (((a1[i//8] &amp; 0xFF) &lt;&lt; i)) res2 |= (((a3[i//8] &amp; 0xFF) &lt;&lt; i)) print(&quot;low&quot;, hex(res1)) print(&quot;hig&quot;, hex(res2)) return res1, res2 xtea魔改了一个xtea，这个随便逆下就行了，xtea的解密没什么好说的，注意用了两个sum以及sum的初始值key就动调拿一下就行 1234567Interceptor.attach(ll2.base.add(0x465C60), { onEnter() { for (let i = 0; i &lt; 12; i++) { console.log(`key[${i}]: `, this.context.x0.add(i * 4).readU32().toString(16)); } } }) 12345678910111213141516171819202122232425262728void xteaDecrypt(uint32_t *v, uint32_t *k){ uint32_t sum = 0, v0 = v[0], v1 = v[1]; uint32_t sum1 = -1091584273; uint32_t sum2 = -1650623010; uint32_t delta = 559038737; sum1 -= 64 * delta; sum2 -= 64 * delta; sum = delta * 32; uint32_t ks2 = (sum2 &gt;&gt; 13) &amp; 3; for (int i = 0; i &lt; 64; i++) { sum2 += delta; v1 -= (sum2 + k[(sum2 &gt;&gt; 13) &amp; 3]) ^ (((v0 &lt;&lt; 8) ^ (v0 &gt;&gt; 7)) - v0); sum1 += delta; v0 -= (sum1 - k[sum1 &amp; 3]) ^ (((v1 &lt;&lt; 7) ^ (v1 &gt;&gt; 8)) + v1); } v[0] = v0; v[1] = v1;}int main(){ uint32_t key[4] = {0x7b777c63, 0xc56f6bf2, 0x2b670130, 0x76abd7fe}; uint32_t plaintext[2] = {71807475, 0}; // {token , 0} xteaDecrypt((uint32_t *)plaintext, key); printf(&quot;%08X %08X&quot;, plaintext[0], plaintext[1]); return 0;} 总结解密输入转成64位整数先跳到libsec2023.so中分高低两份分别进行简单计算加密和字节翻转和dex中的混淆加密，然后高低两份调换位置重新拼成64位传入libil2cpp.so中传入一个vm算法中加密，然后结果再传入xtea中加密，加密完后高位部分和0比较，低位部分和token比较 把上面的解密拼一下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081def decodeVM(ret1, ret2): a1 = [0, 0, 0, 0] a2 = [0, 0, 0, 0] a3 = [0, 0, 0, 0] a4 = [0, 0, 0, 0] for i in range(0, 25, 8): a4[i//8] = (ret2 &gt;&gt; i) &amp; 0xff a4[i//8] = a4[i//8]-i a3[0] = a4[0]+0x2f a3[1] = a4[1] ^ 0xb6 a3[2] = a4[2]-0x37 a3[3] = a4[3] ^ 0x98 for i in range(0, 25, 8): a2[i//8] = (ret1 &gt;&gt; i) &amp; 0xff a2[i//8] = a2[i//8] ^ i a1[0] = a2[0]+0x1b a1[1] = a2[1] ^ 0xc2 a1[2] = a2[2]-0xa8 a1[3] = a2[3] ^ 0x36 res1 = 0 res2 = 0 for i in range(0, 25, 8): res1 |= (((a1[i//8] &amp; 0xFF) &lt;&lt; i)) res2 |= (((a3[i//8] &amp; 0xFF) &lt;&lt; i)) print(&quot;low&quot;, hex(res1)) print(&quot;hig&quot;, hex(res2)) return res1, res2def decode1(enc): print(hex(enc)) enc = [(enc &gt;&gt; 24) &amp; 0xFF, (enc &gt;&gt; 16) &amp; 0xFF, (enc &gt;&gt; 8) &amp; 0xFF, enc &amp; 0xFF] print(list(map(hex, enc))) # 65b0c4b07ac8b1d9 enc[0] = enc[0]+0x1c enc[1] = (enc[1]+8) ^ 0xd3 ^ 1 enc[2] = ((enc[2]+16)+0x5e) ^ 2 enc[3] = (enc[3]+24) ^ 0x86 ^ 3 print(hex((enc[0] &lt;&lt; 24) | (enc[1] &lt;&lt; 16) | (enc[2] &lt;&lt; 8) | enc[3])) return (enc[0] &lt;&lt; 24) | (enc[1] &lt;&lt; 16) | (enc[2] &lt;&lt; 8) | enc[3]def decodeDex(enc): key = [50, -51, -1, -104, 25, -78, 0x7C, -102] b1 = [(enc &gt;&gt; 24) &amp; 0xFF, (enc &gt;&gt; 16) &amp; 0xFF, (enc &gt;&gt; 8) &amp; 0xFF, enc &amp; 0xFF] print(enc) print(list(map(hex, b1))) # b1 = [0x0b, 0x9e, 0x7f, 0xc7] b1 = list(reversed(b1)) for i in range(0, 4): b1[i] = (b1[i]-i) &amp; 0xFF b1[i] = (b1[i] ^ key[i]) &amp; 0xFF v = (b1[0] &lt;&lt; 24) | (b1[1] &lt;&lt; 16) | (b1[2] &lt;&lt; 8) | b1[3] v = v &amp; 0xFFFFFFFF v1 = ((v &lt;&lt; 7) | (v &gt;&gt; 25)) &amp; 0xFFFFFFFF print(hex(v1)) return v1def byteswap(x): return ((x &amp; 0x000000FF) &lt;&lt; 24) | ((x &amp; 0x0000FF00) &lt;&lt; 8) | ((x &amp; 0x00FF0000) &gt;&gt; 8) | ((x &amp; 0xFF000000) &gt;&gt; 24)low32 = 0x7CD0D74Bhig32 = 0xEB77B65Blow32, hig32 = decodeVM(low32, hig32)low32, hig32 = hig32, low32low32 = decodeDex(low32)low32 = byteswap(low32)low32 = decode1(low32)print(&quot;low32:&quot;, hex(low32))hig32 = decodeDex(hig32)hig32 = byteswap(hig32)hig32 = decode1(hig32)print(&quot;hig32:&quot;, hex(hig32))print(hex((hig32 &lt;&lt; 32) | low32))print((byteswap(hig32) &lt;&lt; 32) | byteswap(low32)) 把xtea中解出来的部分分别扔进low32,hig32里，然后跑就行了","link":"/ctf/Andorid/%E8%85%BE%E8%AE%AF%E6%B8%B8%E6%88%8F%E5%AE%89%E5%85%A8%E5%A4%A7%E8%B5%9B2023%E5%AE%89%E5%8D%93%E5%88%9D%E8%B5%9B/"},{"title":"ACM刷题日记","text":"想起来去年还在打acm的时候写了一段时间的做题日记，索性放到博客上好了 CF1898D Milena and Admirer贪心 绝对值图像化思想把$ a_i $，$b_i$抽象成线段的端点，|$a_i-b_i$|表示线段长，操作等同于交换两个线段的端点，通过分类讨论求每种情况下产生的贡献 CF1901B Chip and Ribbon思维还算有趣的题，推一下发现每次操作的贡献是当前段数 * 当前剩下的最小的数，如果是第一次操作则后者减一，对于维护段数，考虑对于每个数存它出现的位置，如果删除时左右都有数则标记段数++，如果左右都空则标记段数– CF1901C Add， Divide and Floor推式子找规律让整个序列都相同等价于把最大的和最小的变成相同的假设每次选一个满足$minn \\leq x \\leq maxn$的x$\\Delta maxn=\\lvert \\frac{maxn-x}{2}\\rvert= \\frac{maxn-x}{2}$$\\Delta minn=\\lvert \\frac{minn-x}{2}\\rvert= \\frac{x-minn}{2}$ 发现如果不考虑精度误差则x可以任意选，考虑精度误差，发现当maxn为奇数，minn为偶数时，选x为偶数可以使maxn下降更快，minn上升更快，反之同理 CF1901D Yet Another Monster Fight思维意外的简单，不知道为啥场切人数那么少显然对于每一个$a_j$，答案最差的情况是在到达$a_j$左侧或右侧某个很大的点$a_i$之前多走弯路(浪费威力最多)，可以对这个大点$a_i$按在$a_j$的左侧或是右侧分类讨论，通过手模发现，结果为$ans_{a_j}=max\\begin{cases} n-i+a_i ，\\quad i &lt; j \\ i+a_i，\\quad i &gt;j \\ a_j\\end{cases}$直接开两个multiset L，R，j从左向右扫，每次删掉一个右边的，增加一个左边的，对于每个j统计答案取min即可 数论涉及多个gcd求和 CF1900D有可能是欧拉反演，但是不想学数论 CF1900E Transitive Graph图论tarjan对于随便一个环(强连通分量)，按题意会连成一个完全图，也就是说在这个块里可以任意走要走长度最长且点权和最小的路，因为上面的条件所以随便一个强连通分量我们都可以一笔画走完，显然能走就走是最优的，tarjan跑完写个拓扑跑类似最长路的dp即可 ####CF1896A Jagged Swaps 结论$a_1=1$就是合法的，手模得出 CF1896B AB Flipping结论同样有趣的题，手模发现原序列去掉前导B和后导A后每个点都可以操作(后面的B可以被一路换到前面去)，固答案为$max \\lbrace 0，len-1 \\rbrace$ CF1896D Ones and Twos结论+DS题目里给了$a_i \\in \\lbrace 1，2\\rbrace$是有道理的对于一个左右端点都是1的子串，任意删掉一个端点的1可以改变子串和的奇偶性，连续删去两个1等价于删去一个2(无论两个1是否相连，由分类讨论得)，那么显然对于每个询问，先取出左右端点为1的最长的串L，如果$sum_L\\geq v$那就合法，否则考虑$sum_L$和$v$的奇偶性，奇偶性相同就向两边凑2，不同则删去一侧的1然后取剩下侧的2，左右端点重合的情况也适用 用set存每个1的位置，查询时直接取set的头尾，区间和用树状数组维护 CF1896C Matching Arrays贪心似乎这种题都是大的对大的小的对小的？ constexpr预处理这个关键字放在定义前可以让后面的东西在编译的时候跑，可能初始化素数表之类的挺有用的？ ####重载运算符对于二元运算符重载的时候成员函数作为左边的参数，显式操作数作为右边的参数 move()a=move(b) 把b的资源转移给a，比复制快很多，大概在滚动数组里有用 CF1902C Insert and Equalize贪心还算巧的贪心，选择一个数$x$使得可以通过不断加$x$让$a_{1…n+1}$相等，首先考虑$a_{1…n}$，先从小到大排序然后考虑相邻项的差值，因为只能不断加一个数这个数只能是这些差值的大公因数，不然凑不齐。然后考虑$a_{n+1}$，记之前得出的最大公因数为$g$，则$a_{n+1}$可以由$a_n$加上或减去g得到，我们优先考虑减，如果减了n次都不行就直接令$a_{n+1}=a_n+g$，同时把{a_{1…n}}抬高g CF1902D Robot QueriesDS+前缀和询问执行给定操作后是否经过指定点，先不考虑翻转，可以把经过的点做成一个前缀和，对于每个询问查询前缀和数组里是否有这个点考虑翻转的情况，对于一个原本能到达的点$pre_i=(x，y)$，我们先把它还原到翻转区间的起点，即$pre_i-(pre_i-pre_{l-1})$，然后看他翻转后是什么样，即$pre_i-(pre_i-pre_{l-1})+(pre_r-pre_{i-1})$如果这个反转后到达的点就是所求的$P=(x，y)$，那么整理下得出$pre_{i-1}=pre_{l-1}+pre_r-P$，所以对于翻转过的区间，我们只要在$[l-1，r-1]$里找是否有符合条件的$pre_{i-1}$即可，对于正常的区间就在$[0，l-1]，[r+1，n]$里找是否有询问的点$P$即可，显然翻转后对于翻转区间外的点是没影响的。找点的具体实现用线段树套set，线段树的每个节点上开一个set，添加点就一路insert到叶子，查的时候合并各区间答案即可 CF1907B YetnotherrokenKeoard栈签到题，分大小写开两个栈即可 CF1907C Removal of Unattractive Pairs贪心发现最后肯定只剩一个字母了，而且那个字母肯定是数量最多的，根据出现次数最多的字母的数量和n的大小分类讨论即可 CF1907D Jumping Through Segments二分二分答案，在check的过程中维护每次能到达的点的区间$[a，b]_n$，显然这个$[a，b]n$的更新可以通过分类讨论$[a，b]{n-1}$与$[l_n，r_n]$的相交情况实现，如果不相交就说明k非法 CF1907F Shift and Reverse哈希+结论首先这道题要知道只有以下几种情况可能是最优的：1.一直往前翻2.翻转然后一直往前翻3.翻转一直往前翻然后翻回来4.一直往前翻最后翻转这四种情况1，4等价于把后面的搬到前面去，2，3等价于把前面的搬到后面，然后最后的结果是使序列变成递增或递减的然后我们把原序列复制一遍放在后面，这样扫过去就可以直接得到所有我们可能通过操作产生的序列，然后操作数可以直接算出来，具体通过手模找规律，然后只要扫到某个数$a_i$是最大或是最小的（可以作为单调序列的起点），我们就用哈希判断$a_{i…i+n-1}$是否和排序好的序列一样，如果一样就计算把原序列变成这样需要的最小操作数并更新答案 set使用自定义类型对于自定义类型，劣质的重载&lt;会影响set的行为(大概率导致set出问题) CF1904B Collecting Game双指针双指针板子题，排序后跑双指针即可 CF1904D1 Set To Max (Easy Version)贪心easy version的数据较小，直接跑$n^2$的贪心即可，hard version可能要在原做法上加一个线段树维护区间最大值从小到大依次取$a_i$，然后分别向左右拓展，只要是扫到的数比$a_i$小并且比$b_i$小就可以把他设为$a_i$，最后扫一遍a看和b是否相同即可 CF1904D2 Set To Max (Hard Version)贪心+RMQ还真是原做法随便加一个单次logn或者更优的rmq，对于一个需要set to max的$a_i$显然我们需要找到它左边或右边最近的和$b_i$相等的$a_j$，选最近可以让一次操作对其他数字的影响最小，然后用rmq查$a_{i…j}$里面是否有比$b_i$大的，$b_{i…j}$里面是否有比$b_i$小的，如果都没有显然这次操作是合法的，然后优化下easy version取数的方式，改成从小到大取$b_i$（从结果入手），总的复杂度限制在rmq初始化$nlogn$ CF1904C Array Game分类讨论发现对于k&gt;=3，可以直接先选两次一样的$a_i，a_j$，然后第三次让两次的差互相减，答案肯定为0对于k=1，直接在所有的差和本来就有的数中间选一个最小的即可对于k=2，先$n^2$搞出来所有的差，然后每次在原数组中lower_bound一下去找和这个差最近的数再做差，也是把搞出来的所有数取min求答案，复杂度$n^2logn$ 后缀BIT把前缀树状数组的所有循环顺序倒过来就能实现后缀bit 费马小定理一个数在 mod b下关于a的逆元为 $a^{b-2}$ CF1917B Erase First or Second Letter计数对于一个字符串，如果确定第一个和第二个字符，那就不能继续操作了，可以将最终的字符串拆分成一个后缀和一个字母组合的形式，我们可以不断进行操作2来使一个字母匹配每一个后缀，同时因为我们只能删前两个字母，所以实际上我们最多有n个不同的后缀，且长度分别为1~n，所以我们要统计对于每一个后缀，前面有多少个不同的字母可以与其组合，开一个桶计数即可，把每个后缀的答案求和就是总的答案。 CF1917C Watering an Array贪心一个重要的性质，假设a=[0，0，…，0]，不管b的组成是什么样的，且执行几次添加操作，始终最多有1个$a_i=i$，因为假设$a_x=x$，那么对于$a_x$前面的所有$a_i$肯定有$a_i \\geq a_x$（因为每次是对一个前缀+1），对于后面的同理，所以如果我们进行过一次reset操作，之后最优的做法一定是add一次就reset一次，总贡献为d/2，所以问题转化成确定第一次reset的时间，注意到第一次reset最多也就产生n的贡献，所以如果我们第一次reset的时间晚于2*n+1，则一定不是最优的，即一开始最多add 2n次，直接暴力add 并统计答案取max即可，注意判断操作是否合法 CF1917E Construct Matrix构造非常神秘的构造，答案一半很显然，一半很不显然要求构造一个n*n的矩阵m，n为偶数，要求每行的1的数量同奇或同偶，每列同奇或同偶，且总数等于k首先特判，如果$k = n^2-2 || k=2 $，此时如果k!=2，则无解然后是对于k%4=0的部分，显然我们可以尝试把1组合成2x2的块放进去，一个2x2的块对横纵的奇偶性都是没影响的对于k%4=2的部分(不知道怎么想到的)如果k&lt;6肯定是第一种无解的情况，当$k \\geq 6$，我们先把$m_{1，1}，m_{1，2}，m_{2，1}，m_{3，3}，m_{3，2}，m_{2，3}$这六块变成1，然后剩下k-6的部分在除左上角4x4的范围继续组成2x2的块填进去，然后$k=n^2-6$则正好会有4个1多出来，则在$m_{1，3}，m_{1，4}，m_{4，4}，m_{4，3}$四个位置填上1，对于其他的所有情况，均无解 CF1913B Swap and Delete思维，字符串定义两种操作，从s中删去任意一个字符，代价为1，任意交换一对字符，代价为0记操作任意次后得到的字符串为t，问使t与s对应位置的字符均不相同的最小代价因为交换是无代价的，所以只要让t的1数量和s长度为|t|的前缀的0数量相同，反之亦然即可考虑直接枚举答案，显然答案最大为|s|，删完了肯定都一样了，对于每个答案n，实际上我们可以在合法的前提下任意删除总数为n的0和1，如果s里的0比t里的1多肯定这个答案是不行的，因为我们只能从t里删东西，对于每个可能成为答案的t，一定有$cnt1_t=cnt1_{preS_|t|}$，所以我们只要对于每个可能成为答案的t，统计s的0与t的1的数量差值和s的1与t的0的数量差值，如果两个差值和与我们枚举到的答案相等，则这个答案就是合法的，从小到大枚举找的合法的就退出即可 CF1913C Game with Multiset贪心，二进制很套路的题往一个集合里多次插入$2^x$，多次询问集合里的数是否可以凑出w显然先把w拆成二进制的形式，然后每次询问从低位向高位枚举，如果集合里这位有多的就除二借给下一位，一路枚举到头即可 CF1913E Matrix Problem最小费用最大流板子题，出在div2E估计是科技太高了发现n很小，且是约束问题，考虑网络流要求$i$行要有$a_i$个1，$j$列要有$b_j$个1，可以建超级源超级汇，合法的情况就是每个$a$点有$a_i$的流量，每个$b$点有$b_j$的流量，直接从源点向每个$a$拉流量为$a_i$的边，从每个$b$向汇点拉流量为$b_i$的边，费用均为0然后中间$a，b$直接拉完全图，边代表矩阵里的点，流量都是1，如果这个点本来是0，就拉费用为1的边，如果已经是1了，就拉费用为-1的边，同时先在答案里+1，表示如果这个点最终就是1，则不需要付出代价，所以费用和先加的1抵消，如果这个点最终应该是0，那这个点的流量就不会算进总流量里，也不会计算这个点的费用，按题意需要付出一点代价，而这个代价在拉边时已经加好了建完图跑dinic板子即可，最后如果a，b流量都跑满且相同就是合法答案 CF1914C Quests贪心显然最优答案是前i个先各做一次，然后剩下k-i次全部做b最大的那一个 CF1914D Three Activities贪心假设每次我们都只选a，b，c里前三大的i，最差的情况是这三个都相同，如果随意拿掉一个a，b，c也总还有两个可以选，而且这些选的都是前三大的，答案一定是在这里面产生的，所以直接找三元组里a，b，c分别是前三大的，从这几个(3~9个)里暴力枚举答案 CF1914E Game with Marbles贪心easy version直接爆搜hard version这么考虑，对alice，一次操作产生的贡献是$a_i+b_i$（A取了$a_i-1$，同时B的$b_i-1$不能取了，等价于对总答案的贡献是$(a_i-1)-(b_i-1)$），发现对bob来说也是同理，所以直接按照$a_i+b_i$排序，依次取大的即可 CF1914G1 Light Bulbs (Easy Version)tarjan这题有2100？ 不是很认可mod 998244353不开long long 是存在溢出并且输出不是负数的可能性的(能开long long 尽量开)发现对于一个颜色，显然如果我们先把一个灯点亮，那另一个灯也亮了，然后这两个灯之间的通过操作2也全亮了把灯抽象成线段的两端，如果一条线段被另一条完全覆盖，那只要长的那条点亮就行，如果交叉覆盖，则任意点亮一条即可，考虑对于每条线段u，向他所覆盖到的所有线段v拉单向边，表示点亮u就能点亮v，这样对于完全覆盖就是只能点亮u，对于交叉覆盖就是u，v任意点亮一个，注意到这里产生了强连通的问题，把图建好后跑缩点，缩完点的图中入度为0的点的数量就是S的大小，然后显然这些入度为零的点里被压缩了颜色数*2个灯泡，用乘法原理全乘在一起就是方案数 CF1918A Brick Wall贪心一个砖的大小是$1k$，墙的稳定性是横着的砖的数量减去竖着的砖的数量显然偶数长度就直接全部$12$的砖，奇数长度就一排$13$的砖，其他的就全部继续用$12$的 CF1918B Minimize Inversions思维给定两个序列A，B，可以同时交换$a_i，a_j和b_i，b_j$，要求输出排序后的A，B，使得其中逆序对的数量和最少考虑单独的一对$a_i，a_j，b_i，b_j$可能会有0，1，2对逆序对的情况，对于0的情况，交换产生2组逆序对，对于1的情况，交换消除一组逆序对，并产生一组逆序对，对于2的情况，交换消除两组逆序对发现如果对A排序，那么A中的逆序对数为0，那么对于所有的$a_i，a_j，b_i，b_j$，只会出现1和0的情况，而这两种情况无论怎么交换都无法减少逆序对的总量，所以此时总的逆序对数达到最小 CF1918C XOR-distance思维异或问题拆位考虑假设$a&gt;b$，发现如果我们搞a，b的最高位（对齐情况下），就会搞完后$a &lt; b$，那后面就没法确定怎么搞了，所以考虑不动最高位，从次高位开始搞，这样不管怎么弄都能满足$a&gt;b$，只要尽可能缩小a并增大b就行了对于a，b该位都是0或1的情况显然对答案没影响1：对于a是1，b是0的情况，x这位是1对答案有贡献2：对于a是0，b是1的情况，x这位是0对答案有贡献所以对于每一个情况1，在$x \\leq r$的前提下不断将x这位置1就可得到最终的x CF1918D Blocking Elements二分 单调队列 dp给定一个序列，要求通过删去元素把序列分为的几段，同时删去的元素一起作为一段，要求使所有段中和最大的最小 最大值最小考虑二分答案，在序列头和尾分别设两个值为0的虚点，$dp_i$表示目前到第i个元素，并删除这个元素，此时被删除元素的总和的最小值，我们每次更新$dp_i$最好是选择某一块合法区间内最小的dp值，考虑单调队列维护这个值，当队头不合法时（队头和i之间的元素和超过二分的答案），不断弹出队头，每次使用队头的值更新此时的$dp_i$，并不断弹出比$dp_i$大的队尾元素，并把i插入单调队列，只要$dp_{n+1}$比此时的答案小，就继续更新答案 CF1921D Very Different Array贪心从B里选n个作为数组A，使$A_{1…n}和C_{1…n}$对应位元素差的绝对值之和最大考虑先让B里最大的对应C里最小的数，这样B里会剩下一些最小的数，同时发现这样每次产生的贡献使递减的，同时最后可能会有B中的数比C中的数小的情况，所以我们再倒着用B里最小的数去对应C里最大的数，这样每次更新答案只用变换一个位置的值，不断更新答案的最大值即可 CF1921E Eat the Chip贪心 结论Alice可以往下，左下，右下走，Bob可以往上，左上，右上走，Alice先手，问谁赢或者平局贪心地想，两边同时向左，同时向右，一左一右都不影响横向距离的奇偶性，即不影响最后谁赢，只有纵向距离的奇偶性影响结果，所以纵向距离为奇数时，bob必定会考虑保平，反之同理考虑保平的情况，显然游戏结束的时间时确定的，即双方纵向位置相同的时候，此时不能吃掉对方就一定平局，所以直接考虑不可能赢的那方在结束前最远能到达左边或右边的哪个位置，再看另一方能否也到达那个位置，能到达就赢，否则平局 CF1922A Tricky Template贪心给定一个字符串s，称满足以下条件的小写字符串t是符合题意的1.如果s第i位是小写，t这一位必须和s一样2.如何s第i位是大写，t这一位必须和s不一样给定符合题意的字符串a，b ，和不符合题意得字符串c，问这样的t是否存在如果a，b，c这一位不一样，只要让t这一位和c一样并大写即可如果a，b这一位一样，和c不一样，只要让t这一位和ab一样并小写即可 CF1922B Forming Triangles组合数给定n个木棍，第i根木棍的长度是$2^{a_i}$，问选三根木棍组成三角形有多少种方案首先发现木棍的长度都是2的幂，显然想组成三角形就只能组成等边三角形，找到每种长度的棍的数量求组合数就行了 CF1922C Closest Cities贪心n个城市在数轴上，有两种移动方式1.移动到任意城市，代价为两城市间的距离2.移动到最近的城市，代价为1q次询问，问从a到b的最小代价发现对于每个城市，发现在只考虑往一个方向走的情况下他和离他最近的那个城市的距离可以压成1，然后显然我们每次询问肯定都是往一个方向走的考虑向左和向右走两种情况分开做，预处理出新的位置，然后询问时直接位置相减算答案 CF1922D Berserk Monsters贪心 set 链表每个怪物每轮会被他的邻居攻击，每轮结束时，受到的伤害大于防御的怪物会死亡，问每轮死亡的怪物数每一轮结束后，如果一个怪物这一轮没有死，且他的邻居也没有死，那他下一轮也不会死（受到和这一轮一样的伤害）所以我们考虑每轮结束时，把死亡的怪物加入set，显然下一轮我们只要更新这些怪物的邻居的答案就行了，更新答案的总复杂度最差为O(3n)，找邻居和删除的过程用链表实现 CF1923A Moving Chips贪心一个1可以被移到最左边最近的空格，问把所有1连起来的最小移动次数显然删除前导0，后导0，剩下的0的数量就是我们要移动的次数 CF1923B Monsters Attack!贪心每秒发射k个子弹，任意分配，每发子弹造成1点伤害，数轴上n个怪物，每秒向原点移动一格，如果任意一秒结束时原点上有存活的怪物则失败，问能否杀死全部怪物先把所有怪物按离原点的距离排序，考虑按秒模拟，每秒射出的总子弹数增加k，并减去这一秒到达原点的所有怪物的血量值，如果出现子弹数不够则失败 CF1923C Find B贪心 构造一个长度为m的序列a是好的当且仅当存在一个长度为m的序列b满足1.a的和等于b的和2.a和b每一位均不相等3.b每一位都大于0给定一个序列c，q次询问，每次问c的一个子段是否是好的显然有一种贪心的构造法，我们考虑c的这个子段里有多少个1，对于这些1，我们构造2，对于剩下不是1的，我们全部构造1，然后如过此时总和还不够，就把少的全部任找一个2加进去，如果不能这么做则这个子段就是不是好的 CF1923D Slimes贪心 二分 前缀和n个史莱姆，每秒有且只有一只史莱姆吃掉一个大小严格小于他的邻居，且大小变为两者之和，n次独立询问，问每只史莱姆最早第几秒被吃掉一个重要的性质，假设一个史莱姆i最终被j吃掉，而j在吃i之前一定吃了包含j的一个子段里的所有史莱姆，然后我们发现，找到j等价于找到这个子段，而这个子段一定是在i的左边或右边且与i相邻，且和正好大于i，即不用去考虑j吃掉i的具体过程，$ans_i$就是这个子段的长度，所以问题转化为对于每个i，找到他左边或右边最短的总和大于他的子段，前缀和+二分即可，总复杂度O(nlogn) CF1945B Fireworks结论观察样例发现答案就是$m/a+m/b+2$ CF1945C Left and Right Houses前缀和前缀和统计1的数量，枚举断点即可 CF1945D Seraphim the Owl贪心假设从i交换至j，发现有两种交换途径，一种是每次只前进一格，这样每次代价为$a_{i+1}$，或者前进x格，那么代价为$\\sum_{p=i+1}^{i+x-1}b_p+a_x$，发现这两种前进方式是灵活的，如果这一步不是终点的话，我们的代价是$\\min(a_i，b_i)$，因此从i交换到j的最优解是$\\sum_{p=i+1}^{j-1}\\min(a_p，b_p)+a_j$，倒着累加即可 CF1945E Binary Search结论考察了二分的性质，对于我们瞎跑出来的l，可以发现有$p_l \\leq x$，这是给出的描述决定的，然后发现如果我们把此时的$p_l$换成一个不大于$x$的数，显然对l的位置也没有影响所以我们直接在原序列上跑题目给出的二分，然后把$x$的位置和跑出来的$l$交换即可 CF1945F Kirill and Mushrooms贪心 set首先为了方便处理不能选的情况，把原序列按$i_{s_j}$从小到大排序依次考虑选$k$的个情况假设我们要选$k$个，那么最优的做法肯定是从可以选的$n-(k-1)$个里选$k$个最大的，可以考虑从选$k-1$个的情况转移来，我们考虑开两个set，把没选的扔进unselect里，选了的扔进select个里，当我们准备选第$k$个的时候，根据题意此时排序后的第$k-1$个就不能选了，如果他在unselect里，就把他删了，然后再选unslect里最大的移到select里，如果他在select里，也把他删了，再从unselect里选最大和次大的移到select里，可以发现这样单次更新答案是logn的，unselect空了就结束，每次更新答案时统计最大值即可 gym104090M ICPCHZ2022 M. Please Save Pigeland换根 线段树缝合怪题，给定点集$S$，要求在树上找到一个点$u$，使得$\\frac{\\sum dist(u，S_i)}{gcd(dist(u，S_i))}最小$考虑换根，我们先求出$u$为1的情况，然后以1为根开始换根，发现我们每向经过一条边$E(u，v)$，对答案产生的影响是$v$子树内的所有特殊点的$dist$全部减去$dis_{E(u，v)}$，其余的特殊点全部加上$dis_{E(u，v)}$，考虑记录以1为根的每个点的dfs序，可以发现一个点子树内的点满足$dfn[u]\\leq dfn[v] \\leq dfn[u]+siz[u]-1$，可以把特殊点按dfs序排序并每次通过两次二分求左右端点的方法得到哪段是要被减去距离的，我们需要一个可以维护区间加减和区间gcd的数据结构，考虑线段树，由gcd的性质得知一个序列的gcd等同于这个序列的差分的gcd，问题转化成单点修和区间gcd，所以每次换根的时候，用线段树维护差分数组，并统计整个特殊点序列的gcd计算答案即可，总复杂度$O(nlog(n)log(V))$ CF1956F Nene and the Passing Gameset 思维因为能否传接球的关系是双向的，不妨设$i&gt;j$，把给定的式子化简一下，可以得到 $i-l_i \\geq j+l_j$ $i-r_i \\leq j+r_j$ 可以在保证1式成立的前提下考虑2式，我们可以把n个人拆成权值分别为$i-l_i$和$i+l_i$的2n个点，再把这些点按权值从小到大排序，这样我们就能保证每个点对前面的所有点都满足1式，同时我们可以把权值为$i+l_i$的点视作修改，把权值为$i-l_i$的点视作询问，每当扫到前者时，我们往一个递减的set中插入该点，权值为$i+r_i$，这样当我们扫到代表询问的点x时，只要不断从set头中取出满足$x-r_x \\leq i+r_i$的点i与x组成连通块，并从set中删去该点，连完后再把整个连通块的根塞回set里，最后统计连通块的数量就可以得到答案了同时我们注意到，对于一个连通块，我们只要看他最大的$i+r_i$的值，所以只要把第一个取出的点作为整个连通块的根即可，因为我们保证了set中第一个取出的点一定是全局$i+r_i$值最大的 CF1942A Farmer John’s Challenge结论对于$n=k$ 显然全部输出1就行了对于$k=1$ 显然先输出n，再依次输出1~n-1即可对于$1&lt;k&lt;n$，发现一个有序序列只要平移一次一定会变成无序的，所以这些都是不可能的情况 CF1942B Bessie and MEX贪心由于mex和排列的性质，考虑倒着做对于$ans_n$，显然此时的mex为n，直接可以算出$ans_n$，当知道了ans_n后，$ans_{n-1}$的mex显然就是目前的mex和$ans_n$的值取小的那个，不倒推即可 CF1942C Bessie’s Birthday Cake贪心 思维考虑y=0的情况，把给定的点连成多边形，对于一个多边形，其内部能划分出的三角形个数就是其边数x-2，然后我们发现如果两个给定的点之间夹了一个未给定的点，这种情况也能组成三角形，所以就是统计距离为2的点对的数量ans,最终答案是ans+x-2 当$y \\neq 0$时，我们要不断构造上面所说的距离为2的点对的情况，这也能分两类讨论，当两个相邻的给定点距离大于2时，根据画图找规律可以发现，在把间隔按照中间每隔一格赛一个点的规则填满时，当距离（$a_x-a_y$）为偶数，一共可以填$(a_x-a_y)/2$个点，产生$(a_x-a_y)/+1$个三角形，当填不满时则少一个，当距离为奇数时，可以填$(a_x-a_y-1)/2$个点，产生$(a_x-a_y-1)/2$个三角形，所以我们先填距离为偶数的间隔，并先填短的，注意处理未填满的情况即可 CF1957B A BIT of a Construction贪心直接从低位到高位枚举$a_i$并将k减去$a_i$即可 CF1957D A BIT of an Inequality思维 二进制我们把原式展开，首先可以的到几个结论： 当x=y=z时肯定不符合题意 原问题等价于，对于一个区间的异或和$pre_{l…r}$，问这个区间内有几个数$a_i$满足$a_i \\bigoplus pre_{l..r} &gt;pre $ 进一步分析2，发现2等价于，要求$a_i$的最高位对于$pre_{l..r}$而言，该位为0 发现如果枚举区间复杂度无法接受，考虑对于y寻找可能的x，y，即区间的左右端点，从左往右枚举y，考虑分别记录y左边至0，y右边至n有多少个$pre_i$第j位为0或者1，假设j为$a_i$的最高位，我们只需简单使用乘法原理（cnt0之间相乘,cnt1之间相乘）就可以得到有多少对$pre_r \\bigoplus pre_l$满足题意实现过程中注意，开始应该把所有点都扔进右边的桶里计数在计算$a_i$的答案时，考虑到实际的区间左端点是$l+1$，所以我们先算答案，再把$pre_i$从右边的桶移到左边的桶，这点通过画图可以得知 CF1966A Card Exchange贪心发现我们只关心一次换了k-1张牌，不关心牌具体的情况，所以最优策略就是每次换当前数量最多的，换过来的k-1张牌存进tot里，遇到不够换的时候拿tot补，最后没法换了把剩下的总牌数加上剩下的tot就是答案（注意最后tot和k-1取min）,开个堆瞎搞即可 CF1966B Rectangle Filling思维发现对于一种颜色，我们相当于是选一条对角线代表的矩形涂色，我们考虑看对于每个颜色，显然它在x轴上最多只能涂到x值最大的同色块那么远，然后x轴和y轴的答案显然是不干扰的，所以要全部涂成同一颜色，我们只要看对一个颜色，它最小的x值和y值是否为1，最大的x值和y值是否为n和m即可 CF1966C Everything Nim博弈论对于每轮游戏，选择一个最多不超过最小石子堆石子个数的正整数k，并将每个堆都移去k个石子因为每次移的个数有上限，而且还是对所有的堆都移，考虑每轮最多能移几个，发现问题等价于对原序列排序后的差分数组进行移石子，且遇到0全部跳过（显然），而且只能从左往右移，然后考虑先后手，当目前堆石子数大于1的时候,先手的那个人可以选择全部移走，或者留一个，意味着他可以决定在移下一堆石子是自己是先手还是后手，也就是再之后遇到1时的强制交换先后手对它没有影响（这点手摸可以发现），所以我们只要考虑遇到第一个大于1的数时谁是先手，也就是统计去0后的差分数组里连续的前导1的数量（不包括差分数组最后一位的数），偶数Alice，奇数Bob CF1966D Missing Subsequence Sum构造看到串的长度小于25，考虑二进制分解，我们可以构造一个1,2,4…的串，同时这个串不包含k最高位的1，这样我们就确保了对于这一位是1的所有数都凑不出来然后考虑如何凑出这一位是1的，且不等于k的其他数，假设这一位为i，串中比它低的位的和加起来是$2^i-1$，那我们如果放一个$k-2^i$，它与前面这些数加起来就是k-1，根据二进制分解的原理我们确保了1…k-1都可以凑出来,然后我们可以暴力添加一个k+1，那么这个k+1与我们前面已经构造出来的1…k-1就可以凑出k+2…2k, CF1969A Two Friends贪心有长度为2的环答案就是2，否则是3 CF1969B Shifts and Sorting贪心手玩发现对于1100，我先操作$s_{1…3}$再操作$s_{2…4}$和直接操作$s_{1…4}$结果是一样的问题就化为从左往右，对于每一个1，把他和他后面遇到的第一个0交换位置（以这两个数为端点执行一次右移）注意到我们这么做的实质是不断把1后面的0提到最前面，所以我们只要记录第一个1的位置pos，然后每次操作后pos+1就是下一个1的位置，所有的1是很自然被排到一起的 CF1969C Minimizing the Sumdp一次操作可以把一个数左边或右边的邻居替换为它，问最多操作$k (k \\leq 10)$次后整个序列和的最小值发现k很小，考虑预处理以i为右端点，i-j为左端点,操作j次产生的贡献$v_{i,j}$,以i为右端点可以方便处理后效性的问题自然想到dp数组$dp_{i,k}$代表前i个数操作k次产生的最小贡献考虑如何转移，假设我们在i处操作j次，此时总共操作了k次，$dp_{i,k}$显然就要从$dp_{i-j-1,k-j}$前面的状态转移来，然后我们肯定要从前面里选一个最小的,所以$mindp_{i,j}$表示$dp_{1…i,j}$里最小的值，转移方程就是$dp_{i,k}=min(dp_{i,k},mindp_{i-l-1,k-j}+v_{i,j})$，记得每次转移完后更新$mindp_{i,j}$,并且$mindp_{i,j}$在进入第一次转移前初始化为$mindp_{i-1,j}$，dp入口为$dp_{0,0}$，因为没说一定要选k次，所以dp和mindp初始化全0即可 CF1969D Shop Game贪心选任意个物品，alice可以以$a_i$的价格买入,并以$b_i$的价格卖给bob，bob可以选择不超过k个物品免费拿走，bob希望alice的总收入最少，alice希望最多，问alice的最大收益是多少 对bob来说，显然他会拿走alice的物品里$b_i$最大的k个，所以我们按b从大到小排序，可以将原序列分成两部分，对于一个$i(i&gt;k)$，它左边需要选k个a最小的的让bob拿，并且其他的都不拿，右边则是a&gt;b的全拿，然后我们往右枚举这个断点并每次统计答案，左边拿一个优先队列维护前k个最小的a的和即可，右边先对$b_i-a_i$求和，然后不断减掉即可，对于左边为什么不用选超过k个，我们考虑，因为bob的行为其实是固定的，对于alice一个物品都不移除的情况，bob实际上就是选第1…k个免费拿，当断点移动到k+2的时候，如果我们不移除k+1，实际上bob还是拿1…k，而不移除k+1的情况在断点为k+1时已经计算过答案了，所以只需要保证左边留k个，其他全移除即可 CF1972A Contest Proposal暴力按题意模拟即可，答案最大不会超过n CF1972B Coin Games思维 结论n个硬币排成环，可以对朝上的硬币进行操作，若硬币数小于2则直接删除这个硬币，否则删除这个硬币的同时翻转相邻的两个硬币，无法操作的人输发现对于所有的情况，朝上的硬币数要么一次减少3个，要么减少1个，要么增加1个，所以每次操作都会改变朝上硬币数的奇偶性，最后把数量变成0，即偶数的那个人赢，所以开始朝上硬币数为奇数时alice赢，否则bob","link":"/%E6%9D%82%E9%A1%B9/acm-log/"},{"title":"[NPCCTF 2025]babyVM","text":"史vm题 ida打开main函数看到进入就是vm虚拟机 点进去发现是一个巨大的switch case循环，结构非常明显，有四个32位寄存器，其他和题目关系不大 二十多个case全部写handle去解析opcode的话难度很大，而且还要指令长度之类的问题，可以采用在指令入口点下条件断点的方式，然后动态执行整个vm，在执行指令的同时输出执行的操作，这样就可以获取vm指令的伪代码了 然后跑一遍就能拿到执行的指令了可以看到非常长，这里我同时在指令前输出了执行前寄存器的值，同时这里的下标也是处理过的，如果直接输出寄存器的值下标会非常大，用了一个python脚本对下标做了偏移让伪代码好看点 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354import reimport sysdef process_text(text): # 找出所有以 heap[938 开头的模式 pattern1 = r'heap\\[(938\\d+)\\]' matches1 = re.findall(pattern1, text) # 找出所有以 heap[1844 开头的模式 pattern2 = r'heap\\[(1844\\d+)\\]' matches2 = re.findall(pattern2, text) # 如果存在匹配项，找出最小索引值 if matches1: indices1 = [int(idx) for idx in matches1] base1 = min(indices1) # 替换heap[938...]为heap_1[offset] for idx in sorted(set(indices1), reverse=True): # 去重并从大到小替换 offset = idx - base1 text = text.replace(f'heap[{idx}]', f'heap_1[{offset}]') if matches2: indices2 = [int(idx) for idx in matches2] base2 = min(indices2) # 替换heap[1844...]为heap_2[offset] for idx in sorted(set(indices2), reverse=True): # 去重并从大到小替换 offset = idx - base2 text = text.replace(f'heap[{idx}]', f'heap_2[{offset}]') return textdef main(): # 如果有命令行参数，则读取文件 if len(sys.argv) &gt; 1: input_file = sys.argv[1] with open(input_file, 'r') as f: text = f.read() else: # 否则从标准输入读取 text = sys.stdin.read() processed_text = process_text(text) # 输出到标准输出 print(processed_text)if __name__ == &quot;__main__&quot;: main() 然后看cmp xx 48可以看出来明显有一个循环，结合各种左右移操作，猜测是tea系列的加密，于是截取一段循环抄算法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475// ------------cmp 4 48------------- // r1= 2984982102 r2= 0 r3= 4 r4= 4207947599 // r1= 2984982102 r2= 0 r3= 4 r4= 4207947599 reg3 = heap_2[56]; // heap_2[56] = 2984982102 // r1= 2984982102 r2= 0 r3= 4 r4= 2984982102 reg3 &gt;&gt;= 6; // r1= 2984982102 r2= 0 r3= 4 r4= 46640345 reg0 = heap_2[56]; // heap_2[56] = 2984982102 // r1= 2984982102 r2= 0 r3= 4 r4= 46640345 reg0 &lt;&lt;= 5; // r1= 1030146752 r2= 0 r3= 4 r4= 46640345 reg3 ^= reg0; // reg0 = 1030146752 // r1= 1030146752 r2= 0 r3= 4 r4= 1067542041 reg3 += heap_2[56]; // heap_2[56] = 2984982102 // r1= 1030146752 r2= 0 r3= 4 r4= 4052524143 reg2 = heap_2[64]; // heap_2[64] = 2610559960 // r1= 1030146752 r2= 0 r3= 2610559960 r4= 4052524143 reg2 &amp;= 3; // r1= 1030146752 r2= 0 r3= 0 r4= 4052524143 reg0 = heap_2[68]; // heap_2[68] = 164 // r1= 164 r2= 0 r3= 0 r4= 4052524143 reg2 = heap_1[0]; // heap_1[0] = 1987012675 // r1= 164 r2= 0 r3= 1987012675 r4= 4052524143 reg2 += heap_2[64]; // heap_2[64] = 2610559960 // r1= 164 r2= 0 r3= 302605339 r4= 4052524143 reg3 ^= reg2; // reg2 = 302605339 // r1= 164 r2= 0 r3= 302605339 r4= 3817207924 reg3 += heap_2[60]; // heap_2[60] = 1830509707 // r1= 164 r2= 0 r3= 302605339 r4= 1352750335 heap_2[60] = 1352750335; // r1= 164 r2= 0 r3= 302605339 r4= 1352750335 reg3 = heap_2[64]; // heap_2[64] = 2610559960 // r1= 164 r2= 0 r3= 302605339 r4= 2610559960 reg3 -= heap_2[32]; // heap_2[32] = 421101834 // r1= 164 r2= 0 r3= 302605339 r4= 2189458126 heap_2[64] = 2189458126; // r1= 164 r2= 0 r3= 302605339 r4= 2189458126 reg0 = heap_2[60]; // heap_2[60] = 1352750335 // r1= 1352750335 r2= 0 r3= 302605339 r4= 2189458126 reg0 &gt;&gt;= 7; // r1= 10568361 r2= 0 r3= 302605339 r4= 2189458126 reg2 = heap_2[60]; // heap_2[60] = 1352750335 // r1= 10568361 r2= 0 r3= 1352750335 r4= 2189458126 reg2 &lt;&lt;= 3; // r1= 10568361 r2= 0 r3= 2232068088 r4= 2189458126 reg0 ^= reg2; // reg2 = 2232068088 // r1= 2242635089 r2= 0 r3= 2232068088 r4= 2189458126 reg0 += heap_2[60]; // heap_2[60] = 1352750335 // r1= 3595385424 r2= 0 r3= 2232068088 r4= 2189458126 reg3 = heap_2[64]; // heap_2[64] = 2189458126 // r1= 3595385424 r2= 0 r3= 2232068088 r4= 2189458126 reg3 &gt;&gt;= 11; // r1= 3595385424 r2= 0 r3= 2232068088 r4= 1069071 reg3 &amp;= 3; // r1= 3595385424 r2= 0 r3= 2232068088 r4= 3 reg2 = heap_2[68]; // heap_2[68] = 164 // r1= 3595385424 r2= 0 r3= 164 r4= 3 reg3 = heap_1[12]; // heap_1[12] = 1597387639 // r1= 3595385424 r2= 0 r3= 164 r4= 1597387639 reg3 += heap_2[64]; // heap_2[64] = 2189458126 // r1= 3595385424 r2= 0 r3= 164 r4= 3786845765 reg0 ^= reg3; // reg3 = 3786845765 // r1= 939234325 r2= 0 r3= 164 r4= 3786845765 reg0 += heap_2[56]; // heap_2[56] = 2984982102 // r1= 3924216427 r2= 0 r3= 164 r4= 3786845765 heap_2[56] = 3924216427; // r1= 3924216427 r2= 0 r3= 164 r4= 3786845765 // r1= 3924216427 r2= 0 r3= 164 r4= 3786845765 reg2 = heap_2[44]; // heap_2[44] = 4 // r1= 3924216427 r2= 0 r3= 4 r4= 3786845765 reg2 += 1; // r1= 3924216427 r2= 0 r3= 5 r4= 3786845765 heap_2[44] = 5; // r1= 3924216427 r2= 0 r3= 5 r4= 3786845765 // ------------cmp 5 48------------- 123456789101112131415// key = Chovy_inkey_w36_void enc(unsigned int v0, unsigned int v1, unsigned int *key){ // heap_2[56] = v0 // heap_2[60] = v1 // heap_2[64] = sum unsigned int sum = 0; unsigned int tmp_reg3 = 0, tmp_reg2 = 0, tmp_reg0 = 0; for (int i = 0; i &lt; 48; i++) { v0 += (((v1 &gt;&gt; 6) ^ (v1 &lt;&lt; 5) )+ v1) ^ (key[sum &amp; 3] + sum); sum -= 421101834; v1 += (((v0 &gt;&gt; 7) ^ (v0 &lt;&lt; 3)) + v0) ^ (key[(sum &gt;&gt; 11) &amp; 3] + sum); }} key 的来源是 12345678910111213141516171819202122232425262728293031heap_2[0] = 67;// r1= 512 r2= 0 r3= 32 r4= 512heap_2[1] = 104;// r1= 512 r2= 0 r3= 32 r4= 512heap_2[2] = 111;// r1= 512 r2= 0 r3= 32 r4= 512heap_2[3] = 118;// r1= 512 r2= 0 r3= 32 r4= 512heap_2[4] = 121;// r1= 512 r2= 0 r3= 32 r4= 512heap_2[5] = 95;// r1= 512 r2= 0 r3= 32 r4= 512heap_2[6] = 105;// r1= 512 r2= 0 r3= 32 r4= 512heap_2[7] = 110;// r1= 512 r2= 0 r3= 32 r4= 512heap_2[8] = 107;// r1= 512 r2= 0 r3= 32 r4= 512heap_2[9] = 101;// r1= 512 r2= 0 r3= 32 r4= 512heap_2[10] = 121;// r1= 512 r2= 0 r3= 32 r4= 512heap_2[11] = 95;// r1= 512 r2= 0 r3= 32 r4= 512heap_2[12] = 119;// r1= 512 r2= 0 r3= 32 r4= 512heap_2[13] = 51;// r1= 512 r2= 0 r3= 32 r4= 512heap_2[14] = 54;// r1= 512 r2= 0 r3= 32 r4= 512heap_2[15] = 95; 其中可能在整理heap时脚本出了点问题，储存key的被错误命名成了heap2，但是还是能辨别出key 于是写解密 12345678910111213141516171819202122232425262728void dec(unsigned int *v, unsigned int *key){ unsigned int v0 = v[0]; unsigned int v1 = v[1]; unsigned int delta = 421101834; unsigned int sum = 0; for (int i = 0; i &lt; 48; i++) sum -= delta; for (int i = 0; i &lt; 48; i++) { v1 -= (((v0 &gt;&gt; 7) ^ (v0 &lt;&lt; 3)) + v0) ^ (key[(sum &gt;&gt; 11) &amp; 3] + sum); sum += delta; v0 -= (((v1 &gt;&gt; 6) ^ (v1 &lt;&lt; 5)) + v1) ^ (key[sum &amp; 3] + sum); } for (int i = 0; i &lt; 4; i++) printf(&quot;%c&quot;, ((unsigned char *)&amp;v0)[i]); for (int i = 0; i &lt; 4; i++) printf(&quot;%c&quot;, ((unsigned char *)&amp;v1)[i]);}int main(){ unsigned char key[] = &quot;Chovy_inkey_w36_&quot;; unsigned char cipher[] = &quot;\\xE5\\xDF\\xF0\\xA1\\xF4\\xBD\\x6A\\xDB\\x1B\\xE9\\xDD\\x20\\r\\x9D!YгY)\\xB9\\xEC\\x2F\\xC0\\&quot;~\\xAD\\xE1\\xB0\\x15\\xB6)&quot;; for (int i = 0; i &lt; 32; i += 8) dec((unsigned int *)&amp;cipher[i], (unsigned int *)key); return 0;} flag{D0_yOu_l1k3_VmmmmMMMMMmmm?}","link":"/ctf/WP/NPCCTF%202025%20babyVM/"},{"title":"NPCCTF 2025 base","text":"坑点非常多的题，基本涵盖了大部分windows逆向常见的对抗手法进来先是一堆花，有jz,jnz和call-ret两种，还算常规，修复完后显示main看汇编时发现有try_except块，然后发现他手动触发了一个div0错误，怀疑错误处理里藏了加密，故nop掉错误处理的jmp部分，反编译except里的代码这样就显现出了完整的main然后这道题发现不能动调，进入main后调试器就失去与程序的链接，所以去查初始化部分仔细看这个api后发现这个api并不是遇到0就截止，而是完整遍历整个区域所有的数据，遇到无效地址跳过，出题人把0x411840这个反调试函数地址藏在了下面点进去那个函数里面也有很多花，并且多了 xor ebx 后cmp ebx 再走jnz的第三种花去完后如下所示下面两个字符串是做过简单加密的，动调打在这里看解密结果(因为此时反调还没初始化完所以可以调)两个字符串解开，ntdll和ZwSetInformationThread，这样就很明显了，手动调用线程信息设置函数，看了下下面参数0x11，就是将当前线程对调试器隐藏，nop掉这个call就行，注意因为vc添加了很多栈平衡校验，所以nop时要把前面的push传参都nop干净，不然运行会报错 主函数其实思路很清晰，先魔改rc4去初始化一个映射表，然后enc进去先用映射表对输入做置换，然后又是魔改的rc4，下面三个rc4根据会根据分支的不同在加密完再和某个数进行一次异或最后暴露出的except块里的代码就是一个循环异或，直接解就行，注意到rc4虽然加了一次异或但仍是可逆的，所以可以在进入rc4前下断点，把循环异或解出的数据用patch的方式写入rc4的参数里，这样rc4跑完后就自动解开了dest同样可以动调拿到，之后只要写脚本把映射重新改回去就行了 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include &lt;bits/stdc++.h&gt;using namespace std;unsigned char dest[] = { 0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76, 0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0, 0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15, 0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75, 0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84, 0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF, 0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8, 0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2, 0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73, 0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB, 0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79, 0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08, 0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A, 0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E, 0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF, 0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16};unsigned char enc[] = { 0x78, 0xD4, 0xD5, 0x92, 0x98, 0x62, 0x14, 0x14, 0xA5, 0x0F, 0x29, 0xAE, 0x9B, 0x58, 0x14, 0x21, 0x0D, 0x7D, 0xA4, 0x66, 0x48, 0x83, 0x79, 0x30, 0xF3, 0x21, 0xD1, 0xCD, 0xE2, 0x02, 0x8D, 0xAC, 0xBC, 0x4A, 0x81, 0xC1, 0x9C, 0xF5, 0xC2, 0xC8, 0x3F, 0x0A};unsigned char ida_chars[] = { 0x33, 0x50, 0xEF, 0x85, 0x21, 0x23, 0xEF, 0x33, 0x18, 0xC7, 0x04, 0xC7, 0xEF, 0xD8, 0x23, 0x04, 0xC7, 0xEF, 0xD8, 0x18, 0xEF, 0xAA, 0x12, 0xD8, 0xEF, 0x05, 0x05, 0x18, 0xD8, 0x12, 0x04, 0xC3, 0x96, 0x9A, 0x9A, 0xFB, 0xAA, 0x12, 0x33, 0x33, 0x04, 0xFF};int main(){ for (int i = 0; i &lt; 7; i++) { enc[6 * i] ^= enc[6 * i + 5]; for (int j = 5; j &gt;= 1; j--) { enc[6 * i + j] ^= enc[6 * i + j - 1]; } } for (int i = 0; i &lt; 42; i++) { if (i % 16 == 0) printf(&quot;\\n&quot;); printf(&quot;%02X &quot;, enc[i]); } for (int i = 0; i &lt; 42; i++) { for (int j = 0; j &lt; 256; j++) { if (dest[j] == ida_chars[i]) { printf(&quot;%c&quot;, j); break; } } } return 0;} flag{2af4101a-201a-4ab9-a664-903577cb9ff0}","link":"/ctf/WP/NPCCTF%202025%20base/"},{"title":"NPCCTF 2025 ezMobile","text":"简单dex壳 进来主类里直接看到一个经典dex壳，这个壳是吧加密过的dex扔进native函数里解密，然后用InMemoryDexClassLoader动态加载我们直接hook这个change,拿到返回值后直接写进入文件获得dex 12345678910def onMessage(message, data): if message['type'] == 'send': print(&quot;[!!] Message from target: &quot;, message['payload']) for i in range(len(message['payload'])): if message['payload'][i] &lt; 0: message['payload'][i] += 256 with open(&quot;class.dex&quot;, &quot;wb&quot;) as f: f.write(bytes(message['payload'])) else: print(&quot;Not a send type Message&quot;, message['stack']) 123456let MainActivity = Java.use(&quot;ctf.myapplication.MainActivity&quot;);MainActivity[&quot;change&quot;].implementation = function (bArr) { let result = this[&quot;change&quot;](bArr); send(result) return result;}; 拿到dex后打开看加密就是一个xxtea加一个base64，base64检查过后发现就是默认表，xxtea魔改了MX和delta，所以手动写xxtea脚本，key是放在native里的，可以直接hook encrypt的参数获取 1FlagChecker.encrypt is called: data=qweery, key=882059e204adefc5 xxtea脚本如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#include &lt;bits/stdc++.h&gt;using namespace std;#define MX (((z &gt;&gt; 5) ^ (y &lt;&lt; 2)) + ((y &gt;&gt; 3) ^ (z &lt;&lt; 4))) ^ ((sum ^ y) + (k[(p &amp; 3) ^ e] ^ z))void xxteaEncrtpy(uint32_t *v, size_t n, uint32_t *k){ uint32_t y, z, sum; uint32_t p, rounds, e; uint32_t delta = -1640531527; rounds = 6 + 52 / n; sum = 0; z = v[n - 1]; do { sum += delta; e = (sum &gt;&gt; 2) &amp; 3; // 引入非线性计算，使得每次取出的key值缺少规律 for (p = 0; p &lt; n - 1; p++) { y = v[p + 1]; z = v[p] += MX; // 每个块加密是增加的偏移量实际上由上一个块(z)和下一个块(y)的值和sum共同决定 } y = v[0]; // 此处其实是循环加密的端点，当然可以对下标取模写进循环里 z = v[n - 1] += MX; } while (--rounds); // 实际上是把相同的操作重复round轮}void xxteaDecrypt(uint32_t *v, size_t n, uint32_t *k){ uint32_t y, z, sum; uint32_t p, rounds, e; uint32_t delta = -1640531527; rounds = 6 + 52 / n; sum = rounds * delta; y = v[0]; // n-1号块的下一个块是0号块 do { e = (sum &gt;&gt; 2) &amp; 3; for (p = n - 1; p &gt; 0; p--) // 反向循环 { z = v[p - 1]; // 因为是反着循环，所以这里是上一个块 y = v[p] -= MX; // 这里是也是取上一个和下一个块的值作为参数 } z = v[n - 1]; // 0号块的上一个块是n-1号块 y = v[0] -= MX; sum -= delta; } while (--rounds);}int main(){ // 882059e204adefc5 char k[] = &quot;882059e204adefc5&quot;; // uint32_t k[4] = {0x01234567, 0x89abcdef, 0xfedcba98, 0x76543210}; unsigned char v[] = {0x61, 0x80, 0x8a, 0x2d, 0x69, 0x52, 0x27, 0xdc, 0x78, 0x95, 0x85, 0x66, 0xee, 0x2a, 0xa5, 0x1e, 0xdf, 0xc4, 0x5e, 0xf8, 0x1a, 0x84, 0x4a, 0x0a, 0x11, 0xed, 0x9d, 0x97, 0x40, 0x67, 0x46, 0x61, 0xa1, 0x35, 0x0f, 0x4a, 0x84, 0xf5, 0xd8, 0x79, 0xfd, 0xc4, 0xa9, 0xb8}; xxteaDecrypt((uint32_t *)v, 11, (uint32_t *)k); for (int i = 0; i &lt; 44; i++) printf(&quot;%c&quot;, v[i]); printf(&quot;\\n&quot;); return 0;} flag{AnDr01d_r3v3rs3_jUcYuWzBSSOwKxbMD}","link":"/ctf/WP/NPCCTF%202025%20ezMobile/"},{"title":"NPCCTF 2025 randomXor","text":"简单伪随机 打开看了下main，看起来是很简单的伪随机，但是随机数算法是出题人自制的，而且是arm架构题目，不能用frida hook，所以考虑用模拟执行获取rand的结果我们在调用srand的代码块进入，然后随便找一个加密完的位置作为结束的位置因为bn有非常方便的读取段数据的api，所以直接把所有段都读进去 12345678910111213141516171819202122232425262728293031323334353637383940414243444546from unicorn import *from unicorn.arm64_const import *from binaryninja import *def hook_code(uc, address, size, user_data): bv = user_data[&quot;bv&quot;] assert isinstance(bv, BinaryView) if address == 0xbc8: print(&quot;w0 = {} w1 ={}&quot;.format(uc.reg_read( UC_ARM64_REG_W0), uc.reg_read(UC_ARM64_REG_W1))) global rd rd.append(uc.reg_read(UC_ARM64_REG_W0)) if address == 0xbdc: print(&quot;addr = {}&quot;.format(uc.reg_read(UC_ARM64_REG_X0) + uc.reg_read(UC_ARM64_REG_X1)))CODE_BASE = 0x0CODE_SIZE = 0x20000STACK_BASE = 0x10000000STACK_SIZE = 0x10000uc = Uc(UC_ARCH_ARM64, UC_MODE_ARM)uc.mem_map(CODE_BASE, CODE_SIZE, UC_PROT_ALL)uc.mem_map(STACK_BASE, STACK_SIZE, UC_PROT_ALL)uc.hook_add(UC_HOOK_CODE, hook_code, user_data={&quot;bv&quot;: bv})rd = []for segment in bv.segments: if segment.readable: start = segment.start end = segment.end size = end-start print(&quot;[+] Mapping segment: [{}]&quot;.format(hex(segment.start))) content = bv.read(start, size) uc.mem_write(start, content)addr = 0xb98addrEnd = 0xc18stack_top = STACK_BASE + STACK_SIZE - 0x100uc.reg_write(UC_ARM64_REG_SP, stack_top)uc.mem_write(stack_top, b&quot;\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00&quot;)uc.emu_start(addr, addrEnd)print(rd)uc.emu_stop() 0xbc8执行的了xor操作，我们在这个位置设置hook，读取w0就能直接拿到随机数 之后直接解密即可 123456789101112131415161718192021rd = [171, 171, 131, 225, 65, 75, 141, 216, 149, 238, 40, 235, 196, 132, 99, 176, 132, 203, 140, 159, 82, 45, 47, 112, 202, 233, 239, 208, 231, 132, 45, 46, 58, 242, 229, 224, 106, 121, 228, 112, 174, 107, 227, 40, 64, 239, 178, 108, 13, 68, 255, 143, 243, 74, 108, 95, 141, 203, 193, 122, 195, 218, 187, 40, 108, 174, 244, 32, 167, 107, 104, 52, 90, 201, 121, 99, 142, 99, 227, 128, 118, 224, 188, 142, 131, 33, 128, 109, 35, 105, 191, 19, 47, 225, 46, 183, 46, 200, 18, 38, 243, 17, 216, 185, 181, 68, 240, 165, 25, 104, 56, 165, 154, 91, 88, 2, 209, 171, 137, 112, 59, 9, 149, 238, 1, 40, 165, 243]cipher = [0xCD, 0xC7, 0xE2, 0x86, 0x3A, 0x19, 0xB9, 0xB6, 0xF1, 0x81, 0x45, 0xB4, 0xB6, 0xE5, 0x0D, 0xD4, 0xB4, 0xA6, 0xD3, 0xF7, 0x33, 0x5D, 0x5F, 0x09, 0x95, 0xAF, 0x9A, 0xBE, 0x89, 0xEA, 0x54, 0x71, 0x68, 0xC6, 0x8B, 0x84, 0x05, 0x14, 0xBB, 0x41, 0xDD, 0x34, 0x91, 0x1B, 0x21, 0x83, 0xDE, 0x15, 0x52, 0x22, 0x8A, 0xE1, 0xBD, 0x33, 0x4D, 0x7E, 0xD2, 0xA3, 0xA9, 0x12, 0xF1, 0xE9, 0x88, 0x60, 0x24, 0xE6, 0xAB, 0x54, 0xCF, 0x02, 0x1B, 0x6B, 0x6B, 0xBA, 0x26, 0x09, 0xFB, 0x10, 0x97, 0xDF, 0x17, 0xBF, 0xCC, 0xE7, 0xB0, 0x42, 0xE5, 0x32, 0x4C, 0x0F, 0xE0, 0x60, 0x47, 0xD0, 0x5A, 0xE8, 0x48, 0xAE, 0x74, 0x4D, 0x98, 0x7A, 0xB3, 0xD2, 0xDE, 0x1B, 0x96, 0x91, 0x7A, 0x03, 0x67, 0xCF, 0xF0, 0x31, 0x32, 0x49, 0x9A, 0xE0, 0xC2, 0x3B, 0x51, 0x63, 0xFF, 0x84, 0x60, 0x5B, 0xC1, 0x8E]print(len(rd))for i in range(0, 128): print(chr(cipher[i] ^ rd[i]), end='') flag{R4ndom_rand0m_happy_Funnny_R4ndom_1s_r3ally_funNy!!_hhh233HHH_this_1s_just_a_pi3ce_of_sh1t_fffkkkkkk_f4ck_jjjjKKKKKjjjjasd}","link":"/ctf/WP/NPCCTF%202025%20randomXor/"},{"title":"TGCTF 2025 RE部分WP","text":"re部分除了最后一道index都做了，index附件本身都跑不起来，而且wasm不好玩，不补了 水果忍者点进去直接就写明白了，iv，key和密文直接就有，cyberchef直接解HZNUCTF{de20-70dd-4e62-b8d0-06e} 蛇年的本命语言1先拿把exe解压一下拿到pyc变量名混淆过，先整理一下明显的z3，上面那个仔细观察后发现每个数字都对应一种字符的出现次数，结合z3求解 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115from z3 import *# v = [Int('v%d' % i) for i in range(6)]final = [BitVec('final[%d]' % i, 8) for i in range(30)]S = Solver()mes = r&quot;H1Z1N1U1C1T1F1{1a6b2c5d7e4f3}1&quot;for i in range(1, 30, 2): S.add(final[i] == ord(mes[i])) print(mes[i])S.add([ 7 * final[0] == 504, 9 * final[0] - 5 * final[1] == 403, (2 * final[0] - 5 * final[1]) + 10 * final[2] == 799, 3 * final[0] + 8 * final[1] + 15 * final[2] + 20 * final[3] == 2938, (5 * final[0] + 15 * final[1] + 20 * final[2] - 19 * final[3]) + 1 * final[4] == 2042, (7 * final[0] + 1 * final[1] + 9 * final[2] - 11 * final[3]) + 2 * final[4] + 5 * final[5] == 1225, 11 * final[0] + 22 * final[1] + 33 * final[2] + 44 * final[3] + 55 * final[4] + 66 * final[5] - 77 * final[6] == 7975, ((21 * final[0] + 23 * final[1] + 3 * final[2] + 24 * final[3] - 55 * final[4]) + 6 * final[5] - 7 * final[6]) + 15 * final[7] == 229, (2 * final[0] + 26 * final[1] + 13 * final[2] + 0 * final[3] - 65 * final[4] ) + 15 * final[5] + 29 * final[6] + 1 * final[7] + 20 * final[8] == 2107, (10 * final[0] + 7 * final[1] + -9 * final[2] + 6 * final[3] + 7 * final[4] + 1 * final[5] + 22 * final[6] + 21 * final[7] - 22 * final[8]) + 30 * final[9] == 4037, (15 * final[0] + 59 * final[1] + 56 * final[2] + 66 * final[3] + 7 * final[4] + 1 * final[5] - 122 * final[6]) + 21 * final[7] + 32 * final[8] + 3 * final[9] - 10 * final[10] == 4950, (((13 * final[0] + 66 * final[1] + 29 * final[2] + 39 * final[3] - 33 * final[4]) + 13 * final[5] - 2 * final[6]) + 42 * final[7] + 62 * final[8] + 1 * final[9] - 10 * final[10]) + 11 * final[11] == 12544, (((23 * final[0] + 6 * final[1] + 29 * final[2] + 3 * final[3] - 3 * final[4]) + 63 * final[5] - 25 * final[6] ) + 2 * final[7] + 32 * final[8] + 1 * final[9] - 10 * final[10]) + 11 * final[11] - 12 * final[12] == 6585, ((((223 * final[0] + 6 * final[1] - 29 * final[2] - 53 * final[3] - 3 * final[4]) + 3 * final[5] - 65 * final[6]) + 0 * final[7] + 36 * final[8] + 1 * final[9] - 15 * final[10]) + 16 * final[11] - 18 * final[12]) + 13 * final[13] == 6893, ((((29 * final[0] + 13 * final[1] - 9 * final[2] - 93 * final[3]) + 33 * final[4] + 6 * final[5] + 65 * final[6] + 1 * final[7] - 36 * final[8]) + 0 * final[9] - 16 * final[10]) + 96 * final[11] - 68 * final[12]) + 33 * final[13] - 14 * final[14] == 1883, (((69 * final[0] + 77 * final[1] - 93 * final[2] - 12 * final[3]) + 0 * final[4] + 0 * final[5] + 1 * final[6] + 16 * final[7] + 36 * final[8] + 6 * final[9] + 19 * final[10] + 66 * final[11] - 8 * final[12]) + 38 * final[13] - 16 * final[14]) + 15 * final[15] == 8257, ((((23 * final[0] + 2 * final[1] - 3 * final[2] - 11 * final[3]) + 12 * final[4] + 24 * final[5] + 1 * final[6] + 6 * final[7] + 14 * final[8] - 0 * final[9]) + 1 * final[10] + 68 * final[11] - 18 * final[12]) + 68 * final[13] - 26 * final[14]) + 15 * final[15] - 16 * final[16] == 5847, (((((24 * final[0] + 0 * final[1] - 1 * final[2] - 15 * final[3]) + 13 * final[4] + 4 * final[5] + 16 * final[6] + 67 * final[7] + 146 * final[8] - 50 * final[9]) + 16 * final[10] + 6 * final[11] - 1 * final[12]) + 69 * final[13] - 27 * final[14]) + 45 * final[15] - 6 * final[16]) + 17 * final[17] == 18257, ((((25 * final[0] + 26 * final[1] - 89 * final[2]) + 16 * final[3] + 19 * final[4] + 44 * final[5] + 36 * final[6] + 66 * final[7] - 150 * final[8] - 250 * final[9] ) + 166 * final[10] + 126 * final[11] - 11 * final[12]) + 690 * final[13] - 207 * final[14]) + 46 * final[15] + 6 * final[16] + 7 * final[17] - 18 * final[18] == 12591, (((((5 * final[0] + 26 * final[1] + 8 * final[2] + 160 * final[3] + 9 * final[4] - 4 * final[5]) + 36 * final[6] + 6 * final[7] - 15 * final[8] - 20 * final[9]) + 66 * final[10] + 16 * final[11] - 1 * final[12]) + 690 * final[13] - 20 * final[14]) + 46 * final[15] + 6 * final[16] + 7 * final[17] - 18 * final[18]) + 19 * final[19] == 52041, ((((((29 * final[0] - 26 * final[1]) + 0 * final[2] + 60 * final[3] + 90 * final[4] - 4 * final[5]) + 6 * final[6] + 6 * final[7] - 16 * final[8] - 21 * final[9]) + 69 * final[10] + 6 * final[11] - 12 * final[12]) + 69 * final[13] - 20 * final[14] - 46 * final[15]) + 65 * final[16] + 0 * final[17] - 1 * final[18]) + 39 * final[19] - 20 * final[20] == 20253, (((((((45 * final[0] - 56 * final[1]) + 10 * final[2] + 650 * final[3] - 900 * final[4]) + 44 * final[5] + 66 * final[6] - 6 * final[7] - 6 * final[8] - 21 * final[9]) + 9 * final[10] - 6 * final[11] - 12 * final[12]) + 69 * final[13] - 2 * final[14] - 406 * final[15]) + 651 * final[16] + 2 * final[17] - 10 * final[18]) + 69 * final[19] - 0 * final[20]) + 21 * final[21] == 18768, (((((555 * final[0] - 6666 * final[1]) + 70 * final[2] + 510 * final[3] - 90 * final[4]) + 499 * final[5] + 66 * final[6] - 66 * final[7] - 610 * final[8] - 221 * final[9]) + 9 * final[10] - 23 * final[11] - 102 * final[12]) + 6 * final[13] + 2050 * final[14] - 406 * final[15]) + 665 * final[16] + 333 * final[17] + 100 * final[18] + 609 * final[19] + 777 * final[20] + 201 * final[21] - 22 * final[22] == 111844, (((((((1 * final[0] - 22 * final[1]) + 333 * final[2] + 4444 * final[3] - 5555 * final[4]) + 6666 * final[5] - 666 * final[6]) + 676 * final[7] - 660 * final[8] - 22 * final[9]) + 9 * final[10] - 73 * final[11] - 107 * final[12]) + 6 * final[13] + 250 * final[14] - 6 * final[15]) + 65 * final[16] + 39 * final[17] + 10 * final[18] + 69 * final[19] + 777 * final[20] + 201 * final[21] - 2 * final[22]) + 23 * final[23] == 159029, (((520 * final[0] - 222 * final[1]) + 333 * final[2] + 4 * final[3] - 56655 * final[4]) + 6666 * final[5] + 666 * final[6] + 66 * final[7] - 60 * final[8] - 220 * final[9]) + 99 * final[10] + 73 * final[11] + 1007 * final[12] + 7777 * final[13] + 2500 * final[14] + 6666 * final[15] + 605 * final[16] + 390 * final[17] + 100 * final[18] + 609 * final[19] + 99999 * final[20] + 210 * final[21] + 232 * final[22] + 23 * final[23] - 24 * final[24] == 2762025, ((((1323 * final[0] - 22 * final[1]) + 333 * final[2] + 4 * final[3] - 55 * final[4]) + 666 * final[5] + 666 * final[6] + 66 * final[7] - 660 * final[8] - 220 * final[9]) + 99 * final[10] + 3 * final[11] + 100 * final[12] + 777 * final[13] + 2500 * final[14] + 6666 * final[15] + 605 * final[16] + 390 * final[17] + 100 * final[18] + 609 * final[19] + 9999 * final[20] + 210 * final[21] + 232 * final[22] + 23 * final[23] - 24 * final[24]) + 25 * final[25] == 1551621, (((((777 * final[0] - 22 * final[1]) + 6969 * final[2] + 4 * final[3] - 55 * final[4]) + 666 * final[5] - 6 * final[6]) + 96 * final[7] - 60 * final[8] - 220 * final[9]) + 99 * final[10] + 3 * final[11] + 100 * final[12] + 777 * final[13] + 250 * final[14] + 666 * final[15] + 65 * final[16] + 90 * final[17] + 100 * final[18] + 609 * final[19] + 999 * final[20] + 21 * final[21] + 232 * final[22] + 23 * final[23] - 24 * final[24]) + 25 * final[25] - 26 * final[26] == 948348, ((((((97 * final[0] - 22 * final[1]) + 6969 * final[2] + 4 * final[3] - 56 * final[4]) + 96 * final[5] - 6 * final[6]) + 96 * final[7] - 60 * final[8] - 20 * final[9]) + 99 * final[10] + 3 * final[11] + 10 * final[12] + 707 * final[13] + 250 * final[14] + 666 * final[15] + -9 * final[16] + 90 * final[17] + -2 * final[18] + 609 * final[19] + 0 * final[20] + 21 * final[21] + 2 * final[22] + 23 * final[23] - 24 * final[24]) + 25 * final[25] - 26 * final[26]) + 27 * final[27] == 777044, (((((177 * final[0] - 22 * final[1]) + 699 * final[2] + 64 * final[3] - 56 * final[4] - 96 * final[5] - 66 * final[6]) + 96 * final[7] - 60 * final[8] - 20 * final[9]) + 99 * final[10] + 3 * final[11] + 10 * final[12] + 707 * final[13] + 250 * final[14] + 666 * final[15] + -9 * final[16] + 0 * final[17] + -2 * final[18] + 69 * final[19] + 0 * final[20] + 21 * final[21] + 222 * final[22] + 23 * final[23] - 224 * final[24]) + 25 * final[25] - 26 * final[26]) + 27 * final[27] - 28 * final[28] == 185016, ((((((77 * final[0] - 2 * final[1]) + 6 * final[2] + 6 * final[3] - 96 * final[4] - 9 * final[5] - 6 * final[6]) + 96 * final[7] - 0 * final[8] - 20 * final[9]) + 99 * final[10] + 3 * final[11] + 10 * final[12] + 707 * final[13] + 250 * final[14] + 666 * final[15] + -9 * final[16] + 0 * final[17] + -2 * final[18] + 9 * final[19] + 0 * final[20] + 21 * final[21] + 222 * final[22] + 23 * final[23] - 224 * final[24]) + 26 * final[25] - -58 * final[26]) + 27 * final[27] - 2 * final[28]) + 29 * final[29] == 130106])if S.check() == sat: ans = S.model() print(ans) print(ans[final[14]].as_long()) for i in range(30): print(chr(ans[final[i]].as_long()), end=&quot;&quot;)# 1U1C1T1F1{1 a6 d2 75 f7 46 3 }1finalans = [0 for i in range(30)]finalans[0] = 72finalans[1] = 49finalans[2] = 90finalans[3] = 49finalans[4] = 78finalans[5] = 49finalans[6] = 85finalans[7] = 49finalans[8] = 67finalans[9] = 49finalans[10] = 84finalans[11] = 49finalans[12] = 70finalans[13] = 49finalans[14] = 123finalans[15] = 49finalans[16] = 97finalans[17] = 54finalans[18] = 100finalans[19] = 50finalans[20] = 55finalans[21] = 53finalans[22] = 102finalans[23] = 55finalans[24] = 13finalans[25] = 52finalans[26] = 54finalans[27] = 51finalans[28] = 125finalans[29] = 49for i in range(30): print(chr(finalans[i]), end=&quot;&quot;)# H1Z1N1U1C1T1F1{1 a6 d2 75 f7 x4 63}1 解完后发现出现4次的字符对应的是不可见字符，可能是z3有多解，尝试爆破，试出来那个位置还有一种解是-HZNUCTF{ad7fa-76a7-ff6a-fffa-7f7d6a} randomsystem点开有花，拿脚本去一去 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758from binaryninja import *import bisectdef matchPatterns(idx: int, bv: BinaryView, instructions: List[Tuple[List[InstructionTextToken], int]], address: List[int]): curInstruction = instructions[idx] if curInstruction[0][0].text == 'jz': # jz jnz if idx + 1 &lt; len(instructions): nextInstruction = instructions[idx + 1] if nextInstruction[0][0].text == 'jnz': if curInstruction[0][2].text == nextInstruction[0][2].text: # print(curInstruction[0], nextInstruction[0]) print(&quot;find jz jnz&quot;) return (curInstruction[1], curInstruction[0][2].value-1) if curInstruction[0][0].text == 'jnz': # jnz jz if idx + 1 &lt; len(instructions): nextInstruction = instructions[idx + 1] if nextInstruction[0][0].text == 'jz': if curInstruction[0][2].text == nextInstruction[0][2].text: # print(curInstruction[0], nextInstruction[0]) print(&quot;find jnz jz&quot;) return (curInstruction[1], curInstruction[0][2].value-1) if curInstruction[0][0].text == 'call': # call-return nextInstructionAddr = instructions[idx + 1][1] # print(curInstruction[0]) if len(curInstruction[0][2].text) and curInstruction[0][2].text[0] == '$': idx = find_instruction_idx(address, curInstruction[0][2].value) if idx != None: callInstruction: List[InstructionTextToken] = instructions[idx][0] if callInstruction[0].text == 'add' and len(callInstruction) == 11 and (callInstruction[8].text == r'%esp' or callInstruction[8].text == r'%rsp'): print(&quot;find call-return&quot;) print(&quot;nextInstructionAddr&quot;, nextInstructionAddr) print(&quot;callInstructionOffset&quot;, callInstruction[2].value) return (curInstruction[1], nextInstructionAddr+callInstruction[2].value-1)def find_instruction_idx(address, addr: int): # print(addr) idx = bisect.bisect_left(address, addr) # 二分说是 if idx &lt; len(address) and addr == address[idx]: return idx else: return Nonedef scanAllInstruction(bv: BinaryView): instructions = [ins for ins in bv.instructions] instructions = sorted(instructions, key=lambda x: x[1]) address = [addr[1] for addr in instructions] for i in range(0, len(instructions)): nopRange = matchPatterns(i, bv, instructions, address) if nopRange: bv.write(nopRange[0], b'\\x90' * (nopRange[1] - nopRange[0] + 1)) print(f&quot;Found NOP range: {hex(nopRange[0])} to {hex(nopRange[1])}&quot;)scanAllInstruction(bv) 点开里面一大坨，但发现前面乱七八杂糟的都在初始化dest这个量，而这个量的预期值直接明文给出了，直接动调patch进入下面的逻辑下面那个rand也不看，反正都是初始化，动调抓最后是一个异或，key直接动调拿到倒数第二个是一个矩阵乘，用z3反解 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475from z3 import *# v = [Int('v%d' % i) for i in range(6)]final = [Int('final[%d]' % i) for i in range(64)]S = Solver()S.add(298 == final[0] + final[8] + final[24] + final[48])S.add(257 == final[1] + final[9] + final[25] + final[49])S.add(255 == final[2] + final[10] + final[26] + final[50])S.add(400 == final[3] + final[11] + final[27] + final[51])S.add(327 == final[4] + final[12] + final[28] + final[52])S.add(300 == final[5] + final[13] + final[29] + final[53])S.add(216 == final[6] + final[14] + final[30] + final[54])S.add(307 == final[7] + final[15] + final[31] + final[55])S.add(302 == final[8] + final[16] + final[40] + final[56])S.add(264 == final[9] + final[17] + final[41] + final[57])S.add(244 == final[10] + final[18] + final[42] + final[58])S.add(359 == final[11] + final[19] + final[43] + final[59])S.add(303 == final[12] + final[20] + final[44] + final[60])S.add(310 == final[13] + final[21] + final[45] + final[61])S.add(264 == final[14] + final[22] + final[46] + final[62])S.add(342 == final[15] + final[23] + final[47] + final[63])S.add(341 == final[16] + final[24] + final[40] + final[48])S.add(258 == final[17] + final[25] + final[41] + final[49])S.add(244 == final[18] + final[26] + final[42] + final[50])S.add(385 == final[19] + final[27] + final[43] + final[51])S.add(356 == final[20] + final[28] + final[44] + final[52])S.add(296 == final[21] + final[29] + final[45] + final[53])S.add(265 == final[22] + final[30] + final[46] + final[54])S.add(310 == final[23] + final[31] + final[47] + final[55])S.add(196 == final[24] + final[40] + final[56])S.add(167 == final[25] + final[41] + final[57])S.add(249 == final[26] + final[42] + final[58])S.add(317 == final[27] + final[43] + final[59])S.add(204 == final[28] + final[44] + final[60])S.add(159 == final[29] + final[45] + final[61])S.add(211 == final[30] + final[46] + final[62])S.add(202 == final[31] + final[47] + final[63])S.add(204 == final[8] + final[32] + final[48])S.add(200 == final[9] + final[33] + final[49])S.add(206 == final[10] + final[34] + final[50])S.add(286 == final[11] + final[35] + final[51])S.add(204 == final[12] + final[36] + final[52])S.add(321 == final[13] + final[37] + final[53])S.add(209 == final[14] + final[38] + final[54])S.add(264 == final[15] + final[39] + final[55])S.add(151 == final[40] + final[56])S.add(113 == final[41] + final[57])S.add(147 == final[42] + final[58])S.add(196 == final[43] + final[59])S.add(148 == final[44] + final[60])S.add(111 == final[45] + final[61])S.add(156 == final[46] + final[62])S.add(145 == final[47] + final[63])S.add(152 == final[48] + final[56])S.add(107 == final[49] + final[57])S.add(154 == final[50] + final[58])S.add(213 == final[51] + final[59])S.add(147 == final[52] + final[60])S.add(154 == final[53] + final[61])S.add(112 == final[54] + final[62])S.add(98 == final[55] + final[63])S.add(204 == final[8] + final[16] + final[56])S.add(208 == final[9] + final[17] + final[57])S.add(199 == final[10] + final[18] + final[58])S.add(260 == final[11] + final[19] + final[59])S.add(203 == final[12] + final[20] + final[60])S.add(256 == final[13] + final[21] + final[61])S.add(165 == final[14] + final[22] + final[62])S.add(242 == final[15] + final[23] + final[63])if S.check() == sat: ans = S.model() # print(ans) for i in range(64): print(chr(ans[final[i]].as_long()), end=&quot;&quot;) 解出fd11v56d454r6f4acb-1ea8d-6fy80795af83zfrb8-cd6cdc24tca7559fa099-再往前就是交换混淆，这个直接往里面输入1，2，3，4，5…爆破交换映射然后重新映射回去即可解出flag 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;bits/stdc++.h&gt;using namespace std;int enc[] = {376, 356, 169, 501, 277, 329, 139, 342, 380, 365, 162, 258, 381, 339, 347, 307, 263, 359, 162, 484, 310, 333, 346, 339, 150, 194, 175, 344, 158, 250, 128, 175, 158, 173, 152, 379, 158, 292, 130, 365, 197, 20, 197, 161, 198, 10, 207, 244, 202, 14, 204, 176, 193, 255, 35, 7, 158, 181, 145, 353, 153, 357, 246, 151};unsigned char key[] = { 0x52, 0x65, 0x56, 0x65, 0x52, 0x65, 0x53, 0x65};int dw[64] = {1, 1, 0, 1, 0, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 1};int main(){ for (int i = 0; i &lt; 64; i++) { enc[i] ^= key[i % 8]; // get final } int k; // [esp+D0h] [ebp-20h] int j; // [esp+DCh] [ebp-14h] int i; // [esp+E8h] [ebp-8h] // for (i = 0; i &lt; 8; ++i) // { // for (j = 0; j &lt; 8; ++j) // { // // final[8 * i + j] = 0; // printf(&quot;S.add(%d == &quot;, enc[8 * i + j]); // for (k = 0; k &lt; 8; ++k) // if (dw[8 * i + k]) // { // printf(&quot;final[%d] +&quot;, 8 * k + j); // } // printf(&quot;)\\n&quot;); // // final[8 * i + j] += intDest[8 * k + j] * dw[8 * i + k]; // } // // result = i + 1; // } unsigned char mappingTable[] = { 37, 38, 39, 41, 36, 63, 58, 54, 44, 57, 49, 50, 33, 46, 45, 43, 55, 34, 42, 40, 56, 62, 35, 61, 52, 53, 47, 48, 64, 51, 59, 60, 13, 18, 23, 5, 1, 2, 3, 20, 4, 19, 16, 9, 15, 14, 27, 28, 11, 12, 30, 25, 26, 8, 17, 21, 10, 7, 31, 32, 24, 22, 6, 29}; char final[] = &quot;fd11v56d454r6f4acb-1ea8d-6fy80795af83zfrb8-cd6cdc24tca7559fa099-&quot;; char ans[65]; for (int i = 1; i &lt;= 64; i++) { ans[i] = final[mappingTable[i - 1] - 1]; } for (int i = 1; i &lt;= 64; i++) printf(&quot;%c&quot;, ans[i]); return 0; // fd11v56d454r6f4acb-1ea8d-6fy80795af83zfrb8-cd6cdc24tca7559fa099-} HZNUCTF{3zfb899ac5c256d-7a8r59f0tccd-4fa6b8vfd111-a44ffy4r0-6dce5679da58} exchange打开有一个很奇怪的算法，对比下输入输出可以看到是把输入以4个16进制位为一组，交换中间的两位并转字符串里面就是很明显的一个des，findCrypto可以找到盒然后这个des是魔改过的，工具没法解，众所周知Fesitel网络密码只要把轮函数反过来跑就能解密，des就是把key倒过来用动调抓一下key，发现这个key似乎是对称的，而且组数也太多了点，合理怀疑这是一个加解密一体的算法，后半部分就是解密用的反key直接把key的指针+32 (看一下当前传参时key的地址通过哪个寄存器转递，直接改寄存器值)然后把密文patch进输入里跑可以看到跑出来的结果十分好看然后写脚本把换位改回去转成hex 123456789char mes[] = &quot;333936147332632923d96353321d3345636826d26314621d3349330463126348&quot;; for (int i = 0; i &lt; 64; i += 4) { swap(mes[i + 1], mes[i + 2]); } for (int i = 0; i &lt; 64; i += 2) { printf(&quot;%c%c &quot;, mes[i], mes[i + 1]); } 直接解出 xteacbc模式的xtea，直接进去抄源码注意到这里有一个反调试，如果直接动调拿key的话种子不对写脚本 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;bits/stdc++.h&gt;using namespace std;void xteaDecrypt(uint32_t *v_0, uint32_t *v_1, uint32_t *k){ uint32_t sum = 0; // printf(&quot;%u %u\\n&quot;, v0, v1); uint32_t v0 = *v_0; uint32_t v1 = *v_1; uint32_t delta = 2654435769u; for (int i = 0; i &lt; 32; i++) sum -= delta; for (int i = 0; i &lt; 32; i++) { v1 -= (k[(sum &gt;&gt; 11) &amp; 3] + sum) ^ (v0 + ((v0 &gt;&gt; 5) ^ (16 * v0))); sum += delta; v0 -= (k[sum &amp; 3] + sum) ^ (v1 + ((v1 &gt;&gt; 5) ^ (16 * v1))); } *v_0 = v0; *v_1 = v1;}int main(){ srand(0x7e8); uint32_t key[4] = {6651, 15290, 20313, 4631}; for (int i = 0; i &lt; 4; i++) key[i] = rand(); uint32_t enc[8] = { 2362123044u, 161969178u, 4215039885u, 4127734393u, 4056687643u, 972708338u, 4071350732u, 387489650u}; for (int j = 6; j &gt;= 0; j--) xteaDecrypt(&amp;enc[j], &amp;enc[j + 1], key); for (int j = 0; j &lt; 32; j += 4) { for (int i = j + 3; i &gt;= j; i--) printf(&quot;%c&quot;, ((char *)enc)[i]); } return 0;} HZNUCTF{ae6-9f57-4b74-b423-98eb} conforanddie检测有ollvm，先尝试用d810解一下解完还是很丑，每个函数都有几百行，但是出题人没删符号表，定位几个关键点众所周知rc4跑两次等于没跑，所以我们尝试用frida去手动调用rc4检查initbox的部分，发现引入了随机数种子，且种子未给出但注意到这个随机数的范围被限定在了0~255(S盒里的元素是uint8)，且rand只调用了这一次所以我们可以hook rand的返回值，爆破所有情况写frida脚本 123456789101112131415161718192021222324252627282930313233343536var lib = Process.findModuleByName(&quot;conforand&quot;);var sym = lib.enumerateSymbols();for (var i = 0; i &lt; sym.length; i++) { console.log(sym[i].name);}var randPtr = Module.findExportByName(&quot;libc.so.6&quot;, &quot;rand&quot;);console.log(&quot;randPtr: &quot; + randPtr);var rc4Ptr = lib.findSymbolByName(&quot;rc4&quot;);var rand = new NativeFunction(randPtr, 'int', []);var rc4 = new NativeFunction(rc4Ptr, 'void', ['pointer', 'int', 'pointer', 'int']);var rc4Key = Memory.alloc(9);rc4Key.writeUtf8String(&quot;JustDoIt!&quot;);let randRet = 0Interceptor.attach(randPtr, { onLeave: function (retval) { retval.replace(randRet); }})for (let i = 0; i &lt; 256; i++) { randRet = i; // console.log(rand()); var Input = Memory.alloc(42); Input.writeByteArray([0x83, 0x1e, 0x9c, 0x48, 0x7a, 0xfa, 0xe8, 0x88, 0x36, 0xd5, 0x0a, 0x08, 0xf6, 0xa7, 0x70, 0x0f, 0xfd, 0x67, 0xdd, 0xd4, 0x3c, 0xa7, 0xed, 0x8d, 0x51, 0x10, 0xce, 0x6a, 0x9e, 0x56, 0x57, 0x83, 0x56, 0xe7, 0x67, 0x9a, 0x67, 0x22, 0x24, 0x6e, 0xcd, 0x2f]); rc4(Input, 42, rc4Key, 9); try { console.log(Input.readUtf8String(41)); } catch (e) { console.log(&quot;Error: &quot; + e); }} 123456789101112131415161718192021222324252627282930313233343536import fridaimport sysimport timedef onMessage(message, data): if message['type'] == 'send': print(&quot;[!!] Message from target: &quot;, message['payload']) else: print(&quot;Not a send type Message&quot;, message['stack'])with open('FridaScript.js', &quot;r&quot;, encoding=&quot;utf-8&quot;) as f: jscode = f.read()targetProcessPackName = &quot;./conforand&quot;device = frida.get_local_device()try: pid = device.spawn(targetProcessPackName) session = device.attach(pid) print(pid)except frida.ProcessNotFoundError: print(&quot;No such process&quot;) sys.exit(0)device.resume(pid)time.sleep(2)# input(&quot;continue&quot;)script = session.create_script(jscode)script.on('message', onMessage)script.load()# device.resume(pid)sys.stdin.read() 解出HZNUCTF{489b88-1305-411e-b1f4-88a3070a73}","link":"/ctf/WP/TGCTF%202025/"},{"title":"从零开始的LLVM-pass （一） 环境搭建和第一个demo","text":"为什么有这篇文章前段时间看了点LLVM的博客，学的非常痛苦，所以打算写一篇文章记录一下基本的框架搭建过程，省的一段时间后又忘了 Demo实现一个 FunctionPass ，遍历所有函数，如果函数不是main函数就修改混淆函数的名字 关于环境开发环境是win，至于为什么不选linux，主要是没有物理机实在不方便，后续如果被win恶心到了可能会迁移到linux win-gnu-llvm下载 非常神奇的找到了兼容win-gnu ABI的llvm工具链，试了下能跑，索性先这样g++用的是MinGW，网上随便下一个新一点的都行 直接下载完就是编译完的二进制文件，把bin加到环境目录就能识别clang和opt了 框架搭建目录结构如图所示build是Cmake的输出路径，最终编译好的pass就存在里面test里是测试文件，用来测试pass的混淆效果transforms里是pass的源码 /transforms/CMakelists.txt12345678910111213141516171819202122232425# /transforms/CMakelists.txtcmake_minimum_required(VERSION 3.13)project(MyPass)set(CMAKE_C_COMPILER &quot;gcc&quot;)set(CMAKE_CXX_COMPILER &quot;g++&quot;)set(LLVM_DIR &quot;C://llvm-19.1.6-1/lib/cmake/llvm&quot;)find_package(LLVM REQUIRED CONFIG)include_directories(${LLVM_INCLUDE_DIRS})link_directories(${LLVM_LIBRARY_DIRS})add_definitions(${LLVM_DEFINITIONS})add_library(MyPass MODULE MyPass.cpp)target_link_libraries(MyPass LLVMCore LLVMSupport LLVMIRReader LLVMPasses LLVMAnalysis LLVMTransformUtils) CMakelist如上设置，要手动导入LLVM的cmake路径，然后中间这些宏都是LLVM的.cmake文件里自带的，直接抄就行之后就和正常cmake项目一样，设置链接库源文件，输出和依赖 test.sh123456789101112# test.shcd ./build cmake -G &quot;Ninja&quot; ../transforms cmake --build .cd ../testg++ test.cpp -o beforeLLVM_testclang++ -S -emit-llvm test.cpp -o test.llopt -load-pass-plugin=../build/libMyPass.dll -passes=encode-func -S test.ll -o test.out.llllc test.out.ll -filetype=obj -o test.og++ test.o -o test ./testcd .. 使用g++编译一份未加pass的二进制文件方便以后对比，使用clang++配合-S -emit-llvm参数输出llvm-IR文件，这是llvm的中间语言文件，之后pass所有的处理都在该文件上进行-load-pass-plugin=${filePath} 是opt新版的api，我们生成的是类似于插件库的dll，之后还要加上 -passes={passName} 指定具体用哪个pass，之后讲如何注册pas时会具体讲这个passName是怎么来的 处理好后用llc把中间文件编译成目标文件，再用g++把中间文件编译成可执行文件就完事了 MyPass.cpp1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &quot;llvm/IR/PassManager.h&quot;#include &quot;llvm/Passes/PassBuilder.h&quot;#include &quot;llvm/Passes/PassPlugin.h&quot;#include &quot;llvm/Support/raw_ostream.h&quot;#include &lt;string&gt;using namespace llvm;namespace{ class EncodeFunctionName : public PassInfoMixin&lt;EncodeFunctionName&gt; { private: static int functionCnt; public: PreservedAnalyses run(Function &amp;F, FunctionAnalysisManager &amp;FAM) { if (F.getName() != &quot;main&quot;) { errs() &lt;&lt; &quot;Old name: &quot; &lt;&lt; F.getName() &lt;&lt; &quot;\\n&quot;; F.setName(&quot;114514func&quot; + std::to_string(++functionCnt)); errs() &lt;&lt; &quot;New name: &quot; &lt;&lt; F.getName() &lt;&lt; &quot;\\n&quot;; } else { errs() &lt;&lt; &quot;function is &quot; &lt;&lt; F.getName() &lt;&lt; &quot;\\n&quot;; } return PreservedAnalyses::all(); } static bool isRequired() { return true; } };}int EncodeFunctionName::functionCnt = 0;extern &quot;C&quot; LLVM_ATTRIBUTE_WEAK ::llvm::PassPluginLibraryInfollvmGetPassPluginInfo(){ return { LLVM_PLUGIN_API_VERSION, &quot;encode-func&quot;, LLVM_VERSION_STRING, [](PassBuilder &amp;PB) { errs() &lt;&lt; &quot;\\n=== Registering EncodeFunctionName Pass ===\\n&quot;; PB.registerPipelineParsingCallback( [](StringRef Name, FunctionPassManager &amp;FPM, ArrayRef&lt;PassBuilder::PipelineElement&gt;) { if (Name == &quot;encode-func&quot;) { errs() &lt;&lt; &quot;Adding EncodeFunctionName pass to manager\\n&quot;; FPM.addPass(EncodeFunctionName()); return true; } return false; }); }};} llvm的所有实现都定义在llvm空间中，因为是个demo所以干脆直接using namespace llvm要实现一个自己的pass，我们要从 PassInfoMixin&lt;&gt; 这个基类模板继承，这是LLVM的新版API，区别于旧版的是我们不用指定pass的类型，而是依靠下面的 run 方法的实现区分pass类型，我们要实现一个functionPAss，所以 run 的参数就是 llvm:Function 和 llvm:FunctionAnalysisManager run 是pass中最关键的方法，一个pass所有的业务都是在run中完成的，这是一个回调，会对所有的函数执行，我们直接用getName获取名字，然后用setName重设名字就行，返回 PreservedAnalyses::all() 表示这个pass不会对其他任何pass产生影响，反正我们也只跑这一个pass，返回all即可 isRequired() 编译器可能会跳过我们的pass，因为实际上pass没做优化，所以要实现 isRequired 返回ture强制要求编译器执行我们的pass extern “C” LLVM_ATTRIBUTE_WEAK ::llvm::PassPluginLibraryInfo llvmGetPassPluginInfo()这是新版LLVM注册pass的惯用约定，这部分基本没什么好改的，返回一个四元组 {LLVM插件API版本号，插件名，插件版本号，注册回调函数} ，其中插件名就是我们用-pass时传递的名字，opt会解析这个名字并并调用相关回调，插件版本号随便写就行 回调会传入一个PassBuilder,我们往里面注册一个解析回调，每次opt解析我们的命令时都会执行这个回调，这个回调的格式也基本是固定的，最重要的是 Name ，这是解析得到的 passName ，我们调用 FPM.FPM.addPass(EncodeFunctionName()) 来完成注册 test.cpp123456789101112131415161718192021222324// test.cpp#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;void testFunctionA(){ std::cout &lt;&lt; &quot;testA&quot;;}void testFunctionB(){ std::cout &lt;&lt; &quot;testB&quot;;}void testFunctionC(){ std::cout &lt;&lt; &quot;testC&quot;;}int main(){ testFunctionA(); testFunctionB(); testFunctionC(); return 0;} 我们声明了三个函数，预期这三个函数的名字都会被改成114514funcxxx 输出根据pass输出的调试信息可以发现opt按照从上到下的顺序对每个函数执行了pass 然后再打开ida看看二进制文件是否真的被修改了 可以看到确实被修改了 下一篇文章可能会写一下怎么修改基本块和怎么混淆运算符","link":"/ctf/llvm/llvm0x1/"},{"title":"AES","text":"简介AES是在DES被证明不安全后出现的加密算法，是经典的块加密算法，可以使用128bit,192bit,256bit三种长度的密钥，数据块长度固定为128bit(16字节)，整个加密过程在一个44的矩阵中进行，AES加密基于代换-置换网络，主要操作有轮密钥加，字节代换，行位移，列混合四种，其中数值运算相关的操作都是定义在$GF(2^8)$这个有限域下的（可以理解为为了防止溢出损失信息），对于有限域下的数值计算如何处理会在实现中说明,AES的运算采用*大端序 特征以AES128为例，在主循环中会依次执行字节代换，行位移，列混合，轮密钥加四个操作共9轮，第十轮不进行列混合操作，不过这个因为编译器会把加密操作优化的面目全非所以不一定看得出来其次是S盒，AES有一个256位的S盒用于进行字节代换操作标准S盒如下 12345678910111213141516const uint8_t S[16][16] = {0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76, 0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0, 0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15, 0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75, 0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84, 0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b, 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf, 0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8, 0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2, 0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73, 0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb, 0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79, 0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08, 0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a, 0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e, 0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf, 0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16}; 以及十个轮常量用于参与密钥拓展算法标准轮常量如下 12345const uint32_t Rcon[10] = {0x01000000, 0x02000000, 0x04000000, 0x08000000, 0x10000000, 0x20000000, 0x40000000, 0x80000000, 0x1b000000, 0x36000000}; 实现AES首先进行密钥拓展，AES的密钥由原本128位密钥组成的4个uint32_t为基础，拓展出10轮，总计44个共11组密钥因为加密是在4*4矩阵上进行操作，且矩阵是列优先排列的，所以先将密文按块转化为矩阵，加密完成后在转换回去 $s_0$ $s_1$ $s_2$ … $s_{14}$ $s_{15}$ 转换后变为： $s_0$ $s_4$ $s_8$ $s_{12}$ $s_1$ $s_5$ $s_9$ $s_{13}$ $s_2$ $s_6$ $s_{10}$ $s_{14}$ $s_3$ $s_7$ $s_{11}$ $s_{15}$ 一开始先进行初始密钥加操作，然后循环9轮，最后再进行第十轮，第十轮中不进行列混合 1234567891011121314151617181920212223242526272829303132void convertToStateArray(uint8_t s[16], uint8_t a[4][4]){ for (int i = 0; i &lt; 4; i++) { for (int j = 0; j &lt; 4; j++) { a[j][i] = s[i * 4 + j]; } }}void AES(uint8_t *message, uint64_t messageLen, uint8_t *key){ extendKey(key); uint8_t sArray[4][4]; for (int i = 0; i &lt; messageLen; i += 16) { convertToStateArray(message + i, sArray); // 转换为状态矩阵 addRoundKey(sArray, 0); // 初始轮密钥加 for (int j = 1; j &lt; 10; j++) // 1~9 { subbytes(sArray); // 字节代换 shiftRows(sArray); // 行移位 columnMix(sArray); // 列混合 addRoundKey(sArray, j); // 轮密钥加 } subbytes(sArray); shiftRows(sArray); addRoundKey(sArray, 10); // 最终轮密钥加 convertToStr(sArray, message + i); // 转换回字符串 }} 字节拓展操作首先把密钥按大端序转换为32位字$W_0$ ~ $W_3$，然后按照以下规则进行拓展出$W_4$ ~ $W_{43}$：$$W_i =\\begin{cases}W_{i-4} \\oplus T(W_{i-1}), &amp; \\text{if } i \\bmod 4 = 0 \\W_{i-4} \\oplus W_{i-1}, &amp; \\text{otherwise}\\end{cases}$$ 其中T是密钥拓展使用的轮函数，由字节偏移，字节代换，轮常量异或三个操作组成 123456789101112131415161718192021222324252627282930uint32_t T(uint32_t w, int round){ w = (w &gt;&gt; 24) | (w &lt;&lt; 8); // 字节偏移，循环左移一字节 uint8_t temp[4]; convertToWordArray(w, temp); // 转换为字节数组 for (int i = 0; i &lt; 4; i++) { temp[i] = S[temp[i] &gt;&gt; 4][temp[i] &amp; 0x0F]; // 字节代换 } w = convertToWord(temp); w ^= Rcon[round]; // 轮常量异或 return w;}void extendKey(uint8_t *key){ for (int i = 0; i &lt; 4; i++) { w[i] = getBigEndian(key + i * 4); // 转大端序 } for (int i = 4, j = 0; i &lt; 44; i++) // 密钥拓展 { if (i % 4 == 0) { w[i] = w[i - 4] ^ T(w[i - 1], j); j++; } else w[i] = w[i - 4] ^ w[i - 1]; }} 轮密钥加操作就是将当前轮对应的密钥与数据进行异或，因为在$GF(2^8)$下的加法与异或等价 123456789101112void addRoundKey(uint8_t sArray[4][4], int round) // 轮密钥加{ uint8_t wArray[4]; for (int i = 0; i &lt; 4; i++) { convertToWordArray(w[round * 4 + i], wArray); // 转换为字节数组 for (int j = 0; j &lt; 4; j++) { sArray[j][i] ^= wArray[j]; // 异或操作 } }} 行位移操作就是把整个矩阵第一行不动，第二行循环左移1位，第三行2位，第四行3位，可以直接模拟 1234567891011121314151617181920212223242526void shiftRows(uint8_t sArray[4][4]){ // 第0行不移位 // 第1行左移1位 uint8_t temp = sArray[1][0]; sArray[1][0] = sArray[1][1]; sArray[1][1] = sArray[1][2]; sArray[1][2] = sArray[1][3]; sArray[1][3] = temp; // 第2行左移2位 uint8_t temp1 = sArray[2][0]; uint8_t temp2 = sArray[2][1]; sArray[2][0] = sArray[2][2]; sArray[2][1] = sArray[2][3]; sArray[2][2] = temp1; sArray[2][3] = temp2; // 第3行左移3位 temp = sArray[3][0]; sArray[3][0] = sArray[3][3]; sArray[3][3] = sArray[3][2]; sArray[3][2] = sArray[3][1]; sArray[3][1] = temp;} 字节代换操作就是将矩阵中一个字节的高4位作为行号，低四位作为列号在S盒中查表 123456void subbytes(uint8_t sArray[4][4]){ for (int i = 0; i &lt; 4; i++) for (int j = 0; j &lt; 4; j++) sArray[i][j] = S[sArray[i][j] &gt;&gt; 4][sArray[i][j] &amp; 0x0F]; // 字节代换} 列混合操作是使用一个事先准备好的4*4矩阵和当前矩阵进行矩阵乘法，GF(2^8)下的乘法满足交换律，结合律和分配律，且与二相乘可以等价于如下操作：1.左移一位2.如果左移前最高位为1，则与0x1B异或所以只要实现乘二就能实现所有情况下的乘法 12345678910111213141516171819202122232425262728293031323334353637383940414243uint8_t GFMul(uint8_t s, int n){ if (n == 1) { return s; } if (n == 2) { uint8_t result = s &lt;&lt; 1; if (s &amp; 0x80) { result = result ^ 0x1b; } return result; } if (n % 2 == 0) return GFMul(GFMul(s, n / 2), 2); else return GFMul(s, n - 1) ^ s;}const uint8_t colM[4][4] = {2, 3, 1, 1, 1, 2, 3, 1, 1, 1, 2, 3, 3, 1, 1, 2}; void columnMix(uint8_t sArray[4][4]){ uint8_t tempArray[4][4]; for (int i = 0; i &lt; 4; i++) for (int j = 0; j &lt; 4; j++) tempArray[i][j] = sArray[i][j]; for (int j = 0; j &lt; 4; j++) { for (int i = 0; i &lt; 4; i++) { sArray[i][j] = GFMul(tempArray[0][j], colM[i][0]) ^ GFMul(tempArray[1][j], colM[i][1]) ^ GFMul(tempArray[2][j], colM[i][2]) ^ GFMul(tempArray[3][j], colM[i][3]); } }} 最后整个流程的图示如下所示 加密完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209#include &lt;bits/stdc++.h&gt;using namespace std;int w[44];uint32_t getBigEndian(uint8_t a[4]){ uint32_t res = 0; res = (a[0] &lt;&lt; 24) | (a[1] &lt;&lt; 16) | (a[2] &lt;&lt; 8) | a[3]; return res;}void convertToStateArray(uint8_t s[16], uint8_t a[4][4]){ for (int i = 0; i &lt; 4; i++) { for (int j = 0; j &lt; 4; j++) { a[j][i] = s[i * 4 + j]; } }}void convertToStr(uint8_t a[4][4], uint8_t s[16]){ for (int i = 0; i &lt; 4; i++) for (int j = 0; j &lt; 4; j++) s[i * 4 + j] = a[j][i];}void convertToWordArray(uint32_t W, uint8_t w[4]){ w[0] = (W &gt;&gt; 24) &amp; 0xFF; w[1] = (W &gt;&gt; 16) &amp; 0xFF; w[2] = (W &gt;&gt; 8) &amp; 0xFF; w[3] = W &amp; 0xFF;}uint32_t convertToWord(uint8_t w[4]){ uint32_t res = 0; res = (w[0] &lt;&lt; 24) | (w[1] &lt;&lt; 16) | (w[2] &lt;&lt; 8) | w[3]; return res;}const uint8_t S[16][16] = {0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76, 0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0, 0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15, 0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75, 0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84, 0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b, 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf, 0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8, 0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2, 0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73, 0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb, 0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79, 0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08, 0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a, 0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e, 0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf, 0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16};const uint32_t Rcon[10] = {0x01000000, 0x02000000, 0x04000000, 0x08000000, 0x10000000, 0x20000000, 0x40000000, 0x80000000, 0x1b000000, 0x36000000};uint32_t T(uint32_t w, int round){ w = (w &gt;&gt; 24) | (w &lt;&lt; 8); // 字节偏移，循环左移一字节 uint8_t temp[4]; convertToWordArray(w, temp); // 转换为字节数组 for (int i = 0; i &lt; 4; i++) { temp[i] = S[temp[i] &gt;&gt; 4][temp[i] &amp; 0x0F]; // 字节代换 } w = convertToWord(temp); w ^= Rcon[round]; // 轮常量异或 return w;}void extendKey(uint8_t *key){ for (int i = 0; i &lt; 4; i++) { w[i] = getBigEndian(key + i * 4); // 转大端序 } for (int i = 4, j = 0; i &lt; 44; i++) // 密钥拓展 { if (i % 4 == 0) { w[i] = w[i - 4] ^ T(w[i - 1], j); j++; } else w[i] = w[i - 4] ^ w[i - 1]; }}void addRoundKey(uint8_t sArray[4][4], int round) // 轮密钥加{ uint8_t wArray[4]; for (int i = 0; i &lt; 4; i++) { convertToWordArray(w[round * 4 + i], wArray); // 转换为字节数组 for (int j = 0; j &lt; 4; j++) { sArray[j][i] ^= wArray[j]; // 异或操作 } }}void subbytes(uint8_t sArray[4][4]){ for (int i = 0; i &lt; 4; i++) for (int j = 0; j &lt; 4; j++) sArray[i][j] = S[sArray[i][j] &gt;&gt; 4][sArray[i][j] &amp; 0x0F]; // 字节代换}void shiftRows(uint8_t sArray[4][4]){ // 第0行不移位 // 第1行左移1位 uint8_t temp = sArray[1][0]; sArray[1][0] = sArray[1][1]; sArray[1][1] = sArray[1][2]; sArray[1][2] = sArray[1][3]; sArray[1][3] = temp; // 第2行左移2位 uint8_t temp1 = sArray[2][0]; uint8_t temp2 = sArray[2][1]; sArray[2][0] = sArray[2][2]; sArray[2][1] = sArray[2][3]; sArray[2][2] = temp1; sArray[2][3] = temp2; // 第3行左移3位 temp = sArray[3][0]; sArray[3][0] = sArray[3][3]; sArray[3][3] = sArray[3][2]; sArray[3][2] = sArray[3][1]; sArray[3][1] = temp;}const uint8_t colM[4][4] = {2, 3, 1, 1, 1, 2, 3, 1, 1, 1, 2, 3, 3, 1, 1, 2};uint8_t GFMul(uint8_t s, int n){ if (n == 1) { return s; } if (n == 2) { uint8_t result = s &lt;&lt; 1; if (s &amp; 0x80) { result = result ^ 0x1b; } return result; } if (n % 2 == 0) return GFMul(GFMul(s, n / 2), 2); else return GFMul(s, n - 1) ^ s;}void columnMix(uint8_t sArray[4][4]){ uint8_t tempArray[4][4]; for (int i = 0; i &lt; 4; i++) for (int j = 0; j &lt; 4; j++) tempArray[i][j] = sArray[i][j]; for (int j = 0; j &lt; 4; j++) { for (int i = 0; i &lt; 4; i++) { sArray[i][j] = GFMul(tempArray[0][j], colM[i][0]) ^ GFMul(tempArray[1][j], colM[i][1]) ^ GFMul(tempArray[2][j], colM[i][2]) ^ GFMul(tempArray[3][j], colM[i][3]); } }}void AES(uint8_t *message, uint64_t messageLen, uint8_t *key){ extendKey(key); uint8_t sArray[4][4]; for (int i = 0; i &lt; messageLen; i += 16) { convertToStateArray(message + i, sArray); // 转换为状态矩阵 addRoundKey(sArray, 0); // 初始轮密钥加 for (int j = 1; j &lt; 10; j++) // 1~9 { subbytes(sArray); // 字节代换 shiftRows(sArray); // 行移位 columnMix(sArray); // 列混合 addRoundKey(sArray, j); // 轮密钥加 } subbytes(sArray); shiftRows(sArray); addRoundKey(sArray, 10); // 最终轮密钥加 convertToStr(sArray, message + i); // 转换回字符串 }}int main(){ char key[] = &quot;0123456789abcdef&quot;; char message[] = &quot;0123456789abcdef&quot;; AES((uint8_t *)message, strlen(message), (uint8_t *)key); for (int i = 0; i &lt; 16; i++) { printf(&quot;%02X &quot;, message[i] &amp; 0xFF); } return 0;} 解密因为是对称加密算法，AES的每一步操作都可以对其实现逆操作，只要把逆操作都实现出来然后按照加密的顺序反向执行就可以解密逆字节代换就是根据S盒可以准备一个反S盒，同样是查表替换 12345678910111213141516171819202122const uint8_t S2[16][16] = {0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb, 0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb, 0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e, 0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25, 0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92, 0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84, 0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06, 0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b, 0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73, 0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e, 0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b, 0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4, 0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f, 0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef, 0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61, 0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d};void deSubBytes(uint8_t sArray[4][4]){ for (int i = 0; i &lt; 4; i++) for (int j = 0; j &lt; 4; j++) sArray[i][j] = S2[sArray[i][j] &gt;&gt; 4][sArray[i][j] &amp; 0x0F]; // 字节代换} 逆行位移把循环左移改为循环右移 1234567891011121314151617181920212223242526void deShiftRows(uint8_t sArray[4][4]){ // 第0行不移位 // 第1行右移1位 uint8_t temp = sArray[1][3]; sArray[1][3] = sArray[1][2]; sArray[1][2] = sArray[1][1]; sArray[1][1] = sArray[1][0]; sArray[1][0] = temp; // 第2行右移2位 uint8_t temp1 = sArray[2][0]; uint8_t temp2 = sArray[2][1]; sArray[2][0] = sArray[2][2]; sArray[2][1] = sArray[2][3]; sArray[2][2] = temp1; sArray[2][3] = temp2; // 第3行右移3位 temp = sArray[3][0]; sArray[3][0] = sArray[3][1]; sArray[3][1] = sArray[3][2]; sArray[3][2] = sArray[3][3]; sArray[3][3] = temp;} 逆列混合因为是矩阵乘法，所以只要构造出colM的逆矩阵就行 1234567891011121314151617const uint8_t deColM[4][4] = {0xe, 0xb, 0xd, 0x9, 0x9, 0xe, 0xb, 0xd, 0xd, 0x9, 0xe, 0xb, 0xb, 0xd, 0x9, 0xe};void deMixColumns(uint8_t sArray[4][4]){ uint8_t tempArray[4][4]; for (int i = 0; i &lt; 4; i++) for (int j = 0; j &lt; 4; j++) tempArray[i][j] = sArray[i][j]; for (int j = 0; j &lt; 4; j++) for (int i = 0; i &lt; 4; i++) sArray[i][j] = GFMul(tempArray[0][j], deColM[i][0]) ^ GFMul(tempArray[1][j], deColM[i][1]) ^ GFMul(tempArray[2][j], deColM[i][2]) ^ GFMul(tempArray[3][j], deColM[i][3]);} 轮密钥加因为是异或，所以不用额外实现反向操作可以给出完整解密如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687const uint8_t S2[16][16] = {0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb, 0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb, 0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e, 0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25, 0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92, 0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84, 0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06, 0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b, 0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73, 0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e, 0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b, 0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4, 0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f, 0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef, 0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61, 0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d};void deSubBytes(uint8_t sArray[4][4]){ for (int i = 0; i &lt; 4; i++) for (int j = 0; j &lt; 4; j++) sArray[i][j] = S2[sArray[i][j] &gt;&gt; 4][sArray[i][j] &amp; 0x0F]; // 字节代换}void deShiftRows(uint8_t sArray[4][4]){ // 第0行不移位 // 第1行右移1位 uint8_t temp = sArray[1][3]; sArray[1][3] = sArray[1][2]; sArray[1][2] = sArray[1][1]; sArray[1][1] = sArray[1][0]; sArray[1][0] = temp; // 第2行右移2位 uint8_t temp1 = sArray[2][0]; uint8_t temp2 = sArray[2][1]; sArray[2][0] = sArray[2][2]; sArray[2][1] = sArray[2][3]; sArray[2][2] = temp1; sArray[2][3] = temp2; // 第3行右移3位 temp = sArray[3][0]; sArray[3][0] = sArray[3][1]; sArray[3][1] = sArray[3][2]; sArray[3][2] = sArray[3][3]; sArray[3][3] = temp;}const uint8_t deColM[4][4] = {0xe, 0xb, 0xd, 0x9, 0x9, 0xe, 0xb, 0xd, 0xd, 0x9, 0xe, 0xb, 0xb, 0xd, 0x9, 0xe};void deMixColumns(uint8_t sArray[4][4]){ uint8_t tempArray[4][4]; for (int i = 0; i &lt; 4; i++) for (int j = 0; j &lt; 4; j++) tempArray[i][j] = sArray[i][j]; for (int j = 0; j &lt; 4; j++) for (int i = 0; i &lt; 4; i++) sArray[i][j] = GFMul(tempArray[0][j], deColM[i][0]) ^ GFMul(tempArray[1][j], deColM[i][1]) ^ GFMul(tempArray[2][j], deColM[i][2]) ^ GFMul(tempArray[3][j], deColM[i][3]);}void AESdecrypt(uint8_t *message, uint64_t messageLen, uint8_t *key){ extendKey(key); uint8_t sArray[4][4]; for (int i = 0; i &lt; messageLen; i += 16) { convertToStateArray(message + i, sArray); // 转换为状态矩阵 addRoundKey(sArray, 10); // 初始轮密钥加 deShiftRows(sArray); // 行移位 deSubBytes(sArray); // 字节代换 for (int j = 9; j &gt;= 1; j--) { addRoundKey(sArray, j); // 轮密钥加 deMixColumns(sArray); // 列混合 deShiftRows(sArray); // 行移位 deSubBytes(sArray); // 字节代换 } addRoundKey(sArray, 0); // 最终轮密钥加 convertToStr(sArray, message + i); }} referenceAES-wikipedia","link":"/ctf/%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86/AES/"},{"title":"RC4","text":"简介RC4是一种比较简单的流加密算法，流加密的特点是逐字节加密，相邻字节间相互独立RC4的密钥不能超过256个字节，这点从初始化密钥流的部分也能看出，因为初始化密钥流使用了swap，整个操作失去线性，所以可以保证密钥流一定的随机性RC4大部分的操作都是在初始化密钥盒，最后只是进行了异或，可以说拿到了密钥盒就是破解了RC4 特征虽然说本文的重点不在特征，但还是指出RC4的一些比较明显的特征，一个是置换盒初始化算法，一个就是最后密钥流对输入的异或 实现1234567891011121314151617181920212223242526272829#include &lt;bits/stdc++.h&gt;using namespace std;int main(){ uint8_t initBox[256]; for (int i = 0; i &lt; 256; i++) initBox[i] = i; // 初始化向量 int j = 0; char key[] = &quot;Eleven&quot;; for (int i = 0; i &lt; 256; i++) { j = (j + initBox[i] + key[i % strlen(key)]) % 256; // 初始化密钥流向量 swap(initBox[i], initBox[j]); } char rawInput[] = &quot;thisIsASecretMessage&quot;; int len = strlen(rawInput); int i = 0; j = 0; for (int k = 0; k &lt; len; k++) { i = (i + 1) % 256; j = (j + initBox[i]) % 256; swap(initBox[i], initBox[j]); int t = (initBox[i] + initBox[j]) % 256; int K = initBox[t]; // 密钥流 rawInput[k] = rawInput[k] ^ K; // 将密钥与输入异或 } return 0;} 破解逐字节异或，一般逆向中其实怎么都能破解，可以动调获取box,或者直接把密文输进去，或者在RC4入口点把输入的内容patch成密文，根据异或的性质RC4的加密算法就是解密算法，跑两遍等于没跑，一般题目会在key上做文章，或者在每轮异或后额外异或一个常数之类的，防止直接拿到key后一把梭继续观察源码注意到这个t其实还能加入偏移，K也能加入常数或偏移，初始化向量也可能事先打乱而不是0,1,2,3…，甚至向量的位数也可以魔改，实战中要具体观察实现 referencewikipedia","link":"/ctf/%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86/RC4/"},{"title":"DES","text":"简介DES加密是经典的基于Feistel网络结构的块加密，DES标准中字节的处理方式为大端序，DES接受一个64位（64bit）的明文和一个64位的key，返回64位的密文在DES流程的开始，64位的key被传入PC1函数生成56位的真正密钥，因为原密钥中有8位是校验位而这56位的密钥会再被拆分成左右两个各28位的密钥 123456789101112131415161718pair&lt;uint32_t, uint32_t&gt; PC1(uint64_t key){ uint8_t pc1L[] = {57, 49, 41, 33, 25, 17, 9, 1, 58, 50, 42, 34, 26, 18, 10, 2, 59, 51, 43, 35, 27, 19, 11, 3, 60, 52, 44, 36}; uint8_t pc1R[] = {63, 55, 47, 39, 31, 23, 15, 7, 62, 54, 46, 38, 30, 22, 14, 6, 61, 53, 45, 37, 29, 21, 13, 5, 28, 20, 12, 4}; pair&lt;uint32_t, uint32_t&gt; keyPair{0, 0}; for (int i = 0; i &lt; 28; i++) { keyPair.first |= ((key &gt;&gt; (64 - pc1L[i])) &amp; 1) &lt;&lt; (27 - i); keyPair.second |= ((key &gt;&gt; (64 - pc1R[i])) &amp; 1) &lt;&lt; (27 - i); } return keyPair;} 两个28位密钥分别左旋特定位数后进入PC2用于生成16个48位子密钥，PC2中有一个盒用于决定选择哪48位来作为密钥 123456789101112131415161718192021222324252627void keyGen(pair&lt;uint32_t, uint32_t&gt; keyPair){ uint8_t offsets[] = {1, 1, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 1}; for (int i = 0; i &lt; 16; i++) { keyPair.first = leftRotate(keyPair.first, offsets[i]); keyPair.second = leftRotate(keyPair.second, offsets[i]); Keys[i] = PC2(((uint64_t)keyPair.first &lt;&lt; 28) | keyPair.second); }}uint64_t PC2(uint64_t key){ uint8_t pc2[] = {14, 17, 11, 24, 1, 5, 3, 28, 15, 6, 21, 10, 23, 19, 12, 4, 26, 8, 16, 7, 27, 20, 13, 2, 41, 52, 31, 37, 47, 55, 30, 40, 51, 45, 33, 48, 44, 49, 39, 56, 34, 53, 46, 42, 50, 36, 29, 32}; uint64_t subKey = 0; for (int i = 0; i &lt; 48; i++) { subKey |= ((key &gt;&gt; (56 - pc2[i])) &amp; 1) &lt;&lt; (47 - i); } return subKey;} 至此为止密钥全部准备完毕，明文被分为左右各32位进入Feistel网络循环流程 1234567891011121314void desEncrypt(uint64_t *plain, uint64_t key){ keyGen(PC1(key)); uint64_t afterIP = IP(*plain); uint32_t l = afterIP &gt;&gt; 32, r = afterIP &amp; 0xFFFFFFFF; for (int i = 0; i &lt; 16; i++) { pair&lt;uint32_t, uint32_t&gt; lr = goRound(l, r, Keys[i]); l = lr.first; r = lr.second; } *plain = ((uint64_t)r &lt;&lt; 32) | l; *plain = FP(*plain);} 明文在进入和结束加密时还要经历IP,FP两次置换，这两次置换只是简单映射 12345678910111213141516171819202122232425262728293031323334uint64_t IP(uint64_t messagge){ uint64_t afterIP = 0; uint8_t ip[] = {58, 50, 42, 34, 26, 18, 10, 2, 60, 52, 44, 36, 28, 20, 12, 4, 62, 54, 46, 38, 30, 22, 14, 6, 64, 56, 48, 40, 32, 24, 16, 8, 57, 49, 41, 33, 25, 17, 9, 1, 59, 51, 43, 35, 27, 19, 11, 3, 61, 53, 45, 37, 29, 21, 13, 5, 63, 55, 47, 39, 31, 23, 15, 7}; for (int i = 0; i &lt; 64; i++) { afterIP |= ((messagge &gt;&gt; (64 - ip[i])) &amp; 1) &lt;&lt; (63 - i); } return afterIP;}uint64_t FP(uint64_t messagge){ uint64_t afterFP = 0; uint8_t fp[] = {40, 8, 48, 16, 56, 24, 64, 32, 39, 7, 47, 15, 55, 23, 63, 31, 38, 6, 46, 14, 54, 22, 62, 30, 37, 5, 45, 13, 53, 21, 61, 29, 36, 4, 44, 12, 52, 20, 60, 28, 35, 3, 43, 11, 51, 19, 59, 27, 34, 2, 42, 10, 50, 18, 58, 26, 33, 1, 41, 9, 49, 17, 57, 25}; for (int i = 0; i &lt; 64; i++) { afterFP |= ((messagge &gt;&gt; (64 - fp[i])) &amp; 1) &lt;&lt; (63 - i); } return afterFP;} Feistel轮函数如下所示 1234567891011uint32_t feistel(uint32_t a, uint64_t key){ uint64_t t = expand(a) ^ key; uint32_t afterS = S(t); afterS = P(afterS); return afterS;}pair&lt;uint32_t, uint32_t&gt; goRound(uint32_t l, uint32_t r, uint64_t key){ return {r, l ^ feistel(r, key)};} 数据先经过E盒拓展为48位后与48位密钥异或，然后进入S盒重新映射为32位，最后由P盒再进行一轮置换后输出 1234567891011121314151617uint64_t expand(uint32_t a){ uint8_t e[] = {32, 1, 2, 3, 4, 5, 4, 5, 6, 7, 8, 9, 8, 9, 10, 11, 12, 13, 12, 13, 14, 15, 16, 17, 16, 17, 18, 19, 20, 21, 20, 21, 22, 23, 24, 25, 24, 25, 26, 27, 28, 29, 28, 29, 30, 31, 32, 1}; uint64_t afterE = 0; for (int i = 0; i &lt; 48; i++) { afterE |= ((a &gt;&gt; (32 - e[i])) &amp; 1) &lt;&lt; (47 - i); } return afterE;} S盒有8个，每个S盒是一个4*16的结构，48位的输出被分为8个6位的块分别进入对应的S盒，每块的第1和第6个位用于索引行(0x00 ~ 0x11)，其余四位用于索引列(0x0000 ~ 0x1111)，S盒中的数都是4位的，最后合起来得到一个32位的输出 1234567891011uint64_t S(uint64_t a){ uint32_t res = 0; for (int i = 0; i &lt; 8; i++) { uint8_t row = ((((a &gt;&gt; (i * 6)) &amp; 0x20)) &gt;&gt; 4) | ((a &gt;&gt; (i * 6)) &amp; 1); uint8_t col = ((a &gt;&gt; (i * 6)) &amp; 0x1E) &gt;&gt; 1; res |= S_box[i][row * 16 + col] &lt;&lt; (i * 4); } return res;} P置换就是再次打乱S盒的输出 1234567891011121314151617uint32_t P(uint64_t a){ uint8_t p[] = {16, 7, 20, 21, 29, 12, 28, 17, 1, 15, 23, 26, 5, 18, 31, 10, 2, 8, 24, 14, 32, 27, 3, 9, 19, 13, 30, 6, 22, 11, 4, 25}; uint32_t afterP = 0; for (int i = 0; i &lt; 32; i++) { afterP |= ((a &gt;&gt; (32 - p[i])) &amp; 1) &lt;&lt; (31 - i); } return afterP;} 至此DES的流程全部结束，按照图例的话如下图所示 特征因为DES的代码过于庞大，且涉及大量位操作，在反编译器中观察DES的特征非常困难，但是DES有非常多的盒，其中部分盒是精心设计的，修改这部分盒会严重影响DES在对抗暴力破解时的安全性，所以我们可以通过这些一般不会修改的盒识别DES S盒S盒引入了非线性操作，且S盒的每一位都设计过用以抵抗差分和线性密码分析，一般不会修改S盒 123456789101112131415161718192021222324252627282930313233uint8_t S_box[8][64] = {{14, 4, 13, 1, 2, 15, 11, 8, 3, 10, 6, 12, 5, 9, 0, 7, 0, 15, 7, 4, 14, 2, 13, 1, 10, 6, 12, 11, 9, 5, 3, 8, 4, 1, 14, 8, 13, 6, 2, 11, 15, 12, 9, 7, 3, 10, 5, 0, 15, 12, 8, 2, 4, 9, 1, 7, 5, 11, 3, 14, 10, 0, 6, 13},{15, 1, 8, 14, 6, 11, 3, 4, 9, 7, 2, 13, 12, 0, 5, 10, 3, 13, 4, 7, 15, 2, 8, 14, 12, 0, 1, 10, 6, 9, 11, 5, 0, 14, 7, 11, 10, 4, 13, 1, 5, 8, 12, 6, 9, 3, 2, 15, 13, 8, 10, 1, 3, 15, 4, 2, 11, 6, 7, 12, 0, 5, 14, 9},{10, 0, 9, 14, 6, 3, 15, 5, 1, 13, 12, 7, 11, 4, 2, 8, 13, 7, 0, 9, 3, 4, 6, 10, 2, 8, 5, 14, 12, 11, 15, 1, 13, 6, 4, 9, 8, 15, 3, 0, 11, 1, 2, 12, 5, 10, 14, 7, 1, 10, 13, 0, 6, 9, 8, 7, 4, 15, 14, 3, 11, 5, 2, 12},{7, 13, 14, 3, 0, 6, 9, 10, 1, 2, 8, 5, 11, 12, 4, 15, 13, 8, 11, 5, 6, 15, 0, 3, 4, 7, 2, 12, 1, 10, 14, 9, 10, 6, 9, 0, 12, 11, 7, 13, 15, 1, 3, 14, 5, 2, 8, 4, 3, 15, 0, 6, 10, 1, 13, 8, 9, 4, 5, 11, 12, 7, 2, 14},{2, 12, 4, 1, 7, 10, 11, 6, 8, 5, 3, 15, 13, 0, 14, 9, 14, 11, 2, 12, 4, 7, 13, 1, 5, 0, 15, 10, 3, 9, 8, 6, 4, 2, 1, 11, 10, 13, 7, 8, 15, 9, 12, 5, 6, 3, 0, 14, 11, 8, 12, 7, 1, 14, 2, 13, 6, 15, 0, 9, 10, 4, 5, 3},{12, 1, 10, 15, 9, 2, 6, 8, 0, 13, 3, 4, 14, 7, 5, 11, 10, 15, 4, 2, 7, 12, 9, 5, 6, 1, 13, 14, 0, 11, 3, 8, 9, 14, 15, 5, 2, 8, 12, 3, 7, 0, 4, 10, 1, 13, 11, 6, 4, 3, 2, 12, 9, 5, 15, 10, 11, 14, 1, 7, 6, 0, 8, 13},{4, 11, 2, 14, 15, 0, 8, 13, 3, 12, 9, 7, 5, 10, 6, 1, 13, 0, 11, 7, 4, 9, 1, 10, 14, 3, 5, 12, 2, 15, 8, 6, 1, 4, 11, 13, 12, 3, 7, 14, 10, 15, 6, 8, 0, 5, 9, 2, 6, 11, 13, 8, 1, 4, 10, 7, 9, 5, 0, 15, 14, 2, 3, 12},{13, 2, 8, 4, 6, 15, 11, 1, 10, 9, 3, 14, 5, 0, 12, 7, 1, 15, 13, 8, 10, 3, 7, 4, 12, 5, 6, 11, 0, 14, 9, 2, 7, 11, 4, 1, 9, 12, 14, 2, 0, 6, 10, 13, 15, 3, 5, 8, 2, 1, 14, 7, 4, 10, 8, 13, 15, 12, 9, 0, 3, 5, 6, 11}}; P盒P盒的特殊设计使得每一轮由同一个S盒输出的4个bit在下一轮都被分散到另外4个不同S盒中进行处理（增强扩散性） 123456789uint8_t p[] = {16, 7, 20, 21, 29, 12, 28, 17, 1, 15, 23, 26, 5, 18, 31, 10, 2, 8, 24, 14, 32, 27, 3, 9, 19, 13, 30, 6, 22, 11, 4, 25}; E盒E盒负责将32位的输入扩展到48位，对混淆能力由很大影响 123456789uint8_t e[] = {32, 1, 2, 3, 4, 5,4, 5, 6, 7, 8, 9,8, 9, 10, 11, 12, 13,12, 13, 14, 15, 16, 17,16, 17, 18, 19, 20, 21,20, 21, 22, 23, 24, 25,24, 25, 26, 27, 28, 29,28, 29, 30, 31, 32, 1}; 实现考虑到DES现在已经被证明不安全，且其加密过程严重依赖系统端序，DES标准为大端序，而现代计算机大多数为小端序，故不给出完整实现，如果遇到需要手动解密的DES，只需要根据Feistel网络的性质，将16个子密钥倒着使用即可解密 referenceDES-wikipedia","link":"/ctf/%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86/DES/"},{"title":"TEA","text":"简介TEA加密是一种经典的块加密，使用64位密文和128位(4个uint_32t)密钥，并使用Feistel框架进行加密Feistel框架指的是将密文分成两个等长块，每轮加密对两个块分别施加轮加密函数并进行交换，这点在TEA中体现为v0的累加值由v1计算得到，反之亦然注意使用TEA加密时如果密文小于64位(bit)要填充0字节占位，否则由于指针类型转换会将垃圾数据引入加密，当密文大于64位时要将密文分块分别执行TEA加密 特征应主要关注其Feistel网络结构而不是关注常量，因为TEA加密的加密计算方式，计算轮次，累加常量均可以魔改，但是密文被分为两个块并在每轮加密中采用相似的加密函数这个特点是不会变的，同时关注每轮中v0,v1分别由v1,v0计算得到，密钥通常为128位即4个uint_32t 实现12345678910111213void teaEncrypt(uint32_t *v, uint32_t *k){ uint32_t sum = 0, v0 = v[0], v1 = v[1]; // 将输入分为两个32位的块 uint32_t delta = 0x9E3779B9; //初始常量，可以为任何数 for (int i = 0; i &lt; 32; i++) { v0 += ((v1 &lt;&lt; 4) + k[0]) ^ (v1 + sum) ^ ((v1 &gt;&gt; 5) + k[1]); // 轮加密函数 sum += delta; v1 += ((v0 &lt;&lt; 4) + k[2]) ^ (v0 + sum) ^ ((v0 &gt;&gt; 5) + k[3]); // 轮加密函数 } v[0] = v0; // 应用修改 v[1] = v1;} 解密因为TEA加密是由Feistel框架设计来的，所以解密Feistel密码的方式对TEA也适用，我们只需根据加密完的最后状态，反向执行同样轮次的轮加密，就能解出明文 1234567891011121314void teaDecrypt(uint32_t *v, uint32_t *k){ uint32_t sum = 0, v0 = v[0], v1 = v[1]; uint32_t delta = 0x9E3779B9; sum = delta * 32; // 获取最终状态的累加和 for (int i = 0; i &lt; 32; i++) { v1 -= ((v0 &lt;&lt; 4) + k[2]) ^ (v0 + sum) ^ ((v0 &gt;&gt; 5) + k[3]); // 因为v1是最后被计算的，所以解密时要先计算v1 sum -= delta; // 累加改为递减 v0 -= ((v1 &lt;&lt; 4) + k[0]) ^ (v1 + sum) ^ ((v1 &gt;&gt; 5) + k[1]); } v[0] = v0; v[1] = v1;} 完整代码12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;bits/stdc++.h&gt;using namespace std;void teaEncrypt(uint32_t *v, uint32_t *k){ uint32_t sum = 0, v0 = v[0], v1 = v[1]; uint32_t delta = 0x9E3779B9; for (int i = 0; i &lt; 32; i++) { v0 += ((v1 &lt;&lt; 4) + k[0]) ^ (v1 + sum) ^ ((v1 &gt;&gt; 5) + k[1]); sum += delta; v1 += ((v0 &lt;&lt; 4) + k[2]) ^ (v0 + sum) ^ ((v0 &gt;&gt; 5) + k[3]); } v[0] = v0; v[1] = v1;}void teaDecrypt(uint32_t *v, uint32_t *k){ uint32_t sum = 0, v0 = v[0], v1 = v[1]; uint32_t delta = 0x9E3779B9; sum = delta * 32; for (int i = 0; i &lt; 32; i++) { v1 -= ((v0 &lt;&lt; 4) + k[2]) ^ (v0 + sum) ^ ((v0 &gt;&gt; 5) + k[3]); sum -= delta; v0 -= ((v1 &lt;&lt; 4) + k[0]) ^ (v1 + sum) ^ ((v1 &gt;&gt; 5) + k[1]); } v[0] = v0; v[1] = v1;}int main(){ uint32_t key[4] = {0x01234567, 0x89ABCDEF, 0xFEDCBA98, 0x76543210}; char plaintext[] = &quot;Eleven11&quot;; teaEncrypt((uint32_t *)plaintext, key); for (int i = 0; i &lt; 8; i++) printf(&quot;%02X &quot;, plaintext[i] &amp; 0xFF); printf(&quot;\\n&quot;); teaDecrypt((uint32_t *)plaintext, key); for (int i = 0; i &lt; 8; i++) printf(&quot;%c&quot;, plaintext[i]); return 0;} refernceTEA-wikipediaFeistel network-wikipedia","link":"/ctf/%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86/TEA/"},{"title":"XTEA","text":"简介省流：TEA的大杯版 因为TEA加密有密钥调度算法过于简单(直接调用),密钥之间等价(每个密钥都被平均的使用)这两个缺陷，所以有了XTEA加密，XTEA将密钥调度的算法改为非线性的，并且略微修改了轮加密计算方法 特征XTEA最大的特征就是每次加密使用的密钥由当前sum的累加值决定，通常是sum经过计算后&amp;3，其余的特征和TEA加密基本相同 实现12345678910111213void xteaEncrypt(uint32_t *v, uint32_t *k){ uint32_t sum = 0, v0 = v[0], v1 = v[1]; uint32_t delta = 0x9E3779B9; for (int i = 0; i &lt; 32; i++) { v0 += (((v1 &lt;&lt; 4) ^ (v1 &gt;&gt; 5)) + v1) ^ (sum + k[sum &amp; 3]); // 使用非线性方式调用key sum += delta; v1 += (((v0 &lt;&lt; 4) ^ (v0 &gt;&gt; 5)) + v0) ^ (sum + k[(sum &gt;&gt; 11) &amp; 3]); } v[0] = v0; v[1] = v1;} 解密虽然XTEA针对TEA进行了很多改进，但是对于逆向工程来说，我们并不是进行黑盒分析，所以XTEA和TEA并没有很大不同，直接使用Feistel密码的解法把运算过程反过来即可 1234567891011121314void xteaDecrypt(uint32_t *v, uint32_t *k){ uint32_t sum = 0, v0 = v[0], v1 = v[1]; uint32_t delta = 0x9E3779B9; sum = delta * 32; for (int i = 0; i &lt; 32; i++) { v1 -= (((v0 &lt;&lt; 4) ^ (v0 &gt;&gt; 5)) + v0) ^ (sum + k[(sum &gt;&gt; 11) &amp; 3]); sum -= delta; v0 -= (((v1 &lt;&lt; 4) ^ (v1 &gt;&gt; 5)) + v1) ^ (sum + k[sum &amp; 3]); } v[0] = v0; v[1] = v1;} 完整代码123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;bits/stdc++.h&gt;using namespace std;void xteaEncrypt(uint32_t *v, uint32_t *k){ uint32_t sum = 0, v0 = v[0], v1 = v[1]; uint32_t delta = 0x9E3779B9; for (int i = 0; i &lt; 32; i++) { v0 += (((v1 &lt;&lt; 4) ^ (v1 &gt;&gt; 5)) + v1) ^ (sum + k[sum &amp; 3]); sum += delta; v1 += (((v0 &lt;&lt; 4) ^ (v0 &gt;&gt; 5)) + v0) ^ (sum + k[(sum &gt;&gt; 11) &amp; 3]); } v[0] = v0; v[1] = v1;}void xteaDecrypt(uint32_t *v, uint32_t *k){ uint32_t sum = 0, v0 = v[0], v1 = v[1]; uint32_t delta = 0x9E3779B9; sum = delta * 32; for (int i = 0; i &lt; 32; i++) { v1 -= (((v0 &lt;&lt; 4) ^ (v0 &gt;&gt; 5)) + v0) ^ (sum + k[(sum &gt;&gt; 11) &amp; 3]); sum -= delta; v0 -= (((v1 &lt;&lt; 4) ^ (v1 &gt;&gt; 5)) + v1) ^ (sum + k[sum &amp; 3]); } v[0] = v0; v[1] = v1;}int main(){ uint32_t key[4] = {0x01234567, 0x89ABCDEF, 0xFEDCBA98, 0x76543210}; char plaintext[] = &quot;Eleven11&quot;; xteaEncrypt((uint32_t *)plaintext, key); for (int i = 0; i &lt; 8; i++) printf(&quot;%02X &quot;, plaintext[i] &amp; 0xFF); printf(&quot;\\n&quot;); xteaDecrypt((uint32_t *)plaintext, key); for (int i = 0; i &lt; 8; i++) printf(&quot;%c&quot;, plaintext[i]); return 0;} refernceXTEA-wikipediaFeistel network-wikipedia","link":"/ctf/%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86/XTEA/"},{"title":"XXTEA","text":"简介省流：TEA的超大杯版 XXTEA是XTEA的改进版，与它的前身不同，XXTEA大量魔改了原来的加密结构，首先是采用了非对称Feistel网络结构，数据不再被分为两个32位块，同时也不再一次只处理64位的数据，而是直接把所有数据分为多个32位块，然后用CBC模式循环加密，令块数为n，则一轮加密指的是将这n个块的数据各变换一次，总的加密轮次由round=6+52/n给出，注意这个公式仅仅是为了在安全性和性能之间做出平衡，理论上加密的轮次并没有要求。加密函数MX也进行了修改，更换了计算方式和密钥选择方式。 特征标准版本的XXTEA加密循环轮次由数据规模n绝定，当然rounds=6+52/n这个公式完全可以魔改，然后是每轮加密中的CBC结构特征，以及128位密钥 实现12345678910111213141516171819202122#define MX ((z &gt;&gt; 5 ^ y &lt;&lt; 2) + (y &gt;&gt; 3 ^ z &lt;&lt; 4) ^ (sum ^ y) + (k[p &amp; 3 ^ e] ^ z))void xxteaEncrtpy(uint32_t *v, size_t n, uint32_t *k){ uint32_t y, z, sum; uint32_t p, rounds, e; uint32_t delta = 0x9E3779B9; rounds = 6 + 52 / n; sum = 0; z = v[n - 1]; do { sum += delta; e = (sum &gt;&gt; 2) &amp; 3; // 引入非线性计算，使得每次取出的key值缺少规律 for (p = 0; p &lt; n - 1; p++) { y = v[p + 1]; z = v[p] += MX; // 每个块加密是增加的偏移量实际上由上一个块(z)和下一个块(y)的值和sum共同决定 } y = v[0]; // 此处其实是循环加密的端点，当然可以对下标取模把这部分写进循环里 z = v[n - 1] += MX; } while (--rounds); // 实际上是把相同的操作重复round轮} 解密虽然整个结构进行了大程度魔改，但仍是Fesitel网络，所以只要想办法把运算逆转过来就能解密 123456789101112131415161718192021void xxteaDecrypt(uint32_t *v, size_t n, uint32_t *k){ uint32_t y, z, sum; uint32_t p, rounds, e; uint32_t delta = 0x9E3779B9; rounds = 6 + 52 / n; sum = rounds * delta; y = v[0]; // n-1号块的下一个块是0号块 do { e = (sum &gt;&gt; 2) &amp; 3; for (p = n - 1; p &gt; 0; p--) // 反向循环 { z = v[p - 1]; // 因为是反着循环，所以这里是上一个块 y = v[p] -= MX; // 这里是也是取上一个和下一个块的值作为参数 } z = v[n - 1]; // 0号块的上一个块是n-1号块 y = v[0] -= MX; sum -= delta; } while (--rounds);} 完整代码代码中加密数据长度正好为64位，注意当长度不为32位的倍数时记得占位填充 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;bits/stdc++.h&gt;using namespace std;#define MX ((z &gt;&gt; 5 ^ y &lt;&lt; 2) + (y &gt;&gt; 3 ^ z &lt;&lt; 4) ^ (sum ^ y) + (k[p &amp; 3 ^ e] ^ z))void xxteaEncrtpy(uint32_t *v, size_t n, uint32_t *k){ uint32_t y, z, sum; uint32_t p, rounds, e; uint32_t delta = 0x9E3779B9; rounds = 6 + 52 / n; sum = 0; z = v[n - 1]; do { sum += delta; e = (sum &gt;&gt; 2) &amp; 3; // 引入非线性计算，使得每次取出的key值缺少规律 for (p = 0; p &lt; n - 1; p++) { y = v[p + 1]; z = v[p] += MX; // 每个块加密是增加的偏移量实际上由上一个块(z)和下一个块(y)的值和sum共同决定 } y = v[0]; // 此处其实是循环加密的端点，当然可以对下标取模写进循环里 z = v[n - 1] += MX; } while (--rounds); // 实际上是把相同的操作重复round轮}void xxteaDecrypt(uint32_t *v, size_t n, uint32_t *k){ uint32_t y, z, sum; uint32_t p, rounds, e; uint32_t delta = 0x9E3779B9; rounds = 6 + 52 / n; sum = rounds * delta; y = v[0]; // n-1号块的下一个块是0号块 do { e = (sum &gt;&gt; 2) &amp; 3; for (p = n - 1; p &gt; 0; p--) // 反向循环 { z = v[p - 1]; // 因为是反着循环，所以这里是上一个块 y = v[p] -= MX; // 这里是也是取上一个和下一个块的值作为参数 } z = v[n - 1]; // 0号块的上一个块是n-1号块 y = v[0] -= MX; sum -= delta; } while (--rounds);}int main(){ uint32_t k[4] = {0x01234567, 0x89abcdef, 0xfedcba98, 0x76543210}; char v[] = &quot;Eleven11&quot;; xxteaEncrtpy((uint32_t *)v, strlen(v) / 4, k); for (int i = 0; i &lt; 8; i++) printf(&quot;%c&quot;, v[i] &amp; 0xFF); printf(&quot;\\n&quot;); xxteaDecrypt((uint32_t *)v, strlen(v) / 4, k); for (int i = 0; i &lt; 8; i++) printf(&quot;%c&quot;, v[i]); printf(&quot;\\n&quot;); return 0;} referenceXXTEA-wikipedia","link":"/ctf/%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86/XXTEA/"},{"title":"加密&amp;编码算法精读目录","text":"对称加密是逆向工程中重要的知识点，这部分笔记对常见的对称加密算法和一些编码算法进行了精读，力求完全剖析加密的具体流程和实现，而不是止步于特征判断 目录 RC4TEAXTEAXXTEADES普通AESTODO： 白盒AESBASE64","link":"/ctf/%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%E7%B2%BE%E8%AF%BB%E7%9B%AE%E5%BD%95/"},{"title":"frida常用api备忘录","text":"一些frida的api备忘录 javascript APIProcessProcess.id : number返回目标进程的PID 1console.log(&quot;processid = &quot;, Process.id); 12$ python launch.py processid = 3819 Process.arch : String返回目标进程的架构 1console.log(&quot;processArch = &quot;, Process.arch); 12$ python launch.py processArch = x64 get和find系的函数建议使用get系,在查找失败时get抛出错误,而find返回NULLProcess.getModuleByAddress(address : NativePointer) : Module address为实际地址Process.getModuleByName(name : String) : Module 根据地址或名称返回 已加载的 目标库(.so库)的对象(Module对象)，地址需提供原生指针 123var lib: Module = Process.getModuleByName(&quot;liba0x9.so&quot;);var lb: Module = Process.getModuleByAddress(lib.base);console.log(&quot;lbname = &quot;, lb.name); 12$ python launch.pylbname = liba0x9.so Process.enumerateModules() : Module[]返回所有已加载的.so库，返回内容是Module对象组成的js数组 1234567var ls = Process.enumerateModules(); for (let i = 0; i &lt; ls.length; i++) { console.log(ls[i].base); console.log(ls[i].name); console.log(ls[i].path); console.log(&quot;------&quot;); } 123456780x768bb30ca000libgraphicsenv.so/system/lib64/libgraphicsenv.so------0x768bb6608000libgui.so/system/lib64/libgui.so..... ThreadThread.backtrace(context, backtracer) : NativePointer[]在java层不如直接调用android.util.log好用，主要用于追踪native层调用栈，通常加上this.context，backtracer有.FUZZY和.ACCURATE两种模式可选返回当前调用栈，返回类型是NativePointer组成的js数组，使用DebugSymbolfromAddress转化为可读符号 123456789var lib: Module = Module.load(&quot;liba0x9.so&quot;); console.log(lib.enumerateExports()[0].name); Interceptor.attach(lib.getExportByName(lib.enumerateExports()[0].name), { onEnter(args) { console.log(Thread.backtrace(this.context, Backtracer.ACCURATE).map(DebugSymbol.fromAddress).join('\\n')); }, onLeave(retval) { retval.replace(1337 as any); }, }) 1234$ python launch.pyJava_com_ad2001_a0x9_MainActivity_check_1flag0x768914fa0a2c libart.so!art_quick_generic_jni_trampoline+0xdc0x768914f83912 libart.so!MterpHelpers+0x1f5 ModuleModule类本身的属性 member use name : String 库名 base : NativePointer 库基地址 size : number 库大小 path : String 库的绝对路径 ModuleObj.enumerateImports() : ModuleImportDetails[]返回这个库的所有导入符号,类型为ModuleImportDetails组成的js数组 ModuleImportDetailsModuleImportDetails类的属性 member use type : ModuleImportType (function | variable) 导入符号的类型 name : String 导入符号的名称 module : String 导入符号来自哪个文件 address : NativePointer 导入符号在内存中的地址(绝对地址)，用于直接调用或修改导入函数 slot : NativePointer 导入表中指向导入函数的指针,用于重定向导入函数 123var lib: Module = Module.load(&quot;liba0x9.so&quot;);var ls = lib.enumerateImports();console.log(ls[0].name, &quot;from module :&quot;, ls[0].module); 12$ python launch.py __cxa_finalize from module : /apex/com.android.runtime/lib64/bionic/libc.so ModuleObj.enumerateExports() : ModuleExportDetails[]返回这个库的所有导出符号,类型为ModuleExportDetails组成的js数组 member use type : ModuleExportType (function | variable) 导出符号的类型 name : String 导出符号的名称 address : NativePointer 导出符号在内存中的地址(绝对地址)，用于直接调用或修改导出函数 ModuleObj.getExportByName(exportName : String) : NativePointer根据名称返回对应导出符号的指针，是frida hook native层函数的主要方法 Module.load(name : String) : Module根据名称(是的就是名称，至少vsc的frida type hint 里提示的是输入名称)返回对应native库的对象，与Process.getModuleByxxx的不同是该方法无需目标库已被加载，且使用该方法可以手动加载目标库 12var lib: Module = Module.load(&quot;libfrida0xa.so&quot;);console.log(lib.name); 12$ python launch.pylibfrida0xa.so Module.ensureInitialized(name : String) : void在目标库加载完成前阻塞程序进行 Module.getBaseAddress(name : String) : NativePointer返回目标库的基地址,等同于Module.load(name).base Module.getExportByName(moduleName : String | null, exportName : String) : NativePointer根据库名和符号名查找对应的导出符号，库名可缺省，此时在全局对该符号进行搜索 MemoryMemory.scan(address : NativePointer, size : number, pattern : String, callbacks : MemoryScanCallbacks) : void这是一个异步函数，用于在内存中扫描对应的模式，address指定了起始地址，size指定了扫描的字节数pattern是一个模式串，必须为以下任意的格式之一1.完全匹配 “1F 13 00 2F”2.通配符 “?F 13 00 ??” 其中?在匹配时可以是0~F中的任意一个3.掩码 “”13 37 13 37 : 1F FF FF F1”” 后面的为掩码，掩码中为1的位表示需要匹配，为0的位则可以是任意值 MemoryScanCallbacksMemoryScanCallbacks 是一个结构体，定义如下 1234567{ onMatch(address : NativePointer, size : number) : function //匹配成功的回调函数，address为成功匹配的地址，size为匹配到的长度 //该函数可通过 return 'stop' 提前结束 onError(reason : String) : function //处理错误的回调函数 onComplete() ： function //匹配结束的回调函数} 这个函数的同步版本为Memory.scanSync(address, size, pattern),返回由匹配到的address和size组成的对象的数组 Memory.protect(address : NativePointer, size : number, protection : String) : boolean修改对应位置内存的权限，返回true表示操作成功，protection为形同”rwx”的字符串 Memory.patchCode(address : NativePointer, size : number, apply : function) : voidapply里是具体要对内存进行修改的操作，address为起始地址，size为修改区域的字节数 NativeFunction获取native层函数的引用 NativeFunction(address, returnType, argTypes[, abi])创建方法var func = new NativeFunction(address, returnType, argTypes[, abi])address : NativePointer 函数地址returnType : [type] 返回类型argTypes : [types…] 参数类型 1const getFlag = new NativeFunction(getFlagPtr, ['void'], ['int', 'int']); // 用例 可用类型 123456789101112131415161718192021voidpointerintuintlongulongcharucharsize_tssize_tfloatdoubleint8uint8int16uint16int32uint32int64uint64bool NativeCallback创建一个native函数回调并返回其指针，实际上就是由js层创建了一个native函数，可以传给native层与 NativeFunction 的区别是 NativeFunction 是从native层到js层，而 NativeCallback 是创建自己的原生函数创建方法new NativeCallback(func, returnType, argTypes[, abi])func是函数的js实现，其他和 NativeFunction 均相同 Interceptorfrida最重要的模块之一，用于hook native函数， Interceptor.attach( target , callbacks )target 为 NativePointer ,callback为 {onEnter: Function(args) , onLeave: Function (retval) }的经典组合注意此处虽然大多数情况下是hook函数，但是只要访问目标地址就会触发回调，所以也可以用base+offset来跟踪特定位置的内存Interceptor.attach 同样会返回一个对当前拦截器的引用，可以调用self.detach()方法解除当前拦截器 123456789101112// 该拦截器在触发第6次hook后会自动解除var cnt = 0; let cnthook = Interceptor.attach(lib.base.add(0x170B8), { onEnter: function () { console.log(&quot;some memory accessed&quot;); cnt++; console.log(cnt) if (cnt &gt; 5) { cnthook.detach(); } } }) TODO:InterceptorJavaXXXWriterXXXRelocatorhexdumprpc.exportsTiming events Python APIfrida的python层主要负责拉起进程以及与js通信，涉及的业务逻辑并不多 参考链接Frida 官方文档Frida-Labs","link":"/ctf/Andorid/firdaApi/firdaApi/"},{"title":"[GWCTF 2019]babyvm","text":"简单vm题，甚至可以直接对着字节码写handle 提示是vm题 打开修复下符号，确实是vm题进去修复下结构体，结构还是很明显的修完后基本知道在干什么了，直接去看text段，指令有五百多个byte，写个脚本解析 123456789101112131415161718192021222324252627282930313233343536373839404142434445i = 0f = open(&quot;output.txt&quot;, &quot;w&quot;, encoding=&quot;utf-8&quot;)cnt = 0while i &lt; len(text) and cnt &lt; 2: if text[i] == 0xF1: print(&quot;mov &quot;, end=&quot;&quot;, file=f) op = text[i+1] i += 2 num = text[i]+text[i+1]*256+text[i+2]*256*256+text[i+3]*256*256 if op == 0xE1: print(&quot;r0 = input[{}]&quot;.format(num), file=f) elif op == 0xE2: print(&quot;r1 = input[{}]&quot;.format(num), file=f) elif op == 0xE3: print(&quot;r2 = input[{}]&quot;.format(num), file=f) elif op == 0xE4: print(&quot;input[{}] = r0&quot;.format(num), file=f) elif op == 0xE5: print(&quot;r3 = input[{}]&quot;.format(num), file=f) elif op == 0xE7: print(&quot;input[{}] = r1&quot;.format(num), file=f) i += 4 elif text[i] == 0xF2: print(&quot;r0 ^= r1&quot;, file=f) i += 1 elif text[i] == 0xF5: print(&quot;readInput&quot;, file=f) i += 1 elif text[i] == 0xF4: print(&quot;rip++&quot;, file=f) i += 1 elif text[i] == 0xF7: print(&quot;r0 *= r3&quot;, file=f) i += 1 elif text[i] == 0xF8: print(&quot;swap r0 r3&quot;, file=f) i += 1 elif text[i] == 0xF6: print(&quot;r0 = r2 + 2*r1 + 3*r0&quot;, file=f) i += 1 elif text[i] == 0xF4: i += 1 cnt += 1 # print(i, hex(text[i]))f.close() 这题有个很恶心的地方，他text段有两段逻辑，并不是rip到0xF4就停止了，前一段是假flag，要用类似栈溢出的方法去第二段逻辑最后手动逆出真正的加密逻辑如下 123456789for i 1 ~ 5 input[i] ^= [i+1]input[6]=(input[8]+2*input[7]+3*input[6])*input[12]input[7]=(input[9]+2*input[8]+3*input[7])*input[12]input[8]=(input[10]+2*input[9]+3*input[8])*input[12]swap input[13] input[19]swap input[14] input[18]swap input[15] input[17] 直接逆即可注意到密文也是假的，真正的密文在一个没有交叉引用的函数里 12345678910111213141516171819202122sec = [0x69, 0x45, 0x2A, 0x37, 0x09, 0x17, 0xC5, 0x0B, 0x5C, 0x72, 0x33, 0x76, 0x33, 0x21, 0x74, 0x31, 0x5F, 0x33, 0x73, 0x72]for i in range(30, 127): if sec[8] == ((sec[10]+2*sec[9]+3*i)*sec[12]) &amp; 0xFF: sec[8] = i breakfor i in range(30, 127): if sec[7] == ((sec[9]+2*sec[8]+3*i)*sec[12]) &amp; 0xFF: sec[7] = i breakfor i in range(30, 127): if sec[6] == ((sec[8]+2*sec[7]+3*i)*sec[12]) &amp; 0xFF: sec[6] = i breaksec[15], sec[17] = sec[17], sec[15]sec[14], sec[18] = sec[18], sec[14]sec[13], sec[19] = sec[19], sec[13]for i in range(5, -1, -1): sec[i] ^= sec[i+1]for i in sec: print(hex(i), end=&quot; &quot;)","link":"/ctf/WP/buu/GWCTF%202019%20babyvm/"},{"title":"Unicorn 修复CEST&#x2F;CSEL有关间接跳转的一些例子","text":"本文中使用大量BianryNinja Python Api 和 Unicorn APi本文使用腾讯游戏安全大赛2023安卓初赛中的libsec2023.so作为样本已知bug：追溯时遇到循环会卡死还未实现指令前移 什么是间接跳转间接跳转指的是在程序原本正常的控制流中，将部分跳转指令的参数由常量改为寄存器值，并通过查表/实时计算地址的形式将原本的静态的地址隐藏起来，从而达到阻止反编译器分析的效果，目前主流的反编译器如ida，BinaryNinja对间接跳转的分析效果均不佳一则间接跳转的例子如下可以看到先对w0和0进行比较更新condition flag的值，然后初始化w8,w9两个寄存器值作为跳转的两种不同方向，在根据情况赋值x8的同时加载跳转表(0x72000+0xc20),然后把x8作为跳转表中的偏移获取对应的地址，注意此时的地址仍不是正确的，再最后执行一次add后才获得了正确的地址 如果我不会写自动化去除脚本该怎么办如果你主要使用ida，那么恭喜你这个样本你可以扔回收站了，ida作为一款纯静态分析工具完全无法实时计算地址对于BianryNinja，有两种方法可以凑合让反编译器恢复控制流，一是把data段的权限设置为只读，因为基于保守分析的原则如果data段可写的话反编译器完全不会去计算跳转地址（因为无法确认静态状态下的跳转表数据是否可信），当data段只读后对于一些计算相对简单的跳转翻译器会尝试去计算其目标，但是效果仍不佳，对于cset/csel这类带分支的间接跳转尤其 123456CSET/CSEL是arm汇编中的两种条件赋值指令CSEL的格式为 CESL dest source1 source2 condcond为条件标识，就是ge le eq之类的当条件满足时dest会由source1赋值，否则由source2赋值CSET的格式为 CSET dest cond如果条件满足则dest被置1，否则置0 这是一处修改data段权限的例子可以看到这处还算可以，整个跳转结构被解析成了一个switch 但并非每次都好用可以看到这里就没有处理出来，注意到计算地址时用到了w8，而网上追溯w8的值由x0所指的地址读取而来，根据arm64调用约定x0是一个函数的第一个参数，所以这是一处跨函数的间接跳转，一些必要参数由函数外传入，反编译器获取不了足够的上下文自然无法计算地址 还有一种方法是自己算出跳转地址后在BinaryNinja的medium IL 或 high IL 视图下给jump里的参数指定user value即告诉反编译器这个参数的值确保为用户指定的值，这样也可以一定程度获得勉强能看的结果，不过这种办法要获取地址，还是有点麻烦的 解决这个问题需要什么我们最终的目的是获取跳转的地址并把br修改成b #xxxxx 的常量跳转，还是上面的例子我们注意到这个结构有一些特点 结尾的最后两行add和br指令完全与程序的正常业务无关，patch掉他们完全没影响 理论上可以设置一个很远栈变量或者寄存器值（比如上文提到的从函数外传进来的x0），然后在计算地址时用到这个值，即不能确定模拟执行的起点 中间可以添加类似frida检测的逻辑将我们导向错误的控制流，而因为我们很难静态分析去对抗检测，所以使用trace获取跳转表再patch未必好用 可以得出几个结论 显然这个跳转只有满足cond和不满足两种情况，以eq为例，我们可以把最后两行无用的指令替换成 b.eq xxx 和 b.ne xxx这样一对互补的指令，这样既能覆盖所有跳转情况，也不会因为过早跳转导致错过必要的指令导致程序逻辑错误 模拟执行的可以分为两步，第一步是执行到csel之前，这时我们暂停执行并保存所有寄存器值，用于获取csel前的上文信息,然后我们从csel开始执行两次模拟执行，每次执行完后恢复寄存器信息，第一次将dest设为source1，第二次将dest块再执行，极端情况就寻找交叉引用，跳转到调用间接跳转所在的设为source2，用于获取cmp两种情况时不同的地址 虽然我们不能确定模拟执行的起点，一次缺少上下文的模拟必然会有两种结果 模拟过程中访问错误地址，直接让模拟执行抛出异常 计算出来的地址歪的离谱，很可能在text段之外 所以我们可以考虑多次尝试模拟执行，如果模拟执行过程中捕获到错误，或者最后发现地址值很离谱，就往前追溯一个基本块再执行，这样一直往前追溯直到计算出的地址通过校验为止 所以最后我们的流程就是先获取csel/cset前的寄存器信息，然后分别执行两次获取不同分支的结果，如果遇到错误就将模拟的范围提前并重新执行，最后获取正确地址后patch到最后两条指令的位置 具体实现模拟执行的准备工作因为so本身也不大，为了方便我们直接遍历所有段，把整个so都载入模拟执行bv是BinaryNinja在脚本执行时全局维护的一个单例，是和bn交互的接口，我们的各种信息都是通过bv提供的方法获取的 1234567891011uc = Uc(UC_ARCH_ARM64, UC_MODE_ARM)uc.mem_map(CODE_BASE, CODE_SIZE, UC_PROT_ALL) # 分配text段内存uc.mem_map(STACK_BASE, STACK_SIZE, UC_PROT_ALL) # 分配栈内存for segment in bv.segments: # 用bn API遍历所有段 if segment.readable: start = segment.start end = segment.end size = end-start print(&quot;[+] Mapping segment: [{}]&quot;.format(hex(segment.data_length))) content = bv.read(start, size) # 读取段数据 uc.mem_write(start, content) # 写入uc模拟器 寻找特征指令之后我们遍历所有指令，从中寻找带有间接跳转特征的br指令，具体流程为记录遇到的最后一个csel或cset，在遇到br后检测记录的csel和cset是否和br在同一个函数内，并且查看这句br指令否有bn自动打上的Unresolved Indirect Control Flow 标记，如果有则可以认为这是一处需要修复的间接跳转 12345678910111213141516171819202122232425262728293031323334353637383940414243lastCsel = None lastCset = None nextWork = None # 记录最后遇到的是csel还是cset for instruction in bv.instructions: # 遍历所有指令 curAddr = instruction[1] # print(curAddr) if instruction[0][0].text == &quot;csel&quot;: lastCsel = instruction nextWork = &quot;csel&quot; if instruction[0][0].text == &quot;cset&quot;: lastCset = instruction nextWork = &quot;cset&quot; if instruction[0][0].text == &quot;br&quot;: tags = bv.get_functions_containing(curAddr)[0].tags # 获取当前函数的所有tag curTag = None for tag in tags: if tag[1] == curAddr: #寻找br指令上的tag curTag = tag[2] break if curTag is None or not (curTag.type.name == &quot;Unresolved Indirect Control Flow&quot;): # 查看是否为间接控制流 continue # print(hex(curAddr)) curBB = bv.get_basic_blocks_at(curAddr)[0] # 获取当前指令所在的基本块 curFunc = bv.get_functions_containing(curAddr)[0] # 获取当前指令所在的函数 # print(curBB) if nextWork is None: continue try: if nextWork == &quot;csel&quot;: if lastCsel[1] &lt; curFunc.start or lastCsel[1] &gt; curBB.end: # 判断csel指令是否在当前函数内 continue workCsel(uc, bv, lastCsel, instruction, (curBB.start, curBB.end), (0xf4c0, 0x591d0), white=[curBB.start]) nextWork = None elif nextWork == &quot;cset&quot;: if lastCset[1] &lt; curFunc.start or lastCset[1] &gt; curBB.end: # 判断cset指令是否在当前函数内 continue workCset(uc, bv, lastCset, instruction, (curBB.start, curBB.end), (0xf4c0, 0x591d0), white=[curBB.start]) nextWork = None except Exception as e: # 捕获预期外的异常 print(&quot;[{}] Error: {}&quot;.format( hex(uc.reg_read(UC_ARM64_REG_PC)), e)) workCsel函数workCset函数和workCsel函数基本没什么区别，这里以workCsel函数为例 1def workCsel(uc: Uc, bv: BinaryView, lastCsel: list, Brinstruction: list, emuRange: Tuple, textSecRange: Tuple, white: list = [], depth: int = 0) 我们需要上一条csel指令的信息，br指令的信息，模拟执行的区间，text段的区间位置和一个白名单（后面会讲这个白名单有什么用），为了方便调试还记录当前搜索的深度depth 12345Hook = uc.hook_add(UC_HOOK_CODE, avoidBlHook, {&quot;bv&quot;: bv, &quot;white&quot;: white}) print(lastCsel) print(&quot;[+] work at {} -- {}&quot;.format(hex(emuRange[0]), hex(emuRange[1]))) print(&quot;[+] cur search depth: {}&quot;.format(depth)) 我们要先添加一个code hook，codehook是unicorn的一种机制，hook添加的回调函数会在每条指令执行前执行，我们可以用这个机制跳过一些我们不想进入的函数，hook的第三个参数是一些传递给回调的变量 avoidBLHook的实现模拟的过程肯定会遇到一些跳转指令，bl就是arm中的call指令，跳转后ret会恢复pc的值，我们可以假设bl跳过去的函数不对我们的计算产生影响，而且如果跳进系统调用里uc就无法模拟了（因为是导入函数），所以遇到bl我们就把pc+4（arm64指令的长度）跳过这条指令然后是我们在往前追溯的过程中，可能会遇到当前基本块是由某个条件跳转到达的，因为我们无法保证顺着模拟的时候一定满足跳转条件，具体情况如下图所以我们要把遇到的基本块的开头加入白名单，在bl时跳过不在白名单中的地址，在b.cond时强制跳转到在白名单中的地址 12345678910111213141516171819202122232425262728def avoidBlHook(uc: Uc, address, size, user_data): bv = user_data.get(&quot;bv&quot;) white = user_data.get(&quot;white&quot;) # 把传过来的白名单和bv取出来 assert isinstance(bv, BinaryView) # 不这样写编辑器不识别bv的类型 code = bv.get_disassembly(address) # 获取当前地址的指令 if &quot;bl&quot; in code: for tar in white: if hex(tar) in code: if debugMode: print(&quot;enter {}&quot;.format(hex(tar))) break else: # 遍历白名单，如果遍历完都没有break，说明当前指令要被跳过 if debugMode: print(&quot;[not {}] [skip {}] {}&quot;.format( list(map(hex, white)), hex(address), code)) uc.reg_write(UC_ARM64_REG_PC, address+4) # 把pc设置为pc+4 if &quot;b.&quot; in code: for tar in white: if hex(tar) in code: if debugMode: print(&quot;force jmp {}&quot;.format(hex(tar))) # 这里如果遇到了白名单中的地址，直接把pc覆写成这个地址，即强制跳转 uc.reg_write(UC_ARM64_REG_PC, tar) break else: if debugMode: print(&quot;skip unknown jmp target&quot;) uc.reg_write(UC_ARM64_REG_PC, address+4) # 否则就跳过（不然也可能会被导到不知道哪里去） 收集信息我们在收集信息的时候重置栈状态（为了确保每次开始执行时栈都是干净的没有上次的脏数据） 12345678910111213141516171819202122232425262728def save_regisers(uc: Uc): regs = {} for reg in ARM64_REG_MAP: if ARM64_REG_MAP[reg] is not None: regs[reg] = uc.reg_read(ARM64_REG_MAP[reg]) # 读取所有寄存器信息并储存 return regsdef emuToGetRegInitState(uc: Uc, start: int, end: int) -&gt; dict: stack_top = STACK_BASE + STACK_SIZE - 0x100 uc.reg_write(UC_ARM64_REG_SP, stack_top) # 设置栈指针 # 根据arm调用约定，初始的栈顶必须写8个0x00 uc.mem_write(stack_top, b&quot;\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00&quot;) uc.emu_start(start, end) # 开启模拟 return save_regisers(uc)regs = emuToGetRegInitState(uc, emuRange[0], lastCsel[1]) # 获取进入CSEL之前的寄存器状态 # 然后因为CSEL的赋值选择第一个还是第二个参数是和cond对应的，br跳转必然前面跟一个add类的计算指令来计算地址 # 也就是说，这里提供了两条指令的空间来让我们构造一对互补的b.cond ，于是就规避了可能误修改业务相关指令的麻烦 destReg = lastCsel[0][2].text trueReg = lastCsel[0][5].text falseReg = lastCsel[0][8].text cond = lastCsel[0][11].text brTarget = Brinstruction[0][2].text curAddr = Brinstruction[1] # 这里搜集一些指令的参数信息，具体为什么这么写因为bn的指令token就是这么约定的 执行模拟以获取跳转地址我们恢复寄存器状态，开始第一次执行 123456789101112131415161718def emuToGetJumpReg(uc: Uc, start: int, end: int, brTarget: str) -&gt; int: uc.emu_start(start, end) return uc.reg_read(ARM64_REG_MAP[brTarget])def recover_regisers(uc: Uc, regs: dict): for reg in ARM64_REG_MAP: if ARM64_REG_MAP[reg] is not None: uc.reg_write(ARM64_REG_MAP[reg], regs[reg]) # print(&quot;{} = {}&quot;.format(reg, hex(regs[reg])))recover_regisers(uc, regs)if trueReg == &quot;xzr&quot; or trueReg == &quot;wzr&quot;: # 这个主要是处理uc不能读取arm的0寄存器的问题，我们要手动赋0 uc.reg_write(ARM64_REG_MAP[destReg], 0)else: uc.reg_write(ARM64_REG_MAP[destReg], regs[trueReg]) # print(regs[trueReg])trueDest = emuToGetJumpReg(uc, lastCsel[1]+4, curAddr, brTarget) 然后再次恢复寄存器状态，开始第二次执行 123456789101112131415recover_regisers(uc, regs)if falseReg == &quot;xzr&quot; or falseReg == &quot;wzr&quot;: uc.reg_write(ARM64_REG_MAP[destReg], 0)else: uc.reg_write(ARM64_REG_MAP[destReg], regs[falseReg])# print(regs[falseReg])falseDest = emuToGetJumpReg( uc, lastCsel[1]+4, curAddr, brTarget)if debugMode: print(&quot;[+] if ture then to:{} \\n else to:{}&quot;.format( hex(trueDest), hex(falseDest)))# print(&quot;[asm to replace]{}\\n[asm to replace]{}&quot;.format(bv.get_disassembly(# curAddr-4), bv.get_disassembly(curAddr)))uc.hook_del(Hook) # 在工作都做完后记得要解除hook，不然重复hook就挂了 处理错误地址当然模拟不可能那么快就做完，首先是校验地址是否正确 123456789101112131415161718if not (textSecRange[0] &lt;= trueDest &lt;= textSecRange[1]) or not (textSecRange[0] &lt;= falseDest &lt;= textSecRange[1]): # 检查地址是否在text段范围内 print(&quot;[x] wrong dest occured,try to fix&quot;) # 如果没有前驱基本块，说明此时处于函数的第一个基本块，要去找该函数的交叉引用 if len(bv.get_basic_blocks_at(emuRange[0])[0].incoming_edges) == 0: ref = list(bv.get_code_refs(emuRange[0])) print(&quot;{} ref {}&quot;.format(hex(emuRange[0]), ref)) preBB = bv.get_basic_blocks_at(ref[0].address)[ 0] # 获取交叉引用所处的基本块 white.append(preBB.start) # 把基本块开头加入跳转白名单 else: preBB = bv.get_basic_blocks_at( emuRange[0])[0].incoming_edges[0].source # 如果有前驱基本块，就获取它 white.append(preBB.start) # 把基本块开头加入跳转白名单 print(&quot;[x] try find missing arg at {}&quot;.format(preBB)) workCsel(uc, bv, lastCsel, Brinstruction, (preBB.start, emuRange[1]), textSecRange, white=white, depth=depth+1) # 递归向前追溯 else: # 如果正常就组装指令并patch buildOpAndPatch(bv, cond, trueDest, falseDest, curAddr) 捕捉非法地址读写除了错误地址外也可能模拟出现非法地址读写，我们捕获UcError并做和上文同样的处理 1234567891011121314151617181920except UcError as e: # 捕获到错误地址读写或其他错误行为 uc.hook_del(Hook) if e.errno == UC_ERR_READ_UNMAPPED or e.errno == UC_ERR_WRITE_UNMAPPED: print(&quot;[x] unmapped R/W occured,try to fix [{} {}]&quot;.format(hex( uc.reg_read(UC_ARM64_REG_PC)), bv.get_disassembly(uc.reg_read(UC_ARM64_REG_PC)))) else: print(&quot;[!!!] unhanddle error: {} [{} {}]&quot;.format(e, hex( uc.reg_read(UC_ARM64_REG_PC)), bv.get_disassembly(uc.reg_read(UC_ARM64_REG_PC)))) if len(bv.get_basic_blocks_at(emuRange[0])[0].incoming_edges) == 0: ref = list(bv.get_code_refs(emuRange[0])) print(&quot;{} ref {}&quot;.format(hex(emuRange[0]), ref)) preBB = bv.get_basic_blocks_at(ref[0].address)[0] white.append(preBB.start) else: preBB = bv.get_basic_blocks_at( emuRange[0])[0].incoming_edges[0].source white.append(preBB.start) print(&quot;[x] try find missing arg at {}&quot;.format(preBB)) workCsel(uc, bv, lastCsel, Brinstruction, (preBB.start, emuRange[1]), textSecRange, white=white, depth=depth+1) 完整的workCsel函数1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889def workCsel(uc: Uc, bv: BinaryView, lastCsel: list, Brinstruction: list, emuRange: Tuple, textSecRange: Tuple, white: list = [], depth: int = 0): try: Hook = uc.hook_add(UC_HOOK_CODE, avoidBlHook, {&quot;bv&quot;: bv, &quot;white&quot;: white}) print(lastCsel) print(&quot;[+] work at {} -- {}&quot;.format(hex(emuRange[0]), hex(emuRange[1]))) print(&quot;[+] cur search depth: {}&quot;.format(depth)) regs = emuToGetRegInitState(uc, emuRange[0], lastCsel[1]) # 获取进入CSEL之前的寄存器状态 # 然后因为CSEL的赋值选择第一个还是第二个参数是和cond对应的，br跳转必然前面跟一个add类的计算指令来计算地址 # 也就是说，这里提供了两条指令的空间来让我们构造一对互补的b.cond ，于是就规避了可能误修改业务相关指令的麻烦 destReg = lastCsel[0][2].text trueReg = lastCsel[0][5].text falseReg = lastCsel[0][8].text cond = lastCsel[0][11].text brTarget = Brinstruction[0][2].text curAddr = Brinstruction[1] # 这里搜集一些指令的参数信息，具体为什么这么写因为bn的指令token就是这么约定的 # print(regs) if debugMode: print(destReg, trueReg, falseReg, cond, brTarget) # hk = uc.hook_add(UC_HOOK_CODE, codeHook, {&quot;bv&quot;: bv}) recover_regisers(uc, regs) if trueReg == &quot;xzr&quot; or trueReg == &quot;wzr&quot;: # 这个主要是处理uc不能读取arm的0寄存器的问题，我们要手动赋0 uc.reg_write(ARM64_REG_MAP[destReg], 0) else: uc.reg_write(ARM64_REG_MAP[destReg], regs[trueReg]) # print(regs[trueReg]) trueDest = emuToGetJumpReg( uc, lastCsel[1]+4, curAddr, brTarget) recover_regisers(uc, regs) if falseReg == &quot;xzr&quot; or falseReg == &quot;wzr&quot;: uc.reg_write(ARM64_REG_MAP[destReg], 0) else: uc.reg_write(ARM64_REG_MAP[destReg], regs[falseReg]) # print(regs[falseReg]) falseDest = emuToGetJumpReg( uc, lastCsel[1]+4, curAddr, brTarget) if debugMode: print(&quot;[+] if ture then to:{} \\n else to:{}&quot;.format( hex(trueDest), hex(falseDest))) # print(&quot;[asm to replace]{}\\n[asm to replace]{}&quot;.format(bv.get_disassembly( # curAddr-4), bv.get_disassembly(curAddr))) uc.hook_del(Hook) if not (textSecRange[0] &lt;= trueDest &lt;= textSecRange[1]) or not (textSecRange[0] &lt;= falseDest &lt;= textSecRange[1]): # 检查地址是否在text段范围内 print(&quot;[x] wrong dest occured,try to fix&quot;) # 如果没有前驱基本块，说明此时处于函数的第一个基本块，要去找该函数的交叉引用 if len(bv.get_basic_blocks_at(emuRange[0])[0].incoming_edges) == 0: ref = list(bv.get_code_refs(emuRange[0])) print(&quot;{} ref {}&quot;.format(hex(emuRange[0]), ref)) preBB = bv.get_basic_blocks_at(ref[0].address)[ 0] # 获取交叉引用所处的基本块 white.append(preBB.start) # 把基本块开头加入跳转白名单 else: preBB = bv.get_basic_blocks_at( emuRange[0])[0].incoming_edges[0].source # 如果有前驱基本块，就获取它 white.append(preBB.start) # 把基本块开头加入跳转白名单 print(&quot;[x] try find missing arg at {}&quot;.format(preBB)) workCsel(uc, bv, lastCsel, Brinstruction, (preBB.start, emuRange[1]), textSecRange, white=white, depth=depth+1) else: # 如果正常就组装指令并patch buildOpAndPatch(bv, cond, trueDest, falseDest, curAddr) except UcError as e: # 捕获到错误地址读写或其他错误行为 uc.hook_del(Hook) if e.errno == UC_ERR_READ_UNMAPPED or e.errno == UC_ERR_WRITE_UNMAPPED: print(&quot;[x] unmapped R/W occured,try to fix [{} {}]&quot;.format(hex( uc.reg_read(UC_ARM64_REG_PC)), bv.get_disassembly(uc.reg_read(UC_ARM64_REG_PC)))) else: print(&quot;[!!!] unhanddle error: {} [{} {}]&quot;.format(e, hex( uc.reg_read(UC_ARM64_REG_PC)), bv.get_disassembly(uc.reg_read(UC_ARM64_REG_PC)))) if len(bv.get_basic_blocks_at(emuRange[0])[0].incoming_edges) == 0: ref = list(bv.get_code_refs(emuRange[0])) print(&quot;{} ref {}&quot;.format(hex(emuRange[0]), ref)) preBB = bv.get_basic_blocks_at(ref[0].address)[0] white.append(preBB.start) else: preBB = bv.get_basic_blocks_at( emuRange[0])[0].incoming_edges[0].source white.append(preBB.start) print(&quot;[x] try find missing arg at {}&quot;.format(preBB)) workCsel(uc, bv, lastCsel, Brinstruction, (preBB.start, emuRange[1]), textSecRange, white=white, depth=depth+1) 组装指令12345678910def buildOpAndPatch(bv: binaryview, cond: str, trueDest: int, falseDest: int, curAddr: int): trueJmp = &quot;b.{} #{}&quot;.format(cond, hex(trueDest-(curAddr-4))) falseJmp = &quot;b.{} #{}&quot;.format(ARM64_CONDS[cond], hex(falseDest-curAddr)) print(&quot;[asm gen]{} -&gt; {}&quot;.format(bv.get_disassembly(curAddr-4), trueJmp)) print(&quot;[asm gen]{} -&gt; {}&quot;.format(bv.get_disassembly(curAddr), falseJmp)) # 使用bn提供的指令转换api获得机械码 bv.write(curAddr-4, Architecture['aarch64'].assemble(trueJmp)) bv.write(curAddr, Architecture['aarch64'].assemble(falseJmp)) print(&quot;===================================================&quot;) 完整代码cest的处理和csel类似，只是把从源寄存器赋值改为了赋值为0/1，这里就不多赘述，直接给出完整的脚本代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357from binaryninja import *from unicorn import *from unicorn.arm64_const import *CODE_BASE = 0x0CODE_SIZE = 0x1200000+0x1000STACK_BASE = 0x30000000STACK_SIZE = 0x8000ARM64_REG_MAP = { 'x0': UC_ARM64_REG_X0, 'x1': UC_ARM64_REG_X1, 'x2': UC_ARM64_REG_X2, 'x3': UC_ARM64_REG_X3, 'x4': UC_ARM64_REG_X4, 'x5': UC_ARM64_REG_X5, 'x6': UC_ARM64_REG_X6, 'x7': UC_ARM64_REG_X7, 'x8': UC_ARM64_REG_X8, 'x9': UC_ARM64_REG_X9, 'x10': UC_ARM64_REG_X10, 'x11': UC_ARM64_REG_X11, 'x12': UC_ARM64_REG_X12, 'x13': UC_ARM64_REG_X13, 'x14': UC_ARM64_REG_X14, 'x15': UC_ARM64_REG_X15, 'x16': UC_ARM64_REG_X16, 'x17': UC_ARM64_REG_X17, 'x18': UC_ARM64_REG_X18, 'x19': UC_ARM64_REG_X19, 'x20': UC_ARM64_REG_X20, 'x21': UC_ARM64_REG_X21, 'x22': UC_ARM64_REG_X22, 'x23': UC_ARM64_REG_X23, 'x24': UC_ARM64_REG_X24, 'x25': UC_ARM64_REG_X25, 'x26': UC_ARM64_REG_X26, 'x27': UC_ARM64_REG_X27, 'x28': UC_ARM64_REG_X28, 'x29': UC_ARM64_REG_X29, 'x30': UC_ARM64_REG_X30, 'sp': UC_ARM64_REG_SP, 'w0': UC_ARM64_REG_X0, 'w1': UC_ARM64_REG_X1, 'w2': UC_ARM64_REG_X2, 'w3': UC_ARM64_REG_X3, 'w4': UC_ARM64_REG_X4, 'w5': UC_ARM64_REG_X5, 'w6': UC_ARM64_REG_X6, 'w7': UC_ARM64_REG_X7, 'w8': UC_ARM64_REG_X8, 'w9': UC_ARM64_REG_X9, 'w10': UC_ARM64_REG_X10, 'w11': UC_ARM64_REG_X11, 'w12': UC_ARM64_REG_X12, 'w13': UC_ARM64_REG_X13, 'w14': UC_ARM64_REG_X14, 'w15': UC_ARM64_REG_X15, 'w16': UC_ARM64_REG_X16, 'w17': UC_ARM64_REG_X17, 'w18': UC_ARM64_REG_X18, 'w19': UC_ARM64_REG_X19, 'w20': UC_ARM64_REG_X20, 'w21': UC_ARM64_REG_X21, 'w22': UC_ARM64_REG_X22, 'w23': UC_ARM64_REG_X23, 'w24': UC_ARM64_REG_X24, 'w25': UC_ARM64_REG_X25, 'w26': UC_ARM64_REG_X26, 'w27': UC_ARM64_REG_X27, 'w28': UC_ARM64_REG_X28, 'wzr': None, 'xzr': None,}# 每个条件码逻辑上对应的互补的条件ARM64_CONDS = { 'eq': 'ne', 'ne': 'eq', 'hs': 'lo', 'lo': 'hs', 'mi': 'pl', 'pl': 'mi', 'vs': 'vc', 'vc': 'vs', 'hi': 'ls', 'ls': 'hi', 'ge': 'lt', 'lt': 'ge', 'gt': 'le', 'le': 'gt', 'cs': 'cc', 'cc': 'cs',}def save_regisers(uc: Uc): regs = {} for reg in ARM64_REG_MAP: if ARM64_REG_MAP[reg] is not None: regs[reg] = uc.reg_read(ARM64_REG_MAP[reg]) # 读取所有寄存器信息并储存 return regsdef codeHook(uc: Uc, address, size, user_data): bv = user_data.get(&quot;bv&quot;) code = bv.get_disassembly(address) assert isinstance(bv, BinaryView) if address &gt;= 0x021e5c and address &lt;= 0x21e74: print(&quot;[{}]{}&quot;.format( hex(address), code)) if address &gt;= 0x000355f0 and address &lt;= 0x00035668: print(&quot;[{}]{}&quot;.format( hex(address), code))def recover_regisers(uc: Uc, regs: dict): for reg in ARM64_REG_MAP: if ARM64_REG_MAP[reg] is not None: uc.reg_write(ARM64_REG_MAP[reg], regs[reg]) # print(&quot;{} = {}&quot;.format(reg, hex(regs[reg])))def emuToGetRegInitState(uc: Uc, start: int, end: int) -&gt; dict: stack_top = STACK_BASE + STACK_SIZE - 0x100 uc.reg_write(UC_ARM64_REG_SP, stack_top) # 设置栈指针 # 根据arm调用约定，初始的栈顶必须写8个0x00 uc.mem_write(stack_top, b&quot;\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00&quot;) uc.emu_start(start, end) # 开启模拟 return save_regisers(uc)def emuToGetJumpReg(uc: Uc, start: int, end: int, brTarget: str) -&gt; int: uc.emu_start(start, end) return uc.reg_read(ARM64_REG_MAP[brTarget])debugMode = 1def avoidBlHook(uc: Uc, address, size, user_data): bv = user_data.get(&quot;bv&quot;) white = user_data.get(&quot;white&quot;) # 把传过来的白名单和bv取出来 assert isinstance(bv, BinaryView) # 不这样写编辑器不识别bv的类型 code = bv.get_disassembly(address) # 获取当前地址的指令 if &quot;bl&quot; in code: for tar in white: if hex(tar) in code: if debugMode: print(&quot;enter {}&quot;.format(hex(tar))) break else: # 遍历白名单，如果遍历完都没有break，说明当前指令要被跳过 if debugMode: print(&quot;[not {}] [skip {}] {}&quot;.format( list(map(hex, white)), hex(address), code)) uc.reg_write(UC_ARM64_REG_PC, address+4) # 把pc设置为pc+4 if &quot;b.&quot; in code: for tar in white: if hex(tar) in code: if debugMode: print(&quot;force jmp {}&quot;.format(hex(tar))) # 这里如果遇到了白名单中的地址，直接把pc覆写成这个地址，即强制跳转 uc.reg_write(UC_ARM64_REG_PC, tar) break else: if debugMode: print(&quot;skip unknown jmp target&quot;) uc.reg_write(UC_ARM64_REG_PC, address+4) # 否则就跳过（不然也可能会被导到不知道哪里去） # input()def buildOpAndPatch(bv: binaryview, cond: str, trueDest: int, falseDest: int, curAddr: int): trueJmp = &quot;b.{} #{}&quot;.format(cond, hex(trueDest-(curAddr-4))) falseJmp = &quot;b.{} #{}&quot;.format(ARM64_CONDS[cond], hex(falseDest-curAddr)) print(&quot;[asm gen]{} -&gt; {}&quot;.format(bv.get_disassembly(curAddr-4), trueJmp)) print(&quot;[asm gen]{} -&gt; {}&quot;.format(bv.get_disassembly(curAddr), falseJmp)) bv.write(curAddr-4, Architecture['aarch64'].assemble(trueJmp)) bv.write(curAddr, Architecture['aarch64'].assemble(falseJmp)) print(&quot;===================================================&quot;)def workCsel(uc: Uc, bv: BinaryView, lastCsel: list, Brinstruction: list, emuRange: Tuple, textSecRange: Tuple, white: list = [], depth: int = 0): try: Hook = uc.hook_add(UC_HOOK_CODE, avoidBlHook, {&quot;bv&quot;: bv, &quot;white&quot;: white}) print(lastCsel) print(&quot;[+] work at {} -- {}&quot;.format(hex(emuRange[0]), hex(emuRange[1]))) print(&quot;[+] cur search depth: {}&quot;.format(depth)) regs = emuToGetRegInitState(uc, emuRange[0], lastCsel[1]) # 获取进入CSEL之前的寄存器状态 # 然后因为CSEL的赋值选择第一个还是第二个参数是和cond对应的，br跳转必然前面跟一个add类的计算指令来计算地址 # 也就是说，这里提供了两条指令的空间来让我们构造一对互补的b.cond ，于是就规避了可能误修改业务相关指令的麻烦 destReg = lastCsel[0][2].text trueReg = lastCsel[0][5].text falseReg = lastCsel[0][8].text cond = lastCsel[0][11].text brTarget = Brinstruction[0][2].text curAddr = Brinstruction[1] # 这里搜集一些指令的参数信息，具体为什么这么写因为bn的指令token就是这么约定的 # print(regs) if debugMode: print(destReg, trueReg, falseReg, cond, brTarget) # hk = uc.hook_add(UC_HOOK_CODE, codeHook, {&quot;bv&quot;: bv}) recover_regisers(uc, regs) if trueReg == &quot;xzr&quot; or trueReg == &quot;wzr&quot;: # 这个主要是处理uc不能读取arm的0寄存器的问题，我们要手动赋0 uc.reg_write(ARM64_REG_MAP[destReg], 0) else: uc.reg_write(ARM64_REG_MAP[destReg], regs[trueReg]) # print(regs[trueReg]) trueDest = emuToGetJumpReg( uc, lastCsel[1]+4, curAddr, brTarget) recover_regisers(uc, regs) if falseReg == &quot;xzr&quot; or falseReg == &quot;wzr&quot;: uc.reg_write(ARM64_REG_MAP[destReg], 0) else: uc.reg_write(ARM64_REG_MAP[destReg], regs[falseReg]) # print(regs[falseReg]) falseDest = emuToGetJumpReg( uc, lastCsel[1]+4, curAddr, brTarget) if debugMode: print(&quot;[+] if ture then to:{} \\n else to:{}&quot;.format( hex(trueDest), hex(falseDest))) # print(&quot;[asm to replace]{}\\n[asm to replace]{}&quot;.format(bv.get_disassembly( # curAddr-4), bv.get_disassembly(curAddr))) uc.hook_del(Hook) if not (textSecRange[0] &lt;= trueDest &lt;= textSecRange[1]) or not (textSecRange[0] &lt;= falseDest &lt;= textSecRange[1]): # 检查地址是否在text段范围内 print(&quot;[x] wrong dest occured,try to fix&quot;) # 如果没有前驱基本块，说明此时处于函数的第一个基本块，要去找该函数的交叉引用 if len(bv.get_basic_blocks_at(emuRange[0])[0].incoming_edges) == 0: ref = list(bv.get_code_refs(emuRange[0])) print(&quot;{} ref {}&quot;.format(hex(emuRange[0]), ref)) preBB = bv.get_basic_blocks_at(ref[0].address)[ 0] # 获取交叉引用所处的基本块 white.append(preBB.start) # 把基本块开头加入跳转白名单 else: preBB = bv.get_basic_blocks_at( emuRange[0])[0].incoming_edges[0].source # 如果有前驱基本块，就获取它 white.append(preBB.start) # 把基本块开头加入跳转白名单 print(&quot;[x] try find missing arg at {}&quot;.format(preBB)) workCsel(uc, bv, lastCsel, Brinstruction, (preBB.start, emuRange[1]), textSecRange, white=white, depth=depth+1) else: # 如果正常就组装指令并patch buildOpAndPatch(bv, cond, trueDest, falseDest, curAddr) except UcError as e: # 捕获到错误地址读写或其他错误行为 uc.hook_del(Hook) if e.errno == UC_ERR_READ_UNMAPPED or e.errno == UC_ERR_WRITE_UNMAPPED: print(&quot;[x] unmapped R/W occured,try to fix [{} {}]&quot;.format(hex( uc.reg_read(UC_ARM64_REG_PC)), bv.get_disassembly(uc.reg_read(UC_ARM64_REG_PC)))) else: print(&quot;[!!!] unhanddle error: {} [{} {}]&quot;.format(e, hex( uc.reg_read(UC_ARM64_REG_PC)), bv.get_disassembly(uc.reg_read(UC_ARM64_REG_PC)))) if len(bv.get_basic_blocks_at(emuRange[0])[0].incoming_edges) == 0: ref = list(bv.get_code_refs(emuRange[0])) print(&quot;{} ref {}&quot;.format(hex(emuRange[0]), ref)) preBB = bv.get_basic_blocks_at(ref[0].address)[0] white.append(preBB.start) else: preBB = bv.get_basic_blocks_at( emuRange[0])[0].incoming_edges[0].source white.append(preBB.start) print(&quot;[x] try find missing arg at {}&quot;.format(preBB)) workCsel(uc, bv, lastCsel, Brinstruction, (preBB.start, emuRange[1]), textSecRange, white=white, depth=depth+1)def workCset(uc: Uc, bv: BinaryView, lastCset: list, Brinstruction: list, emuRange: Tuple, textSecRange: Tuple, white: list = [], depth: int = 0): try: Hook = uc.hook_add(UC_HOOK_CODE, avoidBlHook, {&quot;bv&quot;: bv, &quot;white&quot;: white, &quot;end&quot;: emuRange[1]}) print(lastCset) print(&quot;[+] work at {} -- {}&quot;.format(hex(emuRange[0]), hex(emuRange[1]))) print(&quot;[+] cur search depth: {}&quot;.format(depth)) regs = emuToGetRegInitState(uc, emuRange[0], lastCset[1]) destReg = lastCset[0][2].text cond = lastCset[0][5].text brTarget = Brinstruction[0][2].text curAddr = Brinstruction[1] if debugMode: print(destReg, cond, brTarget) recover_regisers(uc, regs) uc.reg_write(ARM64_REG_MAP[destReg], 1) trueDest = emuToGetJumpReg( uc, lastCset[1]+4, curAddr, brTarget) recover_regisers(uc, regs) uc.reg_write(ARM64_REG_MAP[destReg], 0) falseDest = emuToGetJumpReg( uc, lastCset[1]+4, curAddr, brTarget) if debugMode: print(&quot;[+] if ture then to:{} \\n else to:{}&quot;.format( hex(trueDest), hex(falseDest))) # print(&quot;[asm to replace]{}\\n[asm to replace]{}&quot;.format(bv.get_disassembly( # curAddr-4), bv.get_disassembly(curAddr))) uc.hook_del(Hook) if not (textSecRange[0] &lt;= trueDest &lt;= textSecRange[1]) or not (textSecRange[0] &lt;= falseDest &lt;= textSecRange[1]): print(&quot;[x] wrong dest occured,try to fix&quot;) print(&quot;incoming edges: {}&quot;.format( bv.get_basic_blocks_at(emuRange[0])[0].incoming_edges)) if len(bv.get_basic_blocks_at(emuRange[0])[0].incoming_edges) == 0: ref = list(bv.get_code_refs(emuRange[0])) print(&quot;{} ref {}&quot;.format(hex(emuRange[0]), ref)) preBB = bv.get_basic_blocks_at(ref[0].address)[0] white.append(preBB.start) else: preBB = bv.get_basic_blocks_at( emuRange[0])[0].incoming_edges[0].source white.append(preBB.start) print(&quot;[x] try find missing arg at {}&quot;.format(preBB)) workCset(uc, bv, lastCset, Brinstruction, (preBB.start, emuRange[1]), textSecRange, white=white, depth=depth+1) else: buildOpAndPatch(bv, cond, trueDest, falseDest, curAddr) except UcError as e: uc.hook_del(Hook) if e.errno == UC_ERR_READ_UNMAPPED or e.errno == UC_ERR_WRITE_UNMAPPED: print(&quot;[x] unmapped R/W occured,try to fix [{} {}]&quot;.format(hex( uc.reg_read(UC_ARM64_REG_PC)), bv.get_disassembly(uc.reg_read(UC_ARM64_REG_PC)))) else: print(&quot;[!!!] unhanddle error: {} [{} {}]&quot;.format(e, hex( uc.reg_read(UC_ARM64_REG_PC)), bv.get_disassembly(uc.reg_read(UC_ARM64_REG_PC)))) if len(bv.get_basic_blocks_at(emuRange[0])[0].incoming_edges) == 0: ref = list(bv.get_code_refs(emuRange[0])) print(&quot;{} ref {}&quot;.format(hex(emuRange[0]), ref)) preBB = bv.get_basic_blocks_at(ref[0].address)[0] white.append(preBB.start) else: preBB = bv.get_basic_blocks_at( emuRange[0])[0].incoming_edges[0].source white.append(preBB.start) print(&quot;[x] try find missing arg at {}&quot;.format(preBB)) workCset(uc, bv, lastCset, Brinstruction, (preBB.start, emuRange[1]), textSecRange, white=white, depth=depth+1)def solve(bv: BinaryView): uc = Uc(UC_ARCH_ARM64, UC_MODE_ARM) uc.mem_map(CODE_BASE, CODE_SIZE, UC_PROT_ALL) # 分配text段内存 uc.mem_map(STACK_BASE, STACK_SIZE, UC_PROT_ALL) # 分配栈内存 for segment in bv.segments: # 用bn API遍历所有段 if segment.readable: start = segment.start end = segment.end size = end-start print(&quot;[+] Mapping segment: [{}]&quot;.format(hex(segment.data_length))) content = bv.read(start, size) # 读取段数据 uc.mem_write(start, content) # 写入uc模拟器 lastCsel = None lastCset = None nextWork = None # 记录最后遇到的是csel还是cset for instruction in bv.instructions: # 遍历所有指令 curAddr = instruction[1] # print(curAddr) if instruction[0][0].text == &quot;csel&quot;: lastCsel = instruction nextWork = &quot;csel&quot; if instruction[0][0].text == &quot;cset&quot;: lastCset = instruction nextWork = &quot;cset&quot; if instruction[0][0].text == &quot;br&quot;: tags = bv.get_functions_containing(curAddr)[0].tags # 获取当前函数的所有tag curTag = None for tag in tags: if tag[1] == curAddr: # 寻找br指令上的tag curTag = tag[2] break # 查看是否为间接控制流 if curTag is None or not (curTag.type.name == &quot;Unresolved Indirect Control Flow&quot;): continue # print(hex(curAddr)) curBB = bv.get_basic_blocks_at(curAddr)[0] # 获取当前指令所在的基本块 curFunc = bv.get_functions_containing(curAddr)[0] # 获取当前指令所在的函数 # print(curBB) if nextWork is None: continue try: if nextWork == &quot;csel&quot;: if lastCsel[1] &lt; curFunc.start or lastCsel[1] &gt; curBB.end: # 判断csel指令是否在当前函数内 continue workCsel(uc, bv, lastCsel, instruction, (curBB.start, curBB.end), (0xf4c0, 0x591d0), white=[curBB.start]) nextWork = None elif nextWork == &quot;cset&quot;: if lastCset[1] &lt; curFunc.start or lastCset[1] &gt; curBB.end: # 判断cset指令是否在当前函数内 continue workCset(uc, bv, lastCset, instruction, (curBB.start, curBB.end), (0xf4c0, 0x591d0), white=[curBB.start]) nextWork = None except Exception as e: # 捕获预期外的异常 print(&quot;[{}] Error: {}&quot;.format( hex(uc.reg_read(UC_ARM64_REG_PC)), e))solve(bv) 直接选择bn的run script files执行，看到修复效果还是很好的因为bn是动态分析的，所以要多次运行脚本才能修复每次新识别的指令 鸣谢感谢 @l4n 师傅的文章对本篇文章的启发 一种基于unicorn的寄存器间接跳转混淆去除方式同样感谢 @Itlly 师傅 和 @Jerem1ah 师傅在脚本开发过程中提供的建议","link":"/ctf/unicornSolveCselCset/"},{"title":"ACTF2025 unstoppable","text":"题目本身的意图挺好的，但出题人写的慢的和龟一样的图灵机实现多少有点史了因为龟一样的爆破速度我的二血变三血了frida还是太超模了 主函数进来先看主函数，输入有2703个，而且似乎有意对输入的范围做了检测，使其限定在0~5004input先进入sub_555555559560这个函数，这个函数里面乱七八糟的一堆指针操作乱飞，下面那个重命名为get_arg2的也是一样，让人非常怀疑这个v26和v22是不是结构体(图片里是已经修复过结构体定义的，懒得重新从原附件开始写了)，所以动调输入一些数检查下每次输入后给v22指向的地址命名标记可以看到确实是结构体，而且我们的输入也被存在了每个结构体中，另一个明显的特征是结构体里有大量互相指的指针，算法学的好的已经知道这是什么了，但万一我没打过acm怎么办呢，这里可以画图把每个结构体和他指向的对象连起来这一眼二叉搜索树了，也就是我们的输入被扔进了一颗二叉搜索树里，然后v22,v26都是相关的树节点类型，可以怀疑是根节点之类的，在下面的while循环中也有使用，二叉搜索树的重要性质就是先序遍历就是有序数列，合理怀疑这是在对我们的输入进行排序，我们把输入的组数patch少一点，到while处的逻辑中验证猜想另外注意到上面的循环会对我们的输入去重，如果输入的数已经在树中出现过就会把输入置0再插入树中 第二处循环再get_Input处下断点，可以发现v18确实是按从小到大取出的，但这时发现程序会卡死，经过二分法下断点发现是sub_555555559890这个函数导致了卡死，但巧合的是输入1不会卡死，输入2会，因为输入是排序的，经过多次尝试发现1,3,5均不会卡死（试出来几个不会卡死的方便动调下面的函数），再来看这个函数的逻辑，他接受v17作为传参，而v17在前一个函数进行初始化，经检查v17是一个指针数组，上面那个函数是负责把chiperlist中的数据刷入v17中，发现在取偏移时是按30的倍数取的，检查发现chiperlist正好是5005*30组数据，和我们输入的限制对应再看这个a是怎么出来的，sub_55555555A5B0的第一个参数是一个静态未初始化的全局量，第二个参数是我们取出的输入，我们查交叉引用看这个全局量哪来的可以看到是一个质数表，而且长度正好也是5005，结合动调确认就是查表获得质数表对应下标的数，那也就是说a和b都是查表查出来的，我们的输入其实是2703个合法下标用于在两次查表中获取对应的结果，如果输入不对则会在获取b的时候卡死在下面那个qpow就很清晰了，点进去直接能看出来是快速幂算法（看不出来我也没办法，和源码长得几乎完全一样了），下面那个函数是调用mod API进行取模操作总的来说这块就是把输入从小到大取出，分别进行两次查表获取$a,b$,然后计算$a^b$并累乘到v25上 哈希循环结束后有一个flatten过的函数，用d810解开后直接把整个函数体扔给ai识别，识别为MurmurHash3_x64_128哈希算法，不过他具体怎么样我们不关心，只要知道他会把v25作为种子，把congratulations的哈希值存入hashdest这个buffer即可，再看下面的输出格式，也就是flag主体其实就是这个hash 如何获取种子种子是累乘得到的，a就是查质数，难点在于获取b，可以去赌他获取b的算法在每次执行都是独立的，可以尝试输入(1,3,5),(3,5),(1,5),(1,3)做尝试，发现确实是独立的，那么考虑用frida主动调用去爆破合法的2703组回显，然后再主动调用他实现的qpow和mod函数结合素数表算出种子，最后动调把种子patch进hash函数获取flag 爆破脚本123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657from frida import *import sysimport threadingimport timedef kill(pid): device.kill(pid)device = get_local_device()res = []for i in range(2501, 5005): try: pid = device.spawn([&quot;./unstoppable&quot;]) session = device.attach(pid) except ProcessNotFoundError: print(f&quot;[!] {i:04x} Process not found, skip&quot;) continue js_code = f&quot;&quot;&quot; var baseOffset = 0x555555554000; var initopPtr = Module.getBaseAddress(&quot;unstoppable&quot;).sub(baseOffset).add(0x5555555596A0); var input = {i}; var initop = new NativeFunction(initopPtr, 'int64', ['pointer', 'pointer']); var opBuf = Memory.alloc(0x1000); var oplist = Module.getBaseAddress(&quot;unstoppable&quot;).sub(baseOffset).add(0x55555556D110); initop(opBuf, oplist.add(30 * input)); var vmPtr = Module.getBaseAddress(&quot;unstoppable&quot;).add(0x5890); var vm = new NativeFunction(vmPtr, 'int64', ['pointer']); var result = vm(opBuf); send(result); &quot;&quot;&quot; script = session.create_script(js_code) script.on('message', lambda message, data: res.append((message['payload'], i))) timer = threading.Timer(10, kill, args=[pid]) try: timer.start() device.resume(pid) script.load() time.sleep(10.1) except TransportError: print(f&quot;[!] {i:04x} transport closed, killed or hung&quot;) continue finally: timer.cancel() try: session.detach() except: passprint(f&quot;Total results: {len(res)}&quot;)print(res) 要注意的是使用frida爆破每次要重新起新进程，因为如果输入错了程序就会卡住，而主动调用是阻塞式的，然后每次起进程设置一个时限来分辨是正确输入还是卡死了，还要主动杀掉拉起的进程（不然跑5005轮马上cpu就爆了，frida不会主动杀掉自己拉起来的进程），至于这里为什么一次调用设10s时限就要问出题人的图灵机怎么写的这么卡了，可以把5005切成多片跑，以及做好要跑大半天的准备 调用qpow执行累乘为了防止出题人实现的mod抄错，所以干脆也用frida 12345678910111213141516171819202122232425262728293031323334setImmediate(function () { var baseOffset = 0x555555554000; var ModPtr = Module.getBaseAddress(&quot;unstoppable&quot;) .sub(baseOffset) .add(0x555555559160); var QpowPtr = Module.getBaseAddress(&quot;unstoppable&quot;) .sub(baseOffset) .add(0x5555555591A0); console.log(&quot;ModPtr: &quot; + ModPtr); console.log(&quot;QpowPtr: &quot; + QpowPtr); var qpow = new NativeFunction(QpowPtr, 'uint64', ['pointer', 'uint64', 'uint64']); var mod = new NativeFunction(ModPtr, 'uint64', ['pointer', 'uint64', 'uint64']); var seed = uint64(1); var junk = Memory.alloc(0x10); for (var i = 0; i &lt; blist.length; i++) { var j = blist[i][1]; var a = uint64(primelist[j]); var b = uint64(blist[i][0]); try { var tmp = qpow(junk, a, b); seed = mod(junk, seed, tmp); console.log(&quot;seed[&quot; + i + &quot;] = &quot; + seed); } catch (e) { console.error(&quot;error at i=&quot; + i, e); break; } } console.log(&quot;seed = &quot; + seed); send(seed);}); 脚本里的blist就是b的取值，是[[value,i]….]的形式,有两千多条就不放出来了最后跑完拿到种子 获取flag然后断点打在hash进入前，把v25修掉就行，记得把前面的输入循环整个去掉，不然又在while里卡死了flag直接就输出来了","link":"/ctf/WP/ACTF2025%20unstoppable/"},{"title":"frida 实用代码片段","text":"记录一些可复用的frida脚本 dump so123456789101112131415161718192021222324252627282930313233/*如何使用设置一个倒计时后dump指定的so文件，timeout单位是ms，默认为3000ms对应的python段on_message回调def handleDumpSo(message, data): with open(&quot;dump_&quot;+message['payload'][1], &quot;ab&quot;) as f: f.write(data)*/function dump(soName: string, timeout: number = 3000) { setTimeout(() =&gt; { let libSo = Process.getModuleByName(soName); let base = libSo.base; let size = libSo.size; let sectionRanges = libSo.enumerateRanges(&quot;&quot;); for (let i = 0; i &lt; sectionRanges.length; i++) { console.log(sectionRanges[i].base.sub(base), sectionRanges[i].size, sectionRanges[i].base.add(sectionRanges[i].size).sub(base), sectionRanges[i].protection); Memory.protect(sectionRanges[i].base, sectionRanges[i].size, 'rwx'); let buffer = sectionRanges[i].base.readByteArray(sectionRanges[i].size); console.log(`write ${sectionRanges[i].size} bytes sections`); send([&quot;dumpso&quot;, soName], buffer); if (i + 1 &lt; sectionRanges.length &amp;&amp; sectionRanges[i].base.add(sectionRanges[i].size).compare(sectionRanges[i + 1].base) !== 0) { let gap = Memory.alloc(sectionRanges[i + 1].base.sub(sectionRanges[i].base.add(sectionRanges[i].size)).toUInt32()); let buffer = gap.readByteArray(sectionRanges[i + 1].base.sub(sectionRanges[i].base.add(sectionRanges[i].size)).toUInt32()); console.log(`write ${sectionRanges[i + 1].base.sub(sectionRanges[i].base.add(sectionRanges[i].size)).toUInt32()} bytes gap`); send([&quot;dumpso&quot;, soName], buffer); } } console.log(&quot;base: &quot;, base); console.log(&quot;size: &quot;, size); console.log(&quot;base + size: &quot;, base.add(size)); }, timeout);}dump(&quot;libil2cpp.so&quot;); 把内存中完整的so dump下来，包括仅运行时分配空间的段 HookGetStaticMethodID1234567891011121314151617181920212223242526272829303132333435/*如何使用这个gadget通过hook libart.so中的getStaticMethodID函数来获取so层获取的dex函数信息一般直接运行即可，注意本gadget依赖libart.so的加载配套python解析message的函数def handleGetStaticMethodID(message): print(&quot;----------------------------------------&quot;) print(&quot;JAVA method name: {}&quot;.format(message['payload'][1])) print(&quot;JAVA method signature: {}&quot;.format(message['payload'][2])) print(&quot;Which file get It: {}&quot;.format(message['payload'][3]))*/function hookJNIgetStaticMethodID() { console.log(&quot;hook JNIgetStaticMethodID&quot;); let symbols = Module.load(&quot;libart.so&quot;).enumerateSymbols(); for (let i = 0; i &lt; symbols.length; i++) { let symbol = symbols[i]; if (symbol.name.indexOf(&quot;art&quot;) &gt;= 0 &amp;&amp; symbol.name.indexOf(&quot;JNI&quot;) &gt;= 0 &amp;&amp; symbol.name.indexOf(&quot;GetStaticMethodID&quot;) &gt;= 0 &amp;&amp; symbol.name.indexOf(&quot;CheckJNI&quot;) &lt; 0) { console.log(symbol.name); Interceptor.attach(symbol.address, { onEnter: function (args) { var Name = args[2].readUtf8String(); var sig = args[3].readUtf8String(); let whoCallIt = DebugSymbol.fromAddress(this.returnAddress).toString(); send([&quot;getStaticMethodID&quot;, Name, sig, whoCallIt]); } }) } }}setTimeout(hookJNIgetStaticMethodID, 3000); HookRegisterNative12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455/*如何使用这个gadget通过hook libart.so中的RegisterNatives函数来获取JNI注册的native方法信息一般直接运行即可，注意本gadget依赖libart.so的加载配套python解析message的函数def handleResigerNatives(message): print(&quot;----------------------------------------&quot;) print(&quot;Native Method in class: {}&quot;.format(message['payload'][1])) print(&quot;Native Method name: {}&quot;.format(message['payload'][2])) print(&quot;Native Method signature: {}&quot;.format(message['payload'][3])) print(&quot;Native Method address: {}&quot;.format(message['payload'][4])) print(&quot;Which file register It: {}&quot;.format(message['payload'][5]))*/Java.perform(() =&gt; { hookJNIregisterNatives();})function hookJNIregisterNatives() { console.log(&quot;hook JNIregisterNatives&quot;); let symbols = Process.getModuleByName(&quot;libart.so&quot;).enumerateSymbols(); for (let i = 0; i &lt; symbols.length; i++) { let symbol = symbols[i]; //_ZN3art3JNI15RegisterNativesEP7_JNIEnvP7_jclassPK15JNINativeMethodi if (symbol.name.indexOf(&quot;art&quot;) &gt;= 0 &amp;&amp; symbol.name.indexOf(&quot;JNI&quot;) &gt;= 0 &amp;&amp; symbol.name.indexOf(&quot;RegisterNatives&quot;) &gt;= 0) { Interceptor.attach(symbol.address, { onEnter: function (args) { var jclass = args[1]; let className = Java.vm.getEnv().getClassName(jclass); var methods = args[2]; var nMethods = args[3].toInt32(); // console.log(nMethods); // console.log(&quot;className:&quot;, className); for (let i = 0; i &lt; nMethods; i++) { // console.log(&quot;i:&quot;, i); let nativeMethodPtr = methods.add(i * Process.pointerSize * 3); let namePtr = nativeMethodPtr.add(0).readPointer(); let signaturePtr = nativeMethodPtr.add(Process.pointerSize).readPointer(); let methodPtr = nativeMethodPtr.add(Process.pointerSize * 2).readPointer(); let methodName = namePtr.readUtf8String(); let methodSignature = signaturePtr.readUtf8String(); let whoCallIt = DebugSymbol.fromAddress(this.returnAddress).toString(); // console.log(Module.load(DebugSymbol.fromAddress(this.returnAddress).moduleName as string).base) let methodPtrStr = methodPtr.sub(Module.load(DebugSymbol.fromAddress(this.returnAddress).moduleName as string).base).toString(16); // console.log(&quot;RegisterNatives:&quot;, className, methodName, methodSignature, methodPtrStr, whoCallIt); send([&quot;registerNatives&quot;, className, methodName, methodSignature, methodPtrStr, whoCallIt]); } } }); } } // console.log(&quot;RegisterNatives addr:&quot;, addrRegisterNatives);}// setImmediate(hookWhenArtLoaded); traceStack全量hook脚本，用于追踪执行流脚本中遇到的函数表可以由这个脚本生成 123456789101112131415161718192021222324252627282930313233'''用bn导出函数表和函数地址,方便批量添加frida跟踪调用链'''from binaryninja import *def solve(bv: BinaryView): names = [] addresses = [] with open(&quot;functionDump.txt&quot;, &quot;w&quot;) as f: for func in bv.functions: names.append(func.name) addresses.append(func.start) print(&quot;var functionNames = [&quot;, file=f) for i in range(len(names)): if i == len(names) - 1: print(&quot; \\&quot;{}\\&quot;&quot;.format(names[i]), file=f) else: print(&quot; \\&quot;{}\\&quot;,&quot;.format(names[i]), file=f) print(&quot;];&quot;, file=f) print(&quot;var functionAddresses = [&quot;, file=f) for i in range(len(addresses)): if i == len(addresses) - 1: print(&quot; 0x{:x}&quot;.format(addresses[i]), file=f) else: print(&quot; 0x{:x},&quot;.format(addresses[i]), file=f) print(&quot;];&quot;, file=f) print(&quot;export finish&quot;) print(&quot;total function count: {}&quot;.format(len(names)))solve(bv) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283/*根据给出的函数表跟踪调用链，函数表由bnExportFunctionInfo.py导出顺带给出br的跳转目标地址方便分析bn未识别的函数*/var soName = &quot;libsec2023.so&quot;function sendWrapper(msg) { send([&quot;traceStack&quot;, msg]);}function startTrace(soName) { var tid = Process.getCurrentThreadId(); var lib = Process.getModuleByName(soName); var cnt = 1; sendWrapper(&quot;========================trace started========================&quot;); Stalker.follow(tid, { events: { call: false, ret: false, exec: false, block: false, compile: false }, transform: (iterator) =&gt; { var insn; while ((insn = iterator.next()) != null) { const addr = ptr(insn.address); // 只 instrument 属于目标 so 的指令 if (addr.compare(lib.base) &lt; 0 || addr.compare(lib.base.add(lib.size)) &gt;= 0) { iterator.keep(); continue; } // if (insn.mnemonic == &quot;br&quot;) { // const regName = insn.operands[0].value as string; // iterator.putCallout((ctx) =&gt; { // sendWrapper(`[${addr.sub(lib.base)}]` + &quot;[BR] target =&quot; + ptr(ctx[regName]).sub(lib.base)); // }); // } if (functionAddresses.indexOf(addr.sub(lib.base).toUInt32()) != -1) { sendWrapper(&quot;at &quot; + cnt + &quot; &quot; + functionNames[functionAddresses.indexOf(addr.sub(lib.base).toUInt32())]); cnt++; } iterator.keep(); } } }) // console.log(&quot;========================trace ended========================&quot;);}Java.perform(() =&gt; { var dlopen_addr = Module.getExportByName(&quot;libdl.so&quot;, &quot;dlopen&quot;); var dlopen_ext_addr = Module.getExportByName(&quot;libdl.so&quot;, &quot;android_dlopen_ext&quot;); Interceptor.attach(dlopen_addr, { onEnter: function (args) { var path = args[0].readUtf8String(); if (path?.indexOf(soName) != -1) { this.getSo = 1; } }, onLeave: function (retval) { if (this.getSo) { sendWrapper(&quot;dlopen: &quot; + soName); startTrace(soName); } } }) Interceptor.attach(dlopen_ext_addr, { onEnter: function (args) { var path = args[0].readUtf8String(); if (path?.indexOf(soName) != -1) { this.getSo = 1; } }, onLeave: function (retval) { if (this.getSo) { sendWrapper(&quot;dlopen_ext: &quot; + soName); startTrace(soName); } } })}) python段解析数据的部分，因为trace的数据量实际上相当大，并且有大量重复，所以采用分批合并输出的方式 12345678910111213141516171819202122def handleTraceStack(message): traceLimit = 1000000000 global TraceStacklogs global startPrintLog if len(TraceStacklogs) == 0: TraceStacklogs.append([message['payload'][1], 1]) else: if message['payload'][1] == TraceStacklogs[-1][0]: TraceStacklogs[-1][1] += 1 else: TraceStacklogs.append([message['payload'][1], 1]) def print_log(): global TraceStacklogs for item, cnt in TraceStacklogs: print(f&quot;{item} x{cnt}&quot;) TraceStacklogs.clear() threading.Timer(3.0, print_log).start() if not startPrintLog: startPrintLog = True print_log()","link":"/ctf/Andorid/frida-gadget/"},{"title":"compose 组件速查","text":"kotlin compose 学习笔记 综述compose基本就是类似react中的component，结合jetpack compose编译器生成可以组成成界面的函数块 如何设置函数为compose1234@Composablefun Greeting(name: String) { Text(text = &quot;Hello $name!&quot;)} 通过添加注释(@Composable)告诉jet compose编译器讲这个函数编译为compose Modifier123456@Composablefun GreetingText(message: String, modifier: Modifier = Modifier) { Text( text = message )} Modifier是compose中用于设置字体颜色等属性的对象，可以类比为CSS，对于一个compose不管你用不用modifier最好都传一个进去，因为你不能保证子元素也用不到，而且保持modifier传参可以提供配置一致性 MainActivityMainActivity需要从ComponentActivity()这个父类继承，google给出的一个示例如下 1234567891011121314151617181920class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContent { HappyBirthdayTheme { // A surface container using the 'background' color from the theme Surface( modifier = Modifier.fillMaxSize(), color = MaterialTheme.colorScheme.background ) { GreetingText( message = &quot;Happy Birthday Sam!&quot;, from = &quot;From Emma&quot;, modifier = Modifier.padding(8.dp) ) } } } }} 重点是setContent，用来设置要生成的内容 TextText是最基础的compose函数，用于显示文本使用text参数传递文本，另外也支持fontSize,modifier之类的格式参数 Row横向排版，把元素排成一行，可以使用尾随lambda语法添加需要的compose函数(因为content是最后一个参数，由row中的内容组成的lambda) 1234Row { Text(&quot;First Column&quot;) Text(&quot;Second Column&quot;)} Column纵向排版，其他和Row同理 Box重叠布局，可以把元素堆叠在一起，默认越先声明的元素在图层中的位置越低，也可以通过modifier的zIndex属性手动指定元素的高度 12345678910111213Box(modifier) { // 图片作为背景，Text在图片上方 Image( painter = image, contentDescription = null ) GreetingText( message = message, from = from, modifier = Modifier .fillMaxSize() .padding(8.dp) ) } Image用来渲染图片，图片资源通过R.drawable.resouceID管理,通过painterResource函数获取 123Image( painter = painterResource(R.drawable.androidparty)) ButtonButton是compose中的按钮元素，主要要设置onClick参数，这个参数接受一个lambda作为按钮触发的回调函数Button内部还可以添加元素，和布局一样用尾随lambda添加元素，比如添加按钮提示词Text之类的 State / remember","link":"/development/compose_beginer/"},{"title":"ebpf","text":"","link":"/ctf/ebpf/ebpc0x1/"}],"tags":[{"name":"Reverse","slug":"Reverse","link":"/tags/Reverse/"},{"name":"Andorid","slug":"Andorid","link":"/tags/Andorid/"},{"name":"Python","slug":"Python","link":"/tags/Python/"},{"name":"selenium","slug":"selenium","link":"/tags/selenium/"},{"name":"codeforces","slug":"codeforces","link":"/tags/codeforces/"},{"name":"加密&amp;编码","slug":"加密-编码","link":"/tags/%E5%8A%A0%E5%AF%86-%E7%BC%96%E7%A0%81/"},{"name":"Android","slug":"Android","link":"/tags/Android/"},{"name":"XCTF","slug":"XCTF","link":"/tags/XCTF/"}],"categories":[{"name":"Reverse","slug":"Reverse","link":"/categories/Reverse/"},{"name":"Development","slug":"Development","link":"/categories/Development/"},{"name":"basic","slug":"Reverse/basic","link":"/categories/Reverse/basic/"},{"name":"杂项","slug":"杂项","link":"/categories/%E6%9D%82%E9%A1%B9/"},{"name":"ctf-test","slug":"Reverse/ctf-test","link":"/categories/Reverse/ctf-test/"},{"name":"LLVM","slug":"Reverse/LLVM","link":"/categories/Reverse/LLVM/"},{"name":"对称加密&amp;编码","slug":"Reverse/对称加密-编码","link":"/categories/Reverse/%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86-%E7%BC%96%E7%A0%81/"},{"name":"Andorid","slug":"Reverse/Andorid","link":"/categories/Reverse/Andorid/"}],"pages":[]}