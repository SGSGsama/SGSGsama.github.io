{"posts":[{"title":"selenium爬虫入门","text":"简介selenium是基于浏览器DevTool模拟用户态行为的爬虫框架，与传统爬虫相比selenium最大的优点就是可以通过模拟行为绕过大部分的反爬，同时因为其本身基于浏览器，在对抗加密方面有天然的优势 常用APIwebDriver.Chrome.Options() : Option返回一个 option 对象，用于在之后为浏览器提供选项参数，最常见的用法如下 12options = webdriver.ChromeOptions()options.add_argument(&quot;disable-blink-features=AutomationControlled&quot;) 这段代码为option添加了一个参数将浏览器的 webdriver 属性置为false，该属性常用于检测浏览器是否处于调试模式，常见的反爬会检测该属性，该属性为true则会触发反爬此外还可以添加包括但不限于下列的属性，但用处都不大 123--disable-gpu # 禁用gpu加速--headless # 将浏览器设置为无头浏览器--windows-size=1920,1080 #设置浏览器窗口大小 webdriver.Chrome(options : Option ) : WebDriver创建一个浏览器对象，所有与浏览器的交互都会通过这个对象进行 1driver = webdriver.Chrome(options=options) driver.get(url : str) : void打开一个页面 driver.find_element(by: str , value : str) : WebElement在webdriver目前聚焦的页面中寻找对应html元素，并返回一个可以对找到的元素进行交互的对象， by 是 selenium.webdriver.common.by 中的枚举类， value 是搜索对应的值或表达式，这里只介绍 By.CSS_SELECTOR 和 By.LINK_TEXT，个人认为算是最通用的方法。这个方法只返回找到的第一个元素，且找不到则抛出错误，另一个类似的方法是 driver.find_elements 返回所有找到的元素，如果找不到就返回空列表 By.CSS_SELECTOR 利用CSS选择器查找元素，value 应为一个CSS选择器表达式下面是一些示例 12345678910111213value = &quot;div&quot; # 单独的名字表示筛选特定tag的元素value = &quot;.targetClass&quot; # class名前带.表示筛选带特定类的元素value = &quot;#ID&quot; # ID前带#表示筛选含特定id的元素value = &quot;[attribute]&quot; # 筛选带具备特定属性的元素value = '[attribute=&quot;value&quot;]' # 筛选带特定属性且属性值为value的元素，其中&quot;&quot;不可省略和替换value = &quot;div.targetClass#ID&quot; # 选择含多个条件的元素则将所有条件不加空格地组合在一起value = &quot;div#fatherDiv div#sonDiv&quot; # 如果要选择某个元素的后代元素则将两个元素的筛选条件以空格隔开value = &quot;div#faterDiv &gt; div#directSonDiv&quot; # 如果要选择直属于某个元素的子元素则在两个元素的筛选条件之间额外加入 &gt;value = &quot;:not()&quot; # 选择不符合特定条件的元素，()中可以嵌套另一个CSS选择器表达式 # 比如 &quot;div:not(.disabled)&quot; ,选择不为disable类的div元素 By.LINK_TEXT 筛选文本为 value 的&lt;a&gt;元素即超链接元素，执行严格匹配，另一个类似的方法是 By.PARTIAL_LINK_TEXT，只需提供的 value 是目标的子串就行，此方法用于快捷定位特定超链接对应的元素，方便爬虫在页面间进行跳转 1Page = driver.find_element(by=By.LINK_TEXT, value=&quot;下一页&quot;) # 这样我们就定位到了一个翻页按钮，可以用click之类的方法让我们的爬虫翻页 ActionChains(driver : WebDriver) : ActionChains这是selenium提供的动作链类，用于模拟用户的操作输入 1234567actions = ActionChains(driver) # 指定所属的webdriver，还可以指定duration属性来控制每次操作的时间，用来绕过针对仿真行为的反爬actions.key_down(Keys.CONTROL).click( Page).key_up(Keys.CONTROL).perform() # 这个操作就模拟了ctrl+左键，即在新页面打开对应链接 # 使用连续调用来设计动作链，最后调用perform()执行 # click之类的要指定具体点击的webElement，否则点击鼠标指针所在位置 # 按键类的动作可以用selenium.webdriver.common.keys中的Keys枚举类来模拟按下ctrl之类的功能键，其他按键直接输入对应字符即可 driver.switch_to.window(window_name : str) : void将浏览器的焦点切换至另一个页面，其中 window_name 可以通过 driver.window_handles 获取，这是webdriver类的一个列表成员，储存了当前浏览器所有窗口的 window_name 12driver.switch_to.window(driver.window_handles[-1]) # 切换至最右边的窗口，事实上这个列表里句柄的排列顺序是按窗口打开顺序排列的 driver.close() : void当一个页面的数据爬完了可能要关闭该页面，用close方法就能把当前页面关掉，但是注意driver并 不会自动切换聚焦到新窗口 ，所以close后要调用switch_to.window把焦点转移到新窗口 driver.quit() : void直接关闭浏览器 项目实战项目地址 =&gt; 基于selenium框架爬取avd.aliyun.com上的漏洞报告 阿里云的漏洞网站用了很恶心的加密算法，把本机的时间戳套了一堆加密做成token放进payload里做验证，如果验证不通过就无法进入漏洞库和漏洞报告，我们直接上selenium，只要我们全程模拟用户态行为就不用管加密，这点和逆向工程中的动态调试非常像，本质上是利用了应用自加密/自解密的性质 下面直接上代码 12345678#utility.pydef init_driver(url: str): options = webdriver.ChromeOptions() options.add_argument(&quot;disable-blink-features=AutomationControlled&quot;) driver = webdriver.Chrome(options=options) driver.get(url) return driver 他的加密算法会在加载时就读取 webdriver 标记的值，并且这个参数会被用于加密过程，如果是undefined或者true加密跑出来就是错的，而且非常恶心的是他并不直接从 navigator.webdriver 实时读取，而是加载时检测到 webdriver 不为false就让加密胡乱输出，所以我们加一个参数在网页加载前就把 webdriver 标记设置成false 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#Crawler.pydef runCrawler(catalog: str, number: int = 0, debug: bool = 0, sleepSecond: float = 1): ''' sleepSecond为每跳转一个页面的等待时长，过短可能会触发限流或反爬\\n 如果cve的命名不符合windows文件命名规范则会转换为url命名输出\\n catalog为要爬取的漏洞库的按钮文本{&quot;CVE 漏洞库&quot;,&quot;非CVE漏洞库&quot;,&quot;高危漏洞&quot;}\\n number为爬取的记录数量，若不指定则在调用函数时提示输入 ''' driver = init_driver(&quot;https://avd.aliyun.com/&quot;) Page = driver.find_element(by=By.LINK_TEXT, value=catalog) if debug: print(&quot;in &quot;+driver.title+&quot; at &quot;+driver.current_url) # input(&quot;continue&quot;) actions = ActionChains(driver) actions.key_down(Keys.CONTROL).click( Page).key_up(Keys.CONTROL).perform() # 进入漏洞库列表 sleep(sleepSecond*1.5) # 等待加载 if debug: print(&quot;sleep finished&quot;) driver.switch_to.window(driver.window_handles[-1]) # 切换至漏洞库窗口 links = driver.find_elements(By.TAG_NAME, &quot;a&quot;) # print(len(links)) if debug: # print(driver.window_handles) print(&quot;in &quot;+driver.title+&quot; at &quot;+driver.current_url) # input(&quot;continue&quot;) total = driver.find_element( by=By.CSS_SELECTOR, value=&quot;div.py-3.bg-light &gt; div.container.vuln-list-container &gt; div.py-3 &gt; div.d-flex.justify-content-between.align-items-center &gt; span.text-muted&quot;).text if debug: print(total[total.find(&quot;总计 &quot;)+3: total.find(&quot; 条记录&quot;)]) total = int(total[total.find(&quot;总计 &quot;)+3: total.find(&quot; 条记录&quot;)]) print(&quot;正在爬取 {}&quot;.format(catalog)) toDo = number if toDo == 0: toDo = int(input(&quot;输入要爬取的记录条数，范围为 &lt;={}\\n&quot;.format(total))) hasNextPage = 1 cnt = 0 while hasNextPage and cnt &lt; toDo: if debug: print(&quot;in&quot;+driver.current_url) for link in links: # 遍历所有超链接 if &quot;detail&quot; in link.get_attribute(&quot;href&quot;): link.click() # 进入cve sleep(sleepSecond) driver.switch_to.window( driver.window_handles[-1]) # 切换至新窗口 button = driver.find_elements( by=By.CSS_SELECTOR, value=&quot;.btn.btn-link.text-muted&quot;) if len(button): button[0].click() genRawDoc(driver, debug) cnt += 1 print(&quot;进度 {} / {}&quot;.format(cnt, toDo)) if debug: print(&quot;in &quot;+driver.title+&quot; at &quot;+driver.current_url) input(&quot;continue&quot;) driver.close() # input(&quot;closed&quot;) driver.switch_to.window(driver.window_handles[-1]) if debug: print(&quot;in &quot;+driver.title+&quot; at &quot;+driver.current_url) # input(&quot;continue&quot;) if cnt == toDo: break nextPageButton = driver.find_elements( by=By.CSS_SELECTOR, value=&quot;.px-3.btn.btn-sm.btn-outline-secondary.btn-bd-primary:not(.disabled)&quot;) if debug: print(len(nextPageButton)) hasNextPage = 0 for button in nextPageButton: if &quot;下一页&quot; in button.text: actions.key_down(Keys.CONTROL).click( button).key_up(Keys.CONTROL).perform() # driver.close() sleep(sleepSecond) driver.close() driver.switch_to.window(driver.window_handles[-1]) hasNextPage = 1 break driver.quit() 这段非常长，因为爬虫定位元素基本靠手工定位，有大量重复代码，我们看关键的部分 12345driver = init_driver(&quot;https://avd.aliyun.com/&quot;)Page = driver.find_element(by=By.LINK_TEXT, value=catalog)actions = ActionChains(driver)actions.key_down(Keys.CONTROL).click(Page).key_up(Keys.CONTROL).perform() # 进入漏洞库列表sleep(sleepSecond*1.5) # 等待加载 这里我们打开网站，然后网站首页有三个链接分别跳进不同分类的漏洞库，我们直接用文本定位然后在新页面打开，并且等待加载，这里不直接点击在原地跳转的原因是不知道为什么原地跳转会导致加密算法输出不正确，然后等待加载也很重要，如果不等页面完全加载完就跳转也会让加密算法输出不正确，尚不清楚原因 12driver.switch_to.window(driver.window_handles[-1]) # 切换至漏洞库窗links = driver.find_elements(By.TAG_NAME, &quot;a&quot;) 这段就是把这个页面里所有的超链接元素都抓下来 123total = driver.find_element( by=By.CSS_SELECTOR, value=&quot;div.py-3.bg-light &gt; div.container.vuln-list-container &gt; div.py-3 &gt; div.d-flex.justify-content-between.align-items-center &gt; span.text-muted&quot;).texttotal = int(total[total.find(&quot;总计 &quot;)+3: total.find(&quot; 条记录&quot;)]) 这段是找下总共有多少条记录，不是很重要 1234567891011121314151617while hasNextPage and cnt &lt; toDo: #.... nextPageButton = driver.find_elements( by=By.CSS_SELECTOR, value=&quot;.px-3.btn.btn-sm.btn-outline-secondary.btn-bd-primary:not(.disabled)&quot;) if debug: print(len(nextPageButton)) hasNextPage = 0 for button in nextPageButton: if &quot;下一页&quot; in button.text: actions.key_down(Keys.CONTROL).click( button).key_up(Keys.CONTROL).perform() # driver.close() sleep(sleepSecond) driver.close() #关闭当前页 driver.switch_to.window(driver.window_handles[-1]) #前往下一页 hasNextPage = 1 break 因为记录有很多页，我们要一页一页爬，先找到翻页按钮，然后发现能按和不能按的按钮有一个.disable类的区别，我们就一直翻直到”下一页”变成disable为止然后每次点开一个新的就把老的关了 123456789101112131415161718192021222324for link in links: # 遍历所有超链接 if &quot;detail&quot; in link.get_attribute(&quot;href&quot;): link.click() # 进入cve sleep(sleepSecond) driver.switch_to.window( driver.window_handles[-1]) # 切换至新窗口 button = driver.find_elements( by=By.CSS_SELECTOR, value=&quot;.btn.btn-link.text-muted&quot;) if len(button): button[0].click() genRawDoc(driver, debug) cnt += 1 print(&quot;进度 {} / {}&quot;.format(cnt, toDo)) if debug: print(&quot;in &quot;+driver.title+&quot; at &quot;+driver.current_url) input(&quot;continue&quot;) driver.close() # input(&quot;closed&quot;) driver.switch_to.window(driver.window_handles[-1]) if debug: print(&quot;in &quot;+driver.title+&quot; at &quot;+driver.current_url) # input(&quot;continue&quot;) if cnt == toDo: break 页面里有一堆超链接，我们肯定不能每个都跳进去，发现漏洞详情的超链接里有detail关键字，我们就只找含这个关键字的跳，也是点开，转移焦点，爬数据，关闭，把焦点切回来，同样注意每次等待一会，可以防止访问量过大导致限流或者直接被封ip然后跳进去后发现参考链接如果数量过多会只显示部分，要先点一下 .btn.btn-link.text-muted 的按钮把所有东西都展开genRawDoc里的内容就没什么营养了，目前已经进入具体报告界面，直接定位对应内容，保存下来写入文件就行","link":"/development/selenium0x1/"},{"title":"frida常用api备忘录","text":"javascript APIProcessProcess.id : number返回目标进程的PID 1console.log(&quot;processid = &quot;, Process.id); 12$ python launch.py processid = 3819 Process.arch : String返回目标进程的架构 1console.log(&quot;processArch = &quot;, Process.arch); 12$ python launch.py processArch = x64 get和find系的函数建议使用get系,在查找失败时get抛出错误,而find返回NULLProcess.getModuleByAddress(address : NativePointer) : Module address为实际地址Process.getModuleByName(name : String) : Module 根据地址或名称返回 已加载的 目标库(.so库)的对象(Module对象)，地址需提供原生指针 123var lib: Module = Process.getModuleByName(&quot;liba0x9.so&quot;);var lb: Module = Process.getModuleByAddress(lib.base);console.log(&quot;lbname = &quot;, lb.name); 12$ python launch.pylbname = liba0x9.so Process.enumerateModules() : Module[]返回所有已加载的.so库，返回内容是Module对象组成的js数组 1234567var ls = Process.enumerateModules(); for (let i = 0; i &lt; ls.length; i++) { console.log(ls[i].base); console.log(ls[i].name); console.log(ls[i].path); console.log(&quot;------&quot;); } 123456780x768bb30ca000libgraphicsenv.so/system/lib64/libgraphicsenv.so------0x768bb6608000libgui.so/system/lib64/libgui.so..... ThreadThread.backtrace(context, backtracer) : NativePointer[]在java层不如直接调用android.util.log好用，主要用于追踪native层调用栈，通常加上this.context，backtracer有.FUZZY和.ACCURATE两种模式可选返回当前调用栈，返回类型是NativePointer组成的js数组，使用DebugSymbolfromAddress转化为可读符号 123456789var lib: Module = Module.load(&quot;liba0x9.so&quot;); console.log(lib.enumerateExports()[0].name); Interceptor.attach(lib.getExportByName(lib.enumerateExports()[0].name), { onEnter(args) { console.log(Thread.backtrace(this.context, Backtracer.ACCURATE).map(DebugSymbol.fromAddress).join('\\n')); }, onLeave(retval) { retval.replace(1337 as any); }, }) 1234$ python launch.pyJava_com_ad2001_a0x9_MainActivity_check_1flag0x768914fa0a2c libart.so!art_quick_generic_jni_trampoline+0xdc0x768914f83912 libart.so!MterpHelpers+0x1f5 ModuleModule类本身的属性 member use name : String 库名 base : NativePointer 库基地址 size : number 库大小 path : String 库的绝对路径 ModuleObj.enumerateImports() : ModuleImportDetails[]返回这个库的所有导入符号,类型为ModuleImportDetails组成的js数组 ModuleImportDetailsModuleImportDetails类的属性 member use type : ModuleImportType (function | variable) 导入符号的类型 name : String 导入符号的名称 module : String 导入符号来自哪个文件 address : NativePointer 导入符号在内存中的地址(绝对地址)，用于直接调用或修改导入函数 slot : NativePointer 导入表中指向导入函数的指针,用于重定向导入函数 123var lib: Module = Module.load(&quot;liba0x9.so&quot;);var ls = lib.enumerateImports();console.log(ls[0].name, &quot;from module :&quot;, ls[0].module); 12$ python launch.py __cxa_finalize from module : /apex/com.android.runtime/lib64/bionic/libc.so ModuleObj.enumerateExports() : ModuleExportDetails[]返回这个库的所有导出符号,类型为ModuleExportDetails组成的js数组 member use type : ModuleExportType (function | variable) 导出符号的类型 name : String 导出符号的名称 address : NativePointer 导出符号在内存中的地址(绝对地址)，用于直接调用或修改导出函数 ModuleObj.getExportByName(exportName : String) : NativePointer根据名称返回对应导出符号的指针，是frida hook native层函数的主要方法 Module.load(name : String) : Module根据名称(是的就是名称，至少vsc的frida type hint 里提示的是输入名称)返回对应native库的对象，与Process.getModuleByxxx的不同是该方法无需目标库已被加载，且使用该方法可以手动加载目标库 12var lib: Module = Module.load(&quot;libfrida0xa.so&quot;);console.log(lib.name); 12$ python launch.pylibfrida0xa.so Module.ensureInitialized(name : String) : void在目标库加载完成前阻塞程序进行 Module.getBaseAddress(name : String) : NativePointer返回目标库的基地址,等同于Module.load(name).base Module.getExportByName(moduleName : String | null, exportName : String) : NativePointer根据库名和符号名查找对应的导出符号，库名可缺省，此时在全局对该符号进行搜索 MemoryMemory.scan(address : NativePointer, size : number, pattern : String, callbacks : MemoryScanCallbacks) : void这是一个异步函数，用于在内存中扫描对应的模式，address指定了起始地址，size指定了扫描的字节数pattern是一个模式串，必须为以下任意的格式之一1.完全匹配 “1F 13 00 2F”2.通配符 “?F 13 00 ??” 其中?在匹配时可以是0~F中的任意一个3.掩码 “”13 37 13 37 : 1F FF FF F1”” 后面的为掩码，掩码中为1的位表示需要匹配，为0的位则可以是任意值 MemoryScanCallbacksMemoryScanCallbacks 是一个结构体，定义如下 1234567{ onMatch(address : NativePointer, size : number) : function //匹配成功的回调函数，address为成功匹配的地址，size为匹配到的长度 //该函数可通过 return 'stop' 提前结束 onError(reason : String) : function //处理错误的回调函数 onComplete() ： function //匹配结束的回调函数} 这个函数的同步版本为Memory.scanSync(address, size, pattern),返回由匹配到的address和size组成的对象的数组 Memory.protect(address : NativePointer, size : number, protection : String) : boolean修改对应位置内存的权限，返回true表示操作成功，protection为形同”rwx”的字符串 Memory.patchCode(address : NativePointer, size : number, apply : function) : voidapply里是具体要对内存进行修改的操作，address为起始地址，size为修改区域的字节数 NativeFunction获取native层函数的引用 NativeFunction(address, returnType, argTypes[, abi])创建方法var func = new NativeFunction(address, returnType, argTypes[, abi])address : NativePointer 函数地址returnType : [type] 返回类型argTypes : [types…] 参数类型 1const getFlag = new NativeFunction(getFlagPtr, ['void'], ['int', 'int']); // 用例 可用类型 123456789101112131415161718192021voidpointerintuintlongulongcharucharsize_tssize_tfloatdoubleint8uint8int16uint16int32uint32int64uint64bool TODO:NativeCallbackInterceptorJavaXXXWriterXXXRelocatorhexdumprpc.exportsTiming events 参考链接Frida 官方文档Frida-Labs","link":"/ctf/Andorid/firdaApi/firdaApi/"}],"tags":[{"name":"Python","slug":"Python","link":"/tags/Python/"},{"name":"selenium","slug":"selenium","link":"/tags/selenium/"},{"name":"Reverse","slug":"Reverse","link":"/tags/Reverse/"},{"name":"Andorid","slug":"Andorid","link":"/tags/Andorid/"}],"categories":[{"name":"Development","slug":"Development","link":"/categories/Development/"},{"name":"Reverse","slug":"Reverse","link":"/categories/Reverse/"},{"name":"Python","slug":"Development/Python","link":"/categories/Development/Python/"},{"name":"Andorid","slug":"Reverse/Andorid","link":"/categories/Reverse/Andorid/"},{"name":"Frida","slug":"Reverse/Andorid/Frida","link":"/categories/Reverse/Andorid/Frida/"}],"pages":[]}