{"posts":[{"title":"selenium爬虫入门","text":"简介selenium是基于浏览器DevTool模拟用户态行为的爬虫框架，与传统爬虫相比selenium最大的优点就是可以通过模拟行为绕过大部分的反爬，同时因为其本身基于浏览器，在对抗加密方面有天然的优势 常用APIwebDriver.Chrome.Options() : Option返回一个 option 对象，用于在之后为浏览器提供选项参数，最常见的用法如下 12options = webdriver.ChromeOptions()options.add_argument(&quot;disable-blink-features=AutomationControlled&quot;) 这段代码为option添加了一个参数将浏览器的 webdriver 属性置为false，该属性常用于检测浏览器是否处于调试模式，常见的反爬会检测该属性，该属性为true则会触发反爬此外还可以添加包括但不限于下列的属性，但用处都不大 123--disable-gpu # 禁用gpu加速--headless # 将浏览器设置为无头浏览器--windows-size=1920,1080 #设置浏览器窗口大小 webdriver.Chrome(options : Option ) : WebDriver创建一个浏览器对象，所有与浏览器的交互都会通过这个对象进行 1driver = webdriver.Chrome(options=options) driver.get(url : str ) : void打开一个页面 driver.find_element(by: str , value : str ) : WebElement在webdriver目前聚焦的页面中寻找对应html元素，并返回一个可以对找到的元素进行交互的对象， by 是 selenium.webdriver.common.by 中的枚举类， value 是搜索对应的值或表达式，这里只介绍 By.CSS_SELECTOR 和 By.LINK_TEXT，个人认为算是最通用的方法。这个方法只返回找到的第一个元素，且找不到则抛出错误，另一个类似的方法是 driver.find_elements 返回所有找到的元素，如果找不到就返回空列表 By.CSS_SELECTOR 利用CSS选择器查找元素，value 应为一个CSS选择器表达式下面是一些示例 12345678910111213value = &quot;div&quot; # 单独的名字表示筛选特定tag的元素value = &quot;.targetClass&quot; # class名前带.表示筛选带特定类的元素value = &quot;#ID&quot; # ID前带#表示筛选含特定id的元素value = &quot;[attribute]&quot; # 筛选带具备特定属性的元素value = '[attribute=&quot;value&quot;]' # 筛选带特定属性且属性值为value的元素，其中&quot;&quot;不可省略和替换value = &quot;div.targetClass#ID&quot; # 选择含多个条件的元素则将所有条件不加空格地组合在一起value = &quot;div#fatherDiv div#sonDiv&quot; # 如果要选择某个元素的后代元素则将两个元素的筛选条件以空格隔开value = &quot;div#faterDiv &gt; div#directSonDiv&quot; # 如果要选择直属于某个元素的子元素则在两个元素的筛选条件之间额外加入 &gt;value = &quot;:not()&quot; # 选择不符合特定条件的元素，()中可以嵌套另一个CSS选择器表达式 # 比如 &quot;div:not(.disabled)&quot; ,选择不为disable类的div元素 By.LINK_TEXT 筛选文本为 value 的&lt;a&gt;元素即超链接元素，执行严格匹配，另一个类似的方法是 By.PARTIAL_LINK_TEXT，只需提供的 value 是目标的子串就行，此方法用于快捷定位特定超链接对应的元素，方便爬虫在页面间进行跳转 1Page = driver.find_element(by=By.LINK_TEXT, value=&quot;下一页&quot;) # 这样我们就定位到了一个翻页按钮，可以用click之类的方法让我们的爬虫翻页 ActionChains(driver : WebDriver ) : ActionChains这是selenium提供的动作链类，用于模拟用户的操作输入 1234567actions = ActionChains(driver) # 指定所属的webdriver，还可以指定duration属性来控制每次操作的时间，用来绕过针对仿真行为的反爬actions.key_down(Keys.CONTROL).click( Page).key_up(Keys.CONTROL).perform() # 这个操作就模拟了ctrl+左键，即在新页面打开对应链接 # 使用连续调用来设计动作链，最后调用perform()执行 # click之类的要指定具体点击的webElement，否则点击鼠标指针所在位置 # 按键类的动作可以用selenium.webdriver.common.keys中的Keys枚举类来模拟按下ctrl之类的功能键，其他按键直接输入对应字符即可 driver.switch_to.window(window_name : str ) : void将浏览器的焦点切换至另一个页面，其中 window_name 可以通过 driver.window_handles 获取，这是webdriver类的一个列表成员，储存了当前浏览器所有窗口的 window_name 12driver.switch_to.window(driver.window_handles[-1]) # 切换至最右边的窗口，事实上这个列表里句柄的排列顺序是按窗口打开顺序排列的 driver.close() : void当一个页面的数据爬完了可能要关闭该页面，用close方法就能把当前页面关掉，但是注意driver并 不会自动切换聚焦到新窗口 ，所以close后要调用switch_to.window把焦点转移到新窗口 driver.quit() : void直接关闭浏览器 项目实战项目地址 =&gt; 基于selenium框架爬取avd.aliyun.com上的漏洞报告 阿里云的漏洞网站用了很恶心的加密算法，把本机的时间戳套了一堆加密做成token放进payload里做验证，如果验证不通过就无法进入漏洞库和漏洞报告，我们直接上selenium，只要我们全程模拟用户态行为就不用管加密，这点和逆向工程中的动态调试非常像，本质上是利用了应用自加密/自解密的性质 下面直接上代码 12345678#utility.pydef init_driver(url: str): options = webdriver.ChromeOptions() options.add_argument(&quot;disable-blink-features=AutomationControlled&quot;) driver = webdriver.Chrome(options=options) driver.get(url) return driver 他的加密算法会在加载时就读取 webdriver 标记的值，并且这个参数会被用于加密过程，如果是undefined或者true加密跑出来就是错的，而且非常恶心的是他并不直接从 navigator.webdriver 实时读取，而是加载时检测到 webdriver 不为false就让加密胡乱输出，所以我们加一个参数在网页加载前就把 webdriver 标记设置成false 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#Crawler.pydef runCrawler(catalog: str, number: int = 0, debug: bool = 0, sleepSecond: float = 1): ''' sleepSecond为每跳转一个页面的等待时长，过短可能会触发限流或反爬\\n 如果cve的命名不符合windows文件命名规范则会转换为url命名输出\\n catalog为要爬取的漏洞库的按钮文本{&quot;CVE 漏洞库&quot;,&quot;非CVE漏洞库&quot;,&quot;高危漏洞&quot;}\\n number为爬取的记录数量，若不指定则在调用函数时提示输入 ''' driver = init_driver(&quot;https://avd.aliyun.com/&quot;) Page = driver.find_element(by=By.LINK_TEXT, value=catalog) if debug: print(&quot;in &quot;+driver.title+&quot; at &quot;+driver.current_url) # input(&quot;continue&quot;) actions = ActionChains(driver) actions.key_down(Keys.CONTROL).click( Page).key_up(Keys.CONTROL).perform() # 进入漏洞库列表 sleep(sleepSecond*1.5) # 等待加载 if debug: print(&quot;sleep finished&quot;) driver.switch_to.window(driver.window_handles[-1]) # 切换至漏洞库窗口 links = driver.find_elements(By.TAG_NAME, &quot;a&quot;) # print(len(links)) if debug: # print(driver.window_handles) print(&quot;in &quot;+driver.title+&quot; at &quot;+driver.current_url) # input(&quot;continue&quot;) total = driver.find_element( by=By.CSS_SELECTOR, value=&quot;div.py-3.bg-light &gt; div.container.vuln-list-container &gt; div.py-3 &gt; div.d-flex.justify-content-between.align-items-center &gt; span.text-muted&quot;).text if debug: print(total[total.find(&quot;总计 &quot;)+3: total.find(&quot; 条记录&quot;)]) total = int(total[total.find(&quot;总计 &quot;)+3: total.find(&quot; 条记录&quot;)]) print(&quot;正在爬取 {}&quot;.format(catalog)) toDo = number if toDo == 0: toDo = int(input(&quot;输入要爬取的记录条数，范围为 &lt;={}\\n&quot;.format(total))) hasNextPage = 1 cnt = 0 while hasNextPage and cnt &lt; toDo: if debug: print(&quot;in&quot;+driver.current_url) for link in links: # 遍历所有超链接 if &quot;detail&quot; in link.get_attribute(&quot;href&quot;): link.click() # 进入cve sleep(sleepSecond) driver.switch_to.window( driver.window_handles[-1]) # 切换至新窗口 button = driver.find_elements( by=By.CSS_SELECTOR, value=&quot;.btn.btn-link.text-muted&quot;) if len(button): button[0].click() genRawDoc(driver, debug) cnt += 1 print(&quot;进度 {} / {}&quot;.format(cnt, toDo)) if debug: print(&quot;in &quot;+driver.title+&quot; at &quot;+driver.current_url) input(&quot;continue&quot;) driver.close() # input(&quot;closed&quot;) driver.switch_to.window(driver.window_handles[-1]) if debug: print(&quot;in &quot;+driver.title+&quot; at &quot;+driver.current_url) # input(&quot;continue&quot;) if cnt == toDo: break nextPageButton = driver.find_elements( by=By.CSS_SELECTOR, value=&quot;.px-3.btn.btn-sm.btn-outline-secondary.btn-bd-primary:not(.disabled)&quot;) if debug: print(len(nextPageButton)) hasNextPage = 0 for button in nextPageButton: if &quot;下一页&quot; in button.text: actions.key_down(Keys.CONTROL).click( button).key_up(Keys.CONTROL).perform() # driver.close() sleep(sleepSecond) driver.close() driver.switch_to.window(driver.window_handles[-1]) hasNextPage = 1 break driver.quit() 这段非常长，因为爬虫定位元素基本靠手工定位，有大量重复代码，我们看关键的部分 12345driver = init_driver(&quot;https://avd.aliyun.com/&quot;)Page = driver.find_element(by=By.LINK_TEXT, value=catalog)actions = ActionChains(driver)actions.key_down(Keys.CONTROL).click(Page).key_up(Keys.CONTROL).perform() # 进入漏洞库列表sleep(sleepSecond*1.5) # 等待加载 这里我们打开网站，然后网站首页有三个链接分别跳进不同分类的漏洞库，我们直接用文本定位然后在新页面打开，并且等待加载，这里不直接点击在原地跳转的原因是不知道为什么原地跳转会导致加密算法输出不正确，然后等待加载也很重要，如果不等页面完全加载完就跳转也会让加密算法输出不正确，尚不清楚原因 12driver.switch_to.window(driver.window_handles[-1]) # 切换至漏洞库窗links = driver.find_elements(By.TAG_NAME, &quot;a&quot;) 这段就是把这个页面里所有的超链接元素都抓下来 123total = driver.find_element( by=By.CSS_SELECTOR, value=&quot;div.py-3.bg-light &gt; div.container.vuln-list-container &gt; div.py-3 &gt; div.d-flex.justify-content-between.align-items-center &gt; span.text-muted&quot;).texttotal = int(total[total.find(&quot;总计 &quot;)+3: total.find(&quot; 条记录&quot;)]) 这段是找下总共有多少条记录，不是很重要 1234567891011121314151617while hasNextPage and cnt &lt; toDo: #.... nextPageButton = driver.find_elements( by=By.CSS_SELECTOR, value=&quot;.px-3.btn.btn-sm.btn-outline-secondary.btn-bd-primary:not(.disabled)&quot;) if debug: print(len(nextPageButton)) hasNextPage = 0 for button in nextPageButton: if &quot;下一页&quot; in button.text: actions.key_down(Keys.CONTROL).click( button).key_up(Keys.CONTROL).perform() # driver.close() sleep(sleepSecond) driver.close() #关闭当前页 driver.switch_to.window(driver.window_handles[-1]) #前往下一页 hasNextPage = 1 break 因为记录有很多页，我们要一页一页爬，先找到翻页按钮，然后发现能按和不能按的按钮有一个.disable类的区别，我们就一直翻直到”下一页”变成disable为止然后每次点开一个新的就把老的关了 123456789101112131415161718192021222324for link in links: # 遍历所有超链接 if &quot;detail&quot; in link.get_attribute(&quot;href&quot;): link.click() # 进入cve sleep(sleepSecond) driver.switch_to.window( driver.window_handles[-1]) # 切换至新窗口 button = driver.find_elements( by=By.CSS_SELECTOR, value=&quot;.btn.btn-link.text-muted&quot;) if len(button): button[0].click() genRawDoc(driver, debug) cnt += 1 print(&quot;进度 {} / {}&quot;.format(cnt, toDo)) if debug: print(&quot;in &quot;+driver.title+&quot; at &quot;+driver.current_url) input(&quot;continue&quot;) driver.close() # input(&quot;closed&quot;) driver.switch_to.window(driver.window_handles[-1]) if debug: print(&quot;in &quot;+driver.title+&quot; at &quot;+driver.current_url) # input(&quot;continue&quot;) if cnt == toDo: break 页面里有一堆超链接，我们肯定不能每个都跳进去，发现漏洞详情的超链接里有detail关键字，我们就只找含这个关键字的跳，也是点开，转移焦点，爬数据，关闭，把焦点切回来，同样注意每次等待一会，可以防止访问量过大导致限流或者直接被封ip然后跳进去后发现参考链接如果数量过多会只显示部分，要先点一下 .btn.btn-link.text-muted 的按钮把所有东西都展开genRawDoc里的内容就没什么营养了，目前已经进入具体报告界面，直接定位对应内容，保存下来写入文件就行","link":"/development/selenium0x1/"},{"title":"frida常用api备忘录","text":"javascript APIProcessProcess.id : number返回目标进程的PID 1console.log(&quot;processid = &quot;, Process.id); 12$ python launch.py processid = 3819 Process.arch : String返回目标进程的架构 1console.log(&quot;processArch = &quot;, Process.arch); 12$ python launch.py processArch = x64 get和find系的函数建议使用get系,在查找失败时get抛出错误,而find返回NULLProcess.getModuleByAddress(address : NativePointer) : Module address为实际地址Process.getModuleByName(name : String) : Module 根据地址或名称返回 已加载的 目标库(.so库)的对象(Module对象)，地址需提供原生指针 123var lib: Module = Process.getModuleByName(&quot;liba0x9.so&quot;);var lb: Module = Process.getModuleByAddress(lib.base);console.log(&quot;lbname = &quot;, lb.name); 12$ python launch.pylbname = liba0x9.so Process.enumerateModules() : Module[]返回所有已加载的.so库，返回内容是Module对象组成的js数组 1234567var ls = Process.enumerateModules(); for (let i = 0; i &lt; ls.length; i++) { console.log(ls[i].base); console.log(ls[i].name); console.log(ls[i].path); console.log(&quot;------&quot;); } 123456780x768bb30ca000libgraphicsenv.so/system/lib64/libgraphicsenv.so------0x768bb6608000libgui.so/system/lib64/libgui.so..... ThreadThread.backtrace(context, backtracer) : NativePointer[]在java层不如直接调用android.util.log好用，主要用于追踪native层调用栈，通常加上this.context，backtracer有.FUZZY和.ACCURATE两种模式可选返回当前调用栈，返回类型是NativePointer组成的js数组，使用DebugSymbolfromAddress转化为可读符号 123456789var lib: Module = Module.load(&quot;liba0x9.so&quot;); console.log(lib.enumerateExports()[0].name); Interceptor.attach(lib.getExportByName(lib.enumerateExports()[0].name), { onEnter(args) { console.log(Thread.backtrace(this.context, Backtracer.ACCURATE).map(DebugSymbol.fromAddress).join('\\n')); }, onLeave(retval) { retval.replace(1337 as any); }, }) 1234$ python launch.pyJava_com_ad2001_a0x9_MainActivity_check_1flag0x768914fa0a2c libart.so!art_quick_generic_jni_trampoline+0xdc0x768914f83912 libart.so!MterpHelpers+0x1f5 ModuleModule类本身的属性 member use name : String 库名 base : NativePointer 库基地址 size : number 库大小 path : String 库的绝对路径 ModuleObj.enumerateImports() : ModuleImportDetails[]返回这个库的所有导入符号,类型为ModuleImportDetails组成的js数组 ModuleImportDetailsModuleImportDetails类的属性 member use type : ModuleImportType (function | variable) 导入符号的类型 name : String 导入符号的名称 module : String 导入符号来自哪个文件 address : NativePointer 导入符号在内存中的地址(绝对地址)，用于直接调用或修改导入函数 slot : NativePointer 导入表中指向导入函数的指针,用于重定向导入函数 123var lib: Module = Module.load(&quot;liba0x9.so&quot;);var ls = lib.enumerateImports();console.log(ls[0].name, &quot;from module :&quot;, ls[0].module); 12$ python launch.py __cxa_finalize from module : /apex/com.android.runtime/lib64/bionic/libc.so ModuleObj.enumerateExports() : ModuleExportDetails[]返回这个库的所有导出符号,类型为ModuleExportDetails组成的js数组 member use type : ModuleExportType (function | variable) 导出符号的类型 name : String 导出符号的名称 address : NativePointer 导出符号在内存中的地址(绝对地址)，用于直接调用或修改导出函数 ModuleObj.getExportByName(exportName : String) : NativePointer根据名称返回对应导出符号的指针，是frida hook native层函数的主要方法 Module.load(name : String) : Module根据名称(是的就是名称，至少vsc的frida type hint 里提示的是输入名称)返回对应native库的对象，与Process.getModuleByxxx的不同是该方法无需目标库已被加载，且使用该方法可以手动加载目标库 12var lib: Module = Module.load(&quot;libfrida0xa.so&quot;);console.log(lib.name); 12$ python launch.pylibfrida0xa.so Module.ensureInitialized(name : String) : void在目标库加载完成前阻塞程序进行 Module.getBaseAddress(name : String) : NativePointer返回目标库的基地址,等同于Module.load(name).base Module.getExportByName(moduleName : String | null, exportName : String) : NativePointer根据库名和符号名查找对应的导出符号，库名可缺省，此时在全局对该符号进行搜索 MemoryMemory.scan(address : NativePointer, size : number, pattern : String, callbacks : MemoryScanCallbacks) : void这是一个异步函数，用于在内存中扫描对应的模式，address指定了起始地址，size指定了扫描的字节数pattern是一个模式串，必须为以下任意的格式之一1.完全匹配 “1F 13 00 2F”2.通配符 “?F 13 00 ??” 其中?在匹配时可以是0~F中的任意一个3.掩码 “”13 37 13 37 : 1F FF FF F1”” 后面的为掩码，掩码中为1的位表示需要匹配，为0的位则可以是任意值 MemoryScanCallbacksMemoryScanCallbacks 是一个结构体，定义如下 1234567{ onMatch(address : NativePointer, size : number) : function //匹配成功的回调函数，address为成功匹配的地址，size为匹配到的长度 //该函数可通过 return 'stop' 提前结束 onError(reason : String) : function //处理错误的回调函数 onComplete() ： function //匹配结束的回调函数} 这个函数的同步版本为Memory.scanSync(address, size, pattern),返回由匹配到的address和size组成的对象的数组 Memory.protect(address : NativePointer, size : number, protection : String) : boolean修改对应位置内存的权限，返回true表示操作成功，protection为形同”rwx”的字符串 Memory.patchCode(address : NativePointer, size : number, apply : function) : voidapply里是具体要对内存进行修改的操作，address为起始地址，size为修改区域的字节数 NativeFunction获取native层函数的引用 NativeFunction(address, returnType, argTypes[, abi])创建方法var func = new NativeFunction(address, returnType, argTypes[, abi])address : NativePointer 函数地址returnType : [type] 返回类型argTypes : [types…] 参数类型 1const getFlag = new NativeFunction(getFlagPtr, ['void'], ['int', 'int']); // 用例 可用类型 123456789101112131415161718192021voidpointerintuintlongulongcharucharsize_tssize_tfloatdoubleint8uint8int16uint16int32uint32int64uint64bool TODO:NativeCallbackInterceptorJavaXXXWriterXXXRelocatorhexdumprpc.exportsTiming events Python APIfrida的python层主要负责拉起进程以及与js通信，涉及的业务逻辑并不多 参考链接Frida 官方文档Frida-Labs","link":"/ctf/Andorid/firdaApi/firdaApi/"},{"title":"[GWCTF 2019]babyvm","text":"提示是vm题 打开修复下符号，确实是vm题进去修复下结构体，结构还是很明显的修完后基本知道在干什么了，直接去看text段，指令有五百多个byte，写个脚本解析 123456789101112131415161718192021222324252627282930313233343536373839404142434445i = 0f = open(&quot;output.txt&quot;, &quot;w&quot;, encoding=&quot;utf-8&quot;)cnt = 0while i &lt; len(text) and cnt &lt; 2: if text[i] == 0xF1: print(&quot;mov &quot;, end=&quot;&quot;, file=f) op = text[i+1] i += 2 num = text[i]+text[i+1]*256+text[i+2]*256*256+text[i+3]*256*256 if op == 0xE1: print(&quot;r0 = input[{}]&quot;.format(num), file=f) elif op == 0xE2: print(&quot;r1 = input[{}]&quot;.format(num), file=f) elif op == 0xE3: print(&quot;r2 = input[{}]&quot;.format(num), file=f) elif op == 0xE4: print(&quot;input[{}] = r0&quot;.format(num), file=f) elif op == 0xE5: print(&quot;r3 = input[{}]&quot;.format(num), file=f) elif op == 0xE7: print(&quot;input[{}] = r1&quot;.format(num), file=f) i += 4 elif text[i] == 0xF2: print(&quot;r0 ^= r1&quot;, file=f) i += 1 elif text[i] == 0xF5: print(&quot;readInput&quot;, file=f) i += 1 elif text[i] == 0xF4: print(&quot;rip++&quot;, file=f) i += 1 elif text[i] == 0xF7: print(&quot;r0 *= r3&quot;, file=f) i += 1 elif text[i] == 0xF8: print(&quot;swap r0 r3&quot;, file=f) i += 1 elif text[i] == 0xF6: print(&quot;r0 = r2 + 2*r1 + 3*r0&quot;, file=f) i += 1 elif text[i] == 0xF4: i += 1 cnt += 1 # print(i, hex(text[i]))f.close() 这题有个很恶心的地方，他text段有两段逻辑，并不是rip到0xF4就停止了，前一段是假flag，要用类似栈溢出的方法去第二段逻辑最后手动逆出真正的加密逻辑如下 123456789for i 1 ~ 5 input[i] ^= [i+1]input[6]=(input[8]+2*input[7]+3*input[6])*input[12]input[7]=(input[9]+2*input[8]+3*input[7])*input[12]input[8]=(input[10]+2*input[9]+3*input[8])*input[12]swap input[13] input[19]swap input[14] input[18]swap input[15] input[17] 直接逆即可注意到密文也是假的，真正的密文在一个没有交叉引用的函数里 12345678910111213141516171819202122sec = [0x69, 0x45, 0x2A, 0x37, 0x09, 0x17, 0xC5, 0x0B, 0x5C, 0x72, 0x33, 0x76, 0x33, 0x21, 0x74, 0x31, 0x5F, 0x33, 0x73, 0x72]for i in range(30, 127): if sec[8] == ((sec[10]+2*sec[9]+3*i)*sec[12]) &amp; 0xFF: sec[8] = i breakfor i in range(30, 127): if sec[7] == ((sec[9]+2*sec[8]+3*i)*sec[12]) &amp; 0xFF: sec[7] = i breakfor i in range(30, 127): if sec[6] == ((sec[8]+2*sec[7]+3*i)*sec[12]) &amp; 0xFF: sec[6] = i breaksec[15], sec[17] = sec[17], sec[15]sec[14], sec[18] = sec[18], sec[14]sec[13], sec[19] = sec[19], sec[13]for i in range(5, -1, -1): sec[i] ^= sec[i+1]for i in sec: print(hex(i), end=&quot; &quot;)","link":"/ctf/WP/buu/GWCTF%202019%20babyvm/"},{"title":"从零开始的LLVM-pass （一） 环境搭建和第一个demo","text":"为什么有这篇文章前段时间看了点LLVM的博客，学的非常痛苦，所以打算写一篇文章记录一下基本的框架搭建过程，省的一段时间后又忘了 Demo实现一个 FunctionPass ，遍历所有函数，如果函数不是main函数就修改混淆函数的名字 关于环境开发环境是win，至于为什么不选linux，主要是没有物理机实在不方便，后续如果被win恶心到了可能会迁移到linux win-gnu-llvm下载 非常神奇的找到了兼容win-gnu ABI的llvm工具链，试了下能跑，索性先这样g++用的是MinGW，网上随便下一个新一点的都行 直接下载完就是编译完的二进制文件，把bin加到环境目录就能识别clang和opt了 框架搭建目录结构如图所示build是Cmake的输出路径，最终编译好的pass就存在里面test里是测试文件，用来测试pass的混淆效果transforms里是pass的源码 /transforms/CMakelists.txt12345678910111213141516171819202122232425# /transforms/CMakelists.txtcmake_minimum_required(VERSION 3.13)project(MyPass)set(CMAKE_C_COMPILER &quot;gcc&quot;)set(CMAKE_CXX_COMPILER &quot;g++&quot;)set(LLVM_DIR &quot;C://llvm-19.1.6-1/lib/cmake/llvm&quot;)find_package(LLVM REQUIRED CONFIG)include_directories(${LLVM_INCLUDE_DIRS})link_directories(${LLVM_LIBRARY_DIRS})add_definitions(${LLVM_DEFINITIONS})add_library(MyPass MODULE MyPass.cpp)target_link_libraries(MyPass LLVMCore LLVMSupport LLVMIRReader LLVMPasses LLVMAnalysis LLVMTransformUtils) CMakelist如上设置，要手动导入LLVM的cmake路径，然后中间这些宏都是LLVM的.cmake文件里自带的，直接抄就行之后就和正常cmake项目一样，设置链接库源文件，输出和依赖 test.sh123456789101112# test.shcd ./build cmake -G &quot;Ninja&quot; ../transforms cmake --build .cd ../testg++ test.cpp -o beforeLLVM_testclang++ -S -emit-llvm test.cpp -o test.llopt -load-pass-plugin=../build/libMyPass.dll -passes=encode-func -S test.ll -o test.out.llllc test.out.ll -filetype=obj -o test.og++ test.o -o test ./testcd .. 使用g++编译一份未加pass的二进制文件方便以后对比，使用clang++配合-S -emit-llvm参数输出llvm-IR文件，这是llvm的中间语言文件，之后pass所有的处理都在该文件上进行-load-pass-plugin=${filePath} 是opt新版的api，我们生成的是类似于插件库的dll，之后还要加上 -passes={passName} 指定具体用哪个pass，之后讲如何注册pas时会具体讲这个passName是怎么来的 处理好后用llc把中间文件编译成目标文件，再用g++把中间文件编译成可执行文件就完事了 MyPass.cpp1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &quot;llvm/IR/PassManager.h&quot;#include &quot;llvm/Passes/PassBuilder.h&quot;#include &quot;llvm/Passes/PassPlugin.h&quot;#include &quot;llvm/Support/raw_ostream.h&quot;#include &lt;string&gt;using namespace llvm;namespace{ class EncodeFunctionName : public PassInfoMixin&lt;EncodeFunctionName&gt; { private: static int functionCnt; public: PreservedAnalyses run(Function &amp;F, FunctionAnalysisManager &amp;FAM) { if (F.getName() != &quot;main&quot;) { errs() &lt;&lt; &quot;Old name: &quot; &lt;&lt; F.getName() &lt;&lt; &quot;\\n&quot;; F.setName(&quot;114514func&quot; + std::to_string(++functionCnt)); errs() &lt;&lt; &quot;New name: &quot; &lt;&lt; F.getName() &lt;&lt; &quot;\\n&quot;; } else { errs() &lt;&lt; &quot;function is &quot; &lt;&lt; F.getName() &lt;&lt; &quot;\\n&quot;; } return PreservedAnalyses::all(); } static bool isRequired() { return true; } };}int EncodeFunctionName::functionCnt = 0;extern &quot;C&quot; LLVM_ATTRIBUTE_WEAK ::llvm::PassPluginLibraryInfollvmGetPassPluginInfo(){ return { LLVM_PLUGIN_API_VERSION, &quot;encode-func&quot;, LLVM_VERSION_STRING, [](PassBuilder &amp;PB) { errs() &lt;&lt; &quot;\\n=== Registering EncodeFunctionName Pass ===\\n&quot;; PB.registerPipelineParsingCallback( [](StringRef Name, FunctionPassManager &amp;FPM, ArrayRef&lt;PassBuilder::PipelineElement&gt;) { if (Name == &quot;encode-func&quot;) { errs() &lt;&lt; &quot;Adding EncodeFunctionName pass to manager\\n&quot;; FPM.addPass(EncodeFunctionName()); return true; } return false; }); }};} llvm的所有实现都定义在llvm空间中，因为是个demo所以干脆直接using namespace llvm要实现一个自己的pass，我们要从 PassInfoMixin&lt;&gt; 这个基类模板继承，这是LLVM的新版API，区别于旧版的是我们不用指定pass的类型，而是依靠下面的 run 方法的实现区分pass类型，我们要实现一个functionPAss，所以 run 的参数就是 llvm:Function 和 llvm:FunctionAnalysisManager run 是pass中最关键的方法，一个pass所有的业务都是在run中完成的，这是一个回调，会对所有的函数执行，我们直接用getName获取名字，然后用setName重设名字就行，返回 PreservedAnalyses::all() 表示这个pass不会对其他任何pass产生影响，反正我们也只跑这一个pass，返回all即可 isRequired() 编译器可能会跳过我们的pass，因为实际上pass没做优化，所以要实现 isRequired 返回ture强制要求编译器执行我们的pass extern “C” LLVM_ATTRIBUTE_WEAK ::llvm::PassPluginLibraryInfo llvmGetPassPluginInfo()这是新版LLVM注册pass的惯用约定，这部分基本没什么好改的，返回一个四元组 {LLVM插件API版本号，插件名，插件版本号，注册回调函数} ，其中插件名就是我们用-pass时传递的名字，opt会解析这个名字并并调用相关回调，插件版本号随便写就行 回调会传入一个PassBuilder,我们往里面注册一个解析回调，每次opt解析我们的命令时都会执行这个回调，这个回调的格式也基本是固定的，最重要的是 Name ，这是解析得到的 passName ，我们调用 FPM.FPM.addPass(EncodeFunctionName()) 来完成注册 test.cpp123456789101112131415161718192021222324// test.cpp#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;void testFunctionA(){ std::cout &lt;&lt; &quot;testA&quot;;}void testFunctionB(){ std::cout &lt;&lt; &quot;testB&quot;;}void testFunctionC(){ std::cout &lt;&lt; &quot;testC&quot;;}int main(){ testFunctionA(); testFunctionB(); testFunctionC(); return 0;} 我们声明了三个函数，预期这三个函数的名字都会被改成114514funcxxx 输出根据pass输出的调试信息可以发现opt按照从上到下的顺序对每个函数执行了pass 然后再打开ida看看二进制文件是否真的被修改了 可以看到确实被修改了 下一篇文章可能会写一下怎么修改基本块和怎么混淆运算符","link":"/ctf/llvm/llvm0x1/"}],"tags":[{"name":"Python","slug":"Python","link":"/tags/Python/"},{"name":"selenium","slug":"selenium","link":"/tags/selenium/"},{"name":"Reverse","slug":"Reverse","link":"/tags/Reverse/"},{"name":"Andorid","slug":"Andorid","link":"/tags/Andorid/"}],"categories":[{"name":"Development","slug":"Development","link":"/categories/Development/"},{"name":"Reverse","slug":"Reverse","link":"/categories/Reverse/"},{"name":"Python","slug":"Development/Python","link":"/categories/Development/Python/"},{"name":"Andorid","slug":"Reverse/Andorid","link":"/categories/Reverse/Andorid/"},{"name":"Frida","slug":"Reverse/Andorid/Frida","link":"/categories/Reverse/Andorid/Frida/"},{"name":"LLVM","slug":"Reverse/LLVM","link":"/categories/Reverse/LLVM/"},{"name":"ctf-test","slug":"Reverse/ctf-test","link":"/categories/Reverse/ctf-test/"}],"pages":[]}