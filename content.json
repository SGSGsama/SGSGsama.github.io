{"posts":[{"title":"Android parcel 学习","text":"工作中遇到了需要处理安卓IPC通信的情况，安卓IPC通信即binder通信通过Parcel类来传递数据，记录一下Parcel的使用方法 Parcel 如何储存数据Parcel使用序列化的方法储存数据，本身采用二进制流+偏移量的形式存储数据，也可以理解为文件句柄中的文件流指针 常用方法obtain()parcel的构造方法，用来构造一个空parcel dataSize()返回parcel对象内存储的数据量 dataPosition()获取当前parcel对象的流指针偏移量 setDataPosition()设置当前parcel对象的流指针偏移量 recyle()回收当前parcel对象的内存，相当于delete write/read XXX往parcel里写/读数据，这个数据可以是任意的类型，只要是继承了Parcelable即可序列化即可，writeInt这种自然支持，此外还有writeTypedObject这种可以支持复杂的数据结构,在写入后指针偏移量会自动向后移动注意到一个Parcel的读写行为都共用一个指针偏移，所以如果写入了东西后要读取则需要重新设置偏移量 writeException()往Parcel头写入异常，与之相对的是writeNoException用于写入无异常 readException()读取Parcel头，如果Parcel头写入的是异常就抛出该异常，否则不做任何处理 对齐方式Parcel中采用四字节对齐，如果是小于等于四字节的类型会对齐到四字节储存，大于四字节的则按4bytes的倍数储存，但dataPostion还是按照一个字节为单位设置偏移量的，dataSize也同理","link":"/development/Android_parcel/"},{"title":"ACM刷题日记","text":"想起来去年还在打acm的时候写了一段时间的做题日记，索性放到博客上好了 CF1898D Milena and Admirer贪心 绝对值图像化思想把$ a_i $，$b_i$抽象成线段的端点，|$a_i-b_i$|表示线段长，操作等同于交换两个线段的端点，通过分类讨论求每种情况下产生的贡献 CF1901B Chip and Ribbon思维还算有趣的题，推一下发现每次操作的贡献是当前段数 * 当前剩下的最小的数，如果是第一次操作则后者减一，对于维护段数，考虑对于每个数存它出现的位置，如果删除时左右都有数则标记段数++，如果左右都空则标记段数– CF1901C Add， Divide and Floor推式子找规律让整个序列都相同等价于把最大的和最小的变成相同的假设每次选一个满足$minn \\leq x \\leq maxn$的x$\\Delta maxn=\\lvert \\frac{maxn-x}{2}\\rvert= \\frac{maxn-x}{2}$$\\Delta minn=\\lvert \\frac{minn-x}{2}\\rvert= \\frac{x-minn}{2}$ 发现如果不考虑精度误差则x可以任意选，考虑精度误差，发现当maxn为奇数，minn为偶数时，选x为偶数可以使maxn下降更快，minn上升更快，反之同理 CF1901D Yet Another Monster Fight思维意外的简单，不知道为啥场切人数那么少显然对于每一个$a_j$，答案最差的情况是在到达$a_j$左侧或右侧某个很大的点$a_i$之前多走弯路(浪费威力最多)，可以对这个大点$a_i$按在$a_j$的左侧或是右侧分类讨论，通过手模发现，结果为$ans_{a_j}=max\\begin{cases} n-i+a_i ，\\quad i &lt; j \\ i+a_i，\\quad i &gt;j \\ a_j\\end{cases}$直接开两个multiset L，R，j从左向右扫，每次删掉一个右边的，增加一个左边的，对于每个j统计答案取min即可 数论涉及多个gcd求和 CF1900D有可能是欧拉反演，但是不想学数论 CF1900E Transitive Graph图论tarjan对于随便一个环(强连通分量)，按题意会连成一个完全图，也就是说在这个块里可以任意走要走长度最长且点权和最小的路，因为上面的条件所以随便一个强连通分量我们都可以一笔画走完，显然能走就走是最优的，tarjan跑完写个拓扑跑类似最长路的dp即可 ####CF1896A Jagged Swaps 结论$a_1=1$就是合法的，手模得出 CF1896B AB Flipping结论同样有趣的题，手模发现原序列去掉前导B和后导A后每个点都可以操作(后面的B可以被一路换到前面去)，固答案为$max \\lbrace 0，len-1 \\rbrace$ CF1896D Ones and Twos结论+DS题目里给了$a_i \\in \\lbrace 1，2\\rbrace$是有道理的对于一个左右端点都是1的子串，任意删掉一个端点的1可以改变子串和的奇偶性，连续删去两个1等价于删去一个2(无论两个1是否相连，由分类讨论得)，那么显然对于每个询问，先取出左右端点为1的最长的串L，如果$sum_L\\geq v$那就合法，否则考虑$sum_L$和$v$的奇偶性，奇偶性相同就向两边凑2，不同则删去一侧的1然后取剩下侧的2，左右端点重合的情况也适用 用set存每个1的位置，查询时直接取set的头尾，区间和用树状数组维护 CF1896C Matching Arrays贪心似乎这种题都是大的对大的小的对小的？ constexpr预处理这个关键字放在定义前可以让后面的东西在编译的时候跑，可能初始化素数表之类的挺有用的？ ####重载运算符对于二元运算符重载的时候成员函数作为左边的参数，显式操作数作为右边的参数 move()a=move(b) 把b的资源转移给a，比复制快很多，大概在滚动数组里有用 CF1902C Insert and Equalize贪心还算巧的贪心，选择一个数$x$使得可以通过不断加$x$让$a_{1…n+1}$相等，首先考虑$a_{1…n}$，先从小到大排序然后考虑相邻项的差值，因为只能不断加一个数这个数只能是这些差值的大公因数，不然凑不齐。然后考虑$a_{n+1}$，记之前得出的最大公因数为$g$，则$a_{n+1}$可以由$a_n$加上或减去g得到，我们优先考虑减，如果减了n次都不行就直接令$a_{n+1}=a_n+g$，同时把{a_{1…n}}抬高g CF1902D Robot QueriesDS+前缀和询问执行给定操作后是否经过指定点，先不考虑翻转，可以把经过的点做成一个前缀和，对于每个询问查询前缀和数组里是否有这个点考虑翻转的情况，对于一个原本能到达的点$pre_i=(x，y)$，我们先把它还原到翻转区间的起点，即$pre_i-(pre_i-pre_{l-1})$，然后看他翻转后是什么样，即$pre_i-(pre_i-pre_{l-1})+(pre_r-pre_{i-1})$如果这个反转后到达的点就是所求的$P=(x，y)$，那么整理下得出$pre_{i-1}=pre_{l-1}+pre_r-P$，所以对于翻转过的区间，我们只要在$[l-1，r-1]$里找是否有符合条件的$pre_{i-1}$即可，对于正常的区间就在$[0，l-1]，[r+1，n]$里找是否有询问的点$P$即可，显然翻转后对于翻转区间外的点是没影响的。找点的具体实现用线段树套set，线段树的每个节点上开一个set，添加点就一路insert到叶子，查的时候合并各区间答案即可 CF1907B YetnotherrokenKeoard栈签到题，分大小写开两个栈即可 CF1907C Removal of Unattractive Pairs贪心发现最后肯定只剩一个字母了，而且那个字母肯定是数量最多的，根据出现次数最多的字母的数量和n的大小分类讨论即可 CF1907D Jumping Through Segments二分二分答案，在check的过程中维护每次能到达的点的区间$[a，b]_n$，显然这个$[a，b]n$的更新可以通过分类讨论$[a，b]{n-1}$与$[l_n，r_n]$的相交情况实现，如果不相交就说明k非法 CF1907F Shift and Reverse哈希+结论首先这道题要知道只有以下几种情况可能是最优的：1.一直往前翻2.翻转然后一直往前翻3.翻转一直往前翻然后翻回来4.一直往前翻最后翻转这四种情况1，4等价于把后面的搬到前面去，2，3等价于把前面的搬到后面，然后最后的结果是使序列变成递增或递减的然后我们把原序列复制一遍放在后面，这样扫过去就可以直接得到所有我们可能通过操作产生的序列，然后操作数可以直接算出来，具体通过手模找规律，然后只要扫到某个数$a_i$是最大或是最小的（可以作为单调序列的起点），我们就用哈希判断$a_{i…i+n-1}$是否和排序好的序列一样，如果一样就计算把原序列变成这样需要的最小操作数并更新答案 set使用自定义类型对于自定义类型，劣质的重载&lt;会影响set的行为(大概率导致set出问题) CF1904B Collecting Game双指针双指针板子题，排序后跑双指针即可 CF1904D1 Set To Max (Easy Version)贪心easy version的数据较小，直接跑$n^2$的贪心即可，hard version可能要在原做法上加一个线段树维护区间最大值从小到大依次取$a_i$，然后分别向左右拓展，只要是扫到的数比$a_i$小并且比$b_i$小就可以把他设为$a_i$，最后扫一遍a看和b是否相同即可 CF1904D2 Set To Max (Hard Version)贪心+RMQ还真是原做法随便加一个单次logn或者更优的rmq，对于一个需要set to max的$a_i$显然我们需要找到它左边或右边最近的和$b_i$相等的$a_j$，选最近可以让一次操作对其他数字的影响最小，然后用rmq查$a_{i…j}$里面是否有比$b_i$大的，$b_{i…j}$里面是否有比$b_i$小的，如果都没有显然这次操作是合法的，然后优化下easy version取数的方式，改成从小到大取$b_i$（从结果入手），总的复杂度限制在rmq初始化$nlogn$ CF1904C Array Game分类讨论发现对于k&gt;=3，可以直接先选两次一样的$a_i，a_j$，然后第三次让两次的差互相减，答案肯定为0对于k=1，直接在所有的差和本来就有的数中间选一个最小的即可对于k=2，先$n^2$搞出来所有的差，然后每次在原数组中lower_bound一下去找和这个差最近的数再做差，也是把搞出来的所有数取min求答案，复杂度$n^2logn$ 后缀BIT把前缀树状数组的所有循环顺序倒过来就能实现后缀bit 费马小定理一个数在 mod b下关于a的逆元为 $a^{b-2}$ CF1917B Erase First or Second Letter计数对于一个字符串，如果确定第一个和第二个字符，那就不能继续操作了，可以将最终的字符串拆分成一个后缀和一个字母组合的形式，我们可以不断进行操作2来使一个字母匹配每一个后缀，同时因为我们只能删前两个字母，所以实际上我们最多有n个不同的后缀，且长度分别为1~n，所以我们要统计对于每一个后缀，前面有多少个不同的字母可以与其组合，开一个桶计数即可，把每个后缀的答案求和就是总的答案。 CF1917C Watering an Array贪心一个重要的性质，假设a=[0，0，…，0]，不管b的组成是什么样的，且执行几次添加操作，始终最多有1个$a_i=i$，因为假设$a_x=x$，那么对于$a_x$前面的所有$a_i$肯定有$a_i \\geq a_x$（因为每次是对一个前缀+1），对于后面的同理，所以如果我们进行过一次reset操作，之后最优的做法一定是add一次就reset一次，总贡献为d/2，所以问题转化成确定第一次reset的时间，注意到第一次reset最多也就产生n的贡献，所以如果我们第一次reset的时间晚于2*n+1，则一定不是最优的，即一开始最多add 2n次，直接暴力add 并统计答案取max即可，注意判断操作是否合法 CF1917E Construct Matrix构造非常神秘的构造，答案一半很显然，一半很不显然要求构造一个n*n的矩阵m，n为偶数，要求每行的1的数量同奇或同偶，每列同奇或同偶，且总数等于k首先特判，如果$k = n^2-2 || k=2 $，此时如果k!=2，则无解然后是对于k%4=0的部分，显然我们可以尝试把1组合成2x2的块放进去，一个2x2的块对横纵的奇偶性都是没影响的对于k%4=2的部分(不知道怎么想到的)如果k&lt;6肯定是第一种无解的情况，当$k \\geq 6$，我们先把$m_{1，1}，m_{1，2}，m_{2，1}，m_{3，3}，m_{3，2}，m_{2，3}$这六块变成1，然后剩下k-6的部分在除左上角4x4的范围继续组成2x2的块填进去，然后$k=n^2-6$则正好会有4个1多出来，则在$m_{1，3}，m_{1，4}，m_{4，4}，m_{4，3}$四个位置填上1，对于其他的所有情况，均无解 CF1913B Swap and Delete思维，字符串定义两种操作，从s中删去任意一个字符，代价为1，任意交换一对字符，代价为0记操作任意次后得到的字符串为t，问使t与s对应位置的字符均不相同的最小代价因为交换是无代价的，所以只要让t的1数量和s长度为|t|的前缀的0数量相同，反之亦然即可考虑直接枚举答案，显然答案最大为|s|，删完了肯定都一样了，对于每个答案n，实际上我们可以在合法的前提下任意删除总数为n的0和1，如果s里的0比t里的1多肯定这个答案是不行的，因为我们只能从t里删东西，对于每个可能成为答案的t，一定有$cnt1_t=cnt1_{preS_|t|}$，所以我们只要对于每个可能成为答案的t，统计s的0与t的1的数量差值和s的1与t的0的数量差值，如果两个差值和与我们枚举到的答案相等，则这个答案就是合法的，从小到大枚举找的合法的就退出即可 CF1913C Game with Multiset贪心，二进制很套路的题往一个集合里多次插入$2^x$，多次询问集合里的数是否可以凑出w显然先把w拆成二进制的形式，然后每次询问从低位向高位枚举，如果集合里这位有多的就除二借给下一位，一路枚举到头即可 CF1913E Matrix Problem最小费用最大流板子题，出在div2E估计是科技太高了发现n很小，且是约束问题，考虑网络流要求$i$行要有$a_i$个1，$j$列要有$b_j$个1，可以建超级源超级汇，合法的情况就是每个$a$点有$a_i$的流量，每个$b$点有$b_j$的流量，直接从源点向每个$a$拉流量为$a_i$的边，从每个$b$向汇点拉流量为$b_i$的边，费用均为0然后中间$a，b$直接拉完全图，边代表矩阵里的点，流量都是1，如果这个点本来是0，就拉费用为1的边，如果已经是1了，就拉费用为-1的边，同时先在答案里+1，表示如果这个点最终就是1，则不需要付出代价，所以费用和先加的1抵消，如果这个点最终应该是0，那这个点的流量就不会算进总流量里，也不会计算这个点的费用，按题意需要付出一点代价，而这个代价在拉边时已经加好了建完图跑dinic板子即可，最后如果a，b流量都跑满且相同就是合法答案 CF1914C Quests贪心显然最优答案是前i个先各做一次，然后剩下k-i次全部做b最大的那一个 CF1914D Three Activities贪心假设每次我们都只选a，b，c里前三大的i，最差的情况是这三个都相同，如果随意拿掉一个a，b，c也总还有两个可以选，而且这些选的都是前三大的，答案一定是在这里面产生的，所以直接找三元组里a，b，c分别是前三大的，从这几个(3~9个)里暴力枚举答案 CF1914E Game with Marbles贪心easy version直接爆搜hard version这么考虑，对alice，一次操作产生的贡献是$a_i+b_i$（A取了$a_i-1$，同时B的$b_i-1$不能取了，等价于对总答案的贡献是$(a_i-1)-(b_i-1)$），发现对bob来说也是同理，所以直接按照$a_i+b_i$排序，依次取大的即可 CF1914G1 Light Bulbs (Easy Version)tarjan这题有2100？ 不是很认可mod 998244353不开long long 是存在溢出并且输出不是负数的可能性的(能开long long 尽量开)发现对于一个颜色，显然如果我们先把一个灯点亮，那另一个灯也亮了，然后这两个灯之间的通过操作2也全亮了把灯抽象成线段的两端，如果一条线段被另一条完全覆盖，那只要长的那条点亮就行，如果交叉覆盖，则任意点亮一条即可，考虑对于每条线段u，向他所覆盖到的所有线段v拉单向边，表示点亮u就能点亮v，这样对于完全覆盖就是只能点亮u，对于交叉覆盖就是u，v任意点亮一个，注意到这里产生了强连通的问题，把图建好后跑缩点，缩完点的图中入度为0的点的数量就是S的大小，然后显然这些入度为零的点里被压缩了颜色数*2个灯泡，用乘法原理全乘在一起就是方案数 CF1918A Brick Wall贪心一个砖的大小是$1k$，墙的稳定性是横着的砖的数量减去竖着的砖的数量显然偶数长度就直接全部$12$的砖，奇数长度就一排$13$的砖，其他的就全部继续用$12$的 CF1918B Minimize Inversions思维给定两个序列A，B，可以同时交换$a_i，a_j和b_i，b_j$，要求输出排序后的A，B，使得其中逆序对的数量和最少考虑单独的一对$a_i，a_j，b_i，b_j$可能会有0，1，2对逆序对的情况，对于0的情况，交换产生2组逆序对，对于1的情况，交换消除一组逆序对，并产生一组逆序对，对于2的情况，交换消除两组逆序对发现如果对A排序，那么A中的逆序对数为0，那么对于所有的$a_i，a_j，b_i，b_j$，只会出现1和0的情况，而这两种情况无论怎么交换都无法减少逆序对的总量，所以此时总的逆序对数达到最小 CF1918C XOR-distance思维异或问题拆位考虑假设$a&gt;b$，发现如果我们搞a，b的最高位（对齐情况下），就会搞完后$a &lt; b$，那后面就没法确定怎么搞了，所以考虑不动最高位，从次高位开始搞，这样不管怎么弄都能满足$a&gt;b$，只要尽可能缩小a并增大b就行了对于a，b该位都是0或1的情况显然对答案没影响1：对于a是1，b是0的情况，x这位是1对答案有贡献2：对于a是0，b是1的情况，x这位是0对答案有贡献所以对于每一个情况1，在$x \\leq r$的前提下不断将x这位置1就可得到最终的x CF1918D Blocking Elements二分 单调队列 dp给定一个序列，要求通过删去元素把序列分为的几段，同时删去的元素一起作为一段，要求使所有段中和最大的最小 最大值最小考虑二分答案，在序列头和尾分别设两个值为0的虚点，$dp_i$表示目前到第i个元素，并删除这个元素，此时被删除元素的总和的最小值，我们每次更新$dp_i$最好是选择某一块合法区间内最小的dp值，考虑单调队列维护这个值，当队头不合法时（队头和i之间的元素和超过二分的答案），不断弹出队头，每次使用队头的值更新此时的$dp_i$，并不断弹出比$dp_i$大的队尾元素，并把i插入单调队列，只要$dp_{n+1}$比此时的答案小，就继续更新答案 CF1921D Very Different Array贪心从B里选n个作为数组A，使$A_{1…n}和C_{1…n}$对应位元素差的绝对值之和最大考虑先让B里最大的对应C里最小的数，这样B里会剩下一些最小的数，同时发现这样每次产生的贡献使递减的，同时最后可能会有B中的数比C中的数小的情况，所以我们再倒着用B里最小的数去对应C里最大的数，这样每次更新答案只用变换一个位置的值，不断更新答案的最大值即可 CF1921E Eat the Chip贪心 结论Alice可以往下，左下，右下走，Bob可以往上，左上，右上走，Alice先手，问谁赢或者平局贪心地想，两边同时向左，同时向右，一左一右都不影响横向距离的奇偶性，即不影响最后谁赢，只有纵向距离的奇偶性影响结果，所以纵向距离为奇数时，bob必定会考虑保平，反之同理考虑保平的情况，显然游戏结束的时间时确定的，即双方纵向位置相同的时候，此时不能吃掉对方就一定平局，所以直接考虑不可能赢的那方在结束前最远能到达左边或右边的哪个位置，再看另一方能否也到达那个位置，能到达就赢，否则平局 CF1922A Tricky Template贪心给定一个字符串s，称满足以下条件的小写字符串t是符合题意的1.如果s第i位是小写，t这一位必须和s一样2.如何s第i位是大写，t这一位必须和s不一样给定符合题意的字符串a，b ，和不符合题意得字符串c，问这样的t是否存在如果a，b，c这一位不一样，只要让t这一位和c一样并大写即可如果a，b这一位一样，和c不一样，只要让t这一位和ab一样并小写即可 CF1922B Forming Triangles组合数给定n个木棍，第i根木棍的长度是$2^{a_i}$，问选三根木棍组成三角形有多少种方案首先发现木棍的长度都是2的幂，显然想组成三角形就只能组成等边三角形，找到每种长度的棍的数量求组合数就行了 CF1922C Closest Cities贪心n个城市在数轴上，有两种移动方式1.移动到任意城市，代价为两城市间的距离2.移动到最近的城市，代价为1q次询问，问从a到b的最小代价发现对于每个城市，发现在只考虑往一个方向走的情况下他和离他最近的那个城市的距离可以压成1，然后显然我们每次询问肯定都是往一个方向走的考虑向左和向右走两种情况分开做，预处理出新的位置，然后询问时直接位置相减算答案 CF1922D Berserk Monsters贪心 set 链表每个怪物每轮会被他的邻居攻击，每轮结束时，受到的伤害大于防御的怪物会死亡，问每轮死亡的怪物数每一轮结束后，如果一个怪物这一轮没有死，且他的邻居也没有死，那他下一轮也不会死（受到和这一轮一样的伤害）所以我们考虑每轮结束时，把死亡的怪物加入set，显然下一轮我们只要更新这些怪物的邻居的答案就行了，更新答案的总复杂度最差为O(3n)，找邻居和删除的过程用链表实现 CF1923A Moving Chips贪心一个1可以被移到最左边最近的空格，问把所有1连起来的最小移动次数显然删除前导0，后导0，剩下的0的数量就是我们要移动的次数 CF1923B Monsters Attack!贪心每秒发射k个子弹，任意分配，每发子弹造成1点伤害，数轴上n个怪物，每秒向原点移动一格，如果任意一秒结束时原点上有存活的怪物则失败，问能否杀死全部怪物先把所有怪物按离原点的距离排序，考虑按秒模拟，每秒射出的总子弹数增加k，并减去这一秒到达原点的所有怪物的血量值，如果出现子弹数不够则失败 CF1923C Find B贪心 构造一个长度为m的序列a是好的当且仅当存在一个长度为m的序列b满足1.a的和等于b的和2.a和b每一位均不相等3.b每一位都大于0给定一个序列c，q次询问，每次问c的一个子段是否是好的显然有一种贪心的构造法，我们考虑c的这个子段里有多少个1，对于这些1，我们构造2，对于剩下不是1的，我们全部构造1，然后如过此时总和还不够，就把少的全部任找一个2加进去，如果不能这么做则这个子段就是不是好的 CF1923D Slimes贪心 二分 前缀和n个史莱姆，每秒有且只有一只史莱姆吃掉一个大小严格小于他的邻居，且大小变为两者之和，n次独立询问，问每只史莱姆最早第几秒被吃掉一个重要的性质，假设一个史莱姆i最终被j吃掉，而j在吃i之前一定吃了包含j的一个子段里的所有史莱姆，然后我们发现，找到j等价于找到这个子段，而这个子段一定是在i的左边或右边且与i相邻，且和正好大于i，即不用去考虑j吃掉i的具体过程，$ans_i$就是这个子段的长度，所以问题转化为对于每个i，找到他左边或右边最短的总和大于他的子段，前缀和+二分即可，总复杂度O(nlogn) CF1945B Fireworks结论观察样例发现答案就是$m/a+m/b+2$ CF1945C Left and Right Houses前缀和前缀和统计1的数量，枚举断点即可 CF1945D Seraphim the Owl贪心假设从i交换至j，发现有两种交换途径，一种是每次只前进一格，这样每次代价为$a_{i+1}$，或者前进x格，那么代价为$\\sum_{p=i+1}^{i+x-1}b_p+a_x$，发现这两种前进方式是灵活的，如果这一步不是终点的话，我们的代价是$\\min(a_i，b_i)$，因此从i交换到j的最优解是$\\sum_{p=i+1}^{j-1}\\min(a_p，b_p)+a_j$，倒着累加即可 CF1945E Binary Search结论考察了二分的性质，对于我们瞎跑出来的l，可以发现有$p_l \\leq x$，这是给出的描述决定的，然后发现如果我们把此时的$p_l$换成一个不大于$x$的数，显然对l的位置也没有影响所以我们直接在原序列上跑题目给出的二分，然后把$x$的位置和跑出来的$l$交换即可 CF1945F Kirill and Mushrooms贪心 set首先为了方便处理不能选的情况，把原序列按$i_{s_j}$从小到大排序依次考虑选$k$的个情况假设我们要选$k$个，那么最优的做法肯定是从可以选的$n-(k-1)$个里选$k$个最大的，可以考虑从选$k-1$个的情况转移来，我们考虑开两个set，把没选的扔进unselect里，选了的扔进select个里，当我们准备选第$k$个的时候，根据题意此时排序后的第$k-1$个就不能选了，如果他在unselect里，就把他删了，然后再选unslect里最大的移到select里，如果他在select里，也把他删了，再从unselect里选最大和次大的移到select里，可以发现这样单次更新答案是logn的，unselect空了就结束，每次更新答案时统计最大值即可 gym104090M ICPCHZ2022 M. Please Save Pigeland换根 线段树缝合怪题，给定点集$S$，要求在树上找到一个点$u$，使得$\\frac{\\sum dist(u，S_i)}{gcd(dist(u，S_i))}最小$考虑换根，我们先求出$u$为1的情况，然后以1为根开始换根，发现我们每向经过一条边$E(u，v)$，对答案产生的影响是$v$子树内的所有特殊点的$dist$全部减去$dis_{E(u，v)}$，其余的特殊点全部加上$dis_{E(u，v)}$，考虑记录以1为根的每个点的dfs序，可以发现一个点子树内的点满足$dfn[u]\\leq dfn[v] \\leq dfn[u]+siz[u]-1$，可以把特殊点按dfs序排序并每次通过两次二分求左右端点的方法得到哪段是要被减去距离的，我们需要一个可以维护区间加减和区间gcd的数据结构，考虑线段树，由gcd的性质得知一个序列的gcd等同于这个序列的差分的gcd，问题转化成单点修和区间gcd，所以每次换根的时候，用线段树维护差分数组，并统计整个特殊点序列的gcd计算答案即可，总复杂度$O(nlog(n)log(V))$ CF1956F Nene and the Passing Gameset 思维因为能否传接球的关系是双向的，不妨设$i&gt;j$，把给定的式子化简一下，可以得到 $i-l_i \\geq j+l_j$ $i-r_i \\leq j+r_j$ 可以在保证1式成立的前提下考虑2式，我们可以把n个人拆成权值分别为$i-l_i$和$i+l_i$的2n个点，再把这些点按权值从小到大排序，这样我们就能保证每个点对前面的所有点都满足1式，同时我们可以把权值为$i+l_i$的点视作修改，把权值为$i-l_i$的点视作询问，每当扫到前者时，我们往一个递减的set中插入该点，权值为$i+r_i$，这样当我们扫到代表询问的点x时，只要不断从set头中取出满足$x-r_x \\leq i+r_i$的点i与x组成连通块，并从set中删去该点，连完后再把整个连通块的根塞回set里，最后统计连通块的数量就可以得到答案了同时我们注意到，对于一个连通块，我们只要看他最大的$i+r_i$的值，所以只要把第一个取出的点作为整个连通块的根即可，因为我们保证了set中第一个取出的点一定是全局$i+r_i$值最大的 CF1942A Farmer John’s Challenge结论对于$n=k$ 显然全部输出1就行了对于$k=1$ 显然先输出n，再依次输出1~n-1即可对于$1&lt;k&lt;n$，发现一个有序序列只要平移一次一定会变成无序的，所以这些都是不可能的情况 CF1942B Bessie and MEX贪心由于mex和排列的性质，考虑倒着做对于$ans_n$，显然此时的mex为n，直接可以算出$ans_n$，当知道了ans_n后，$ans_{n-1}$的mex显然就是目前的mex和$ans_n$的值取小的那个，不倒推即可 CF1942C Bessie’s Birthday Cake贪心 思维考虑y=0的情况，把给定的点连成多边形，对于一个多边形，其内部能划分出的三角形个数就是其边数x-2，然后我们发现如果两个给定的点之间夹了一个未给定的点，这种情况也能组成三角形，所以就是统计距离为2的点对的数量ans,最终答案是ans+x-2 当$y \\neq 0$时，我们要不断构造上面所说的距离为2的点对的情况，这也能分两类讨论，当两个相邻的给定点距离大于2时，根据画图找规律可以发现，在把间隔按照中间每隔一格赛一个点的规则填满时，当距离（$a_x-a_y$）为偶数，一共可以填$(a_x-a_y)/2$个点，产生$(a_x-a_y)/+1$个三角形，当填不满时则少一个，当距离为奇数时，可以填$(a_x-a_y-1)/2$个点，产生$(a_x-a_y-1)/2$个三角形，所以我们先填距离为偶数的间隔，并先填短的，注意处理未填满的情况即可 CF1957B A BIT of a Construction贪心直接从低位到高位枚举$a_i$并将k减去$a_i$即可 CF1957D A BIT of an Inequality思维 二进制我们把原式展开，首先可以的到几个结论： 当x=y=z时肯定不符合题意 原问题等价于，对于一个区间的异或和$pre_{l…r}$，问这个区间内有几个数$a_i$满足$a_i \\bigoplus pre_{l..r} &gt;pre $ 进一步分析2，发现2等价于，要求$a_i$的最高位对于$pre_{l..r}$而言，该位为0 发现如果枚举区间复杂度无法接受，考虑对于y寻找可能的x，y，即区间的左右端点，从左往右枚举y，考虑分别记录y左边至0，y右边至n有多少个$pre_i$第j位为0或者1，假设j为$a_i$的最高位，我们只需简单使用乘法原理（cnt0之间相乘,cnt1之间相乘）就可以得到有多少对$pre_r \\bigoplus pre_l$满足题意实现过程中注意，开始应该把所有点都扔进右边的桶里计数在计算$a_i$的答案时，考虑到实际的区间左端点是$l+1$，所以我们先算答案，再把$pre_i$从右边的桶移到左边的桶，这点通过画图可以得知 CF1966A Card Exchange贪心发现我们只关心一次换了k-1张牌，不关心牌具体的情况，所以最优策略就是每次换当前数量最多的，换过来的k-1张牌存进tot里，遇到不够换的时候拿tot补，最后没法换了把剩下的总牌数加上剩下的tot就是答案（注意最后tot和k-1取min）,开个堆瞎搞即可 CF1966B Rectangle Filling思维发现对于一种颜色，我们相当于是选一条对角线代表的矩形涂色，我们考虑看对于每个颜色，显然它在x轴上最多只能涂到x值最大的同色块那么远，然后x轴和y轴的答案显然是不干扰的，所以要全部涂成同一颜色，我们只要看对一个颜色，它最小的x值和y值是否为1，最大的x值和y值是否为n和m即可 CF1966C Everything Nim博弈论对于每轮游戏，选择一个最多不超过最小石子堆石子个数的正整数k，并将每个堆都移去k个石子因为每次移的个数有上限，而且还是对所有的堆都移，考虑每轮最多能移几个，发现问题等价于对原序列排序后的差分数组进行移石子，且遇到0全部跳过（显然），而且只能从左往右移，然后考虑先后手，当目前堆石子数大于1的时候,先手的那个人可以选择全部移走，或者留一个，意味着他可以决定在移下一堆石子是自己是先手还是后手，也就是再之后遇到1时的强制交换先后手对它没有影响（这点手摸可以发现），所以我们只要考虑遇到第一个大于1的数时谁是先手，也就是统计去0后的差分数组里连续的前导1的数量（不包括差分数组最后一位的数），偶数Alice，奇数Bob CF1966D Missing Subsequence Sum构造看到串的长度小于25，考虑二进制分解，我们可以构造一个1,2,4…的串，同时这个串不包含k最高位的1，这样我们就确保了对于这一位是1的所有数都凑不出来然后考虑如何凑出这一位是1的，且不等于k的其他数，假设这一位为i，串中比它低的位的和加起来是$2^i-1$，那我们如果放一个$k-2^i$，它与前面这些数加起来就是k-1，根据二进制分解的原理我们确保了1…k-1都可以凑出来,然后我们可以暴力添加一个k+1，那么这个k+1与我们前面已经构造出来的1…k-1就可以凑出k+2…2k, CF1969A Two Friends贪心有长度为2的环答案就是2，否则是3 CF1969B Shifts and Sorting贪心手玩发现对于1100，我先操作$s_{1…3}$再操作$s_{2…4}$和直接操作$s_{1…4}$结果是一样的问题就化为从左往右，对于每一个1，把他和他后面遇到的第一个0交换位置（以这两个数为端点执行一次右移）注意到我们这么做的实质是不断把1后面的0提到最前面，所以我们只要记录第一个1的位置pos，然后每次操作后pos+1就是下一个1的位置，所有的1是很自然被排到一起的 CF1969C Minimizing the Sumdp一次操作可以把一个数左边或右边的邻居替换为它，问最多操作$k (k \\leq 10)$次后整个序列和的最小值发现k很小，考虑预处理以i为右端点，i-j为左端点,操作j次产生的贡献$v_{i,j}$,以i为右端点可以方便处理后效性的问题自然想到dp数组$dp_{i,k}$代表前i个数操作k次产生的最小贡献考虑如何转移，假设我们在i处操作j次，此时总共操作了k次，$dp_{i,k}$显然就要从$dp_{i-j-1,k-j}$前面的状态转移来，然后我们肯定要从前面里选一个最小的,所以$mindp_{i,j}$表示$dp_{1…i,j}$里最小的值，转移方程就是$dp_{i,k}=min(dp_{i,k},mindp_{i-l-1,k-j}+v_{i,j})$，记得每次转移完后更新$mindp_{i,j}$,并且$mindp_{i,j}$在进入第一次转移前初始化为$mindp_{i-1,j}$，dp入口为$dp_{0,0}$，因为没说一定要选k次，所以dp和mindp初始化全0即可 CF1969D Shop Game贪心选任意个物品，alice可以以$a_i$的价格买入,并以$b_i$的价格卖给bob，bob可以选择不超过k个物品免费拿走，bob希望alice的总收入最少，alice希望最多，问alice的最大收益是多少 对bob来说，显然他会拿走alice的物品里$b_i$最大的k个，所以我们按b从大到小排序，可以将原序列分成两部分，对于一个$i(i&gt;k)$，它左边需要选k个a最小的的让bob拿，并且其他的都不拿，右边则是a&gt;b的全拿，然后我们往右枚举这个断点并每次统计答案，左边拿一个优先队列维护前k个最小的a的和即可，右边先对$b_i-a_i$求和，然后不断减掉即可，对于左边为什么不用选超过k个，我们考虑，因为bob的行为其实是固定的，对于alice一个物品都不移除的情况，bob实际上就是选第1…k个免费拿，当断点移动到k+2的时候，如果我们不移除k+1，实际上bob还是拿1…k，而不移除k+1的情况在断点为k+1时已经计算过答案了，所以只需要保证左边留k个，其他全移除即可 CF1972A Contest Proposal暴力按题意模拟即可，答案最大不会超过n CF1972B Coin Games思维 结论n个硬币排成环，可以对朝上的硬币进行操作，若硬币数小于2则直接删除这个硬币，否则删除这个硬币的同时翻转相邻的两个硬币，无法操作的人输发现对于所有的情况，朝上的硬币数要么一次减少3个，要么减少1个，要么增加1个，所以每次操作都会改变朝上硬币数的奇偶性，最后把数量变成0，即偶数的那个人赢，所以开始朝上硬币数为奇数时alice赢，否则bob","link":"/%E6%9D%82%E9%A1%B9/acm-log/"},{"title":"Makefile tutorial","text":"总结一下makefile tutorial里的教程，总不能一直拿bash做构建系统 Makefile rulesrules是makefile最基本的内容，当运行make时，其实就是在执行对应rule下面的命令 12345target: prerequirement command command ... command 一个rule由以上结构组成，target是rule的目标文件名称，prerequirement是rule的依赖文件，只有这些文件都存在才会执行对应的rule，command是make命令或者shell命令，前面有一个tab缩进 rule之间可以互相依赖 123456test: test.o gcc -o test test.otest.o: test.c gcc -c test.c test.o 比如上面这个，test的依赖是test.o，运行make时会先运行test.o，再执行test 变量makefile变量只能是纯文本，引号之类的也不会转义，有三种给变量赋值的方式 123a:= 1b?= 2c= 3 :=是立刻赋值，=是当使用到了才赋值（延迟赋值）,?=是未初始化则赋值使用+=实现变量字符串的拼接 变量通过$()来使用 123a:= test1 test2 test3test: echo $(a) targetrule可以设置多个prerequirement 12345678all: one two threeone:two:three: 这个经典的例子就是make all,等价于make one two three rule同时也可以设置多个target，等价于执行好多遍 1234567f1.o f2.o: echo $@# $@的意思是target名，这个等价于# f1.o:# echo f1.o# f2.o:# echo f2.o 预设变量下面是几个常用的预设变量 $@ target名 $? 所有时间戳比target新的prerequirement $^ 所有的prerequirement $&lt; 第一个prerequirement 正则匹配只有*和%两种匹配符，*正则匹配只建议由wildcard函数包裹使用 *的功能是匹配任意字符，比如$(wildcard *.c)就是目录下所有后缀为.c的文件 %的功能是匹配并替换，通常用在模式固定的rule或者字符串替换中 12%.o : %.c $(CC) -c $(CFLAGS) $&lt; -o $@ 这里就是匹配目录下所有.c文件的名称作为pattern然后生成对应名字的.o文件 123objects = foo.o bar.o all.o$(objects): %.o: %.c $(CC) -c $^ -o $@ 这个则是从objects中提取符合%.o的模式，然后替换到%.c中，等于是为每个.o寻找对应的.c文件并编译 c/cppmakefile会自动对目录下的与目标同名的c/cpp文件生成编译命令，不建议使用这个技巧 n.o会以n.c作为源被以下命令编译$(CC) -c $(CPPFLAGS) $(CFLAGS) $^ -o $@ 如果是n.cc或n.cpp则是如下$(CXX) -c $(CPPFLAGS) $(CXXFLAGS) $^ -o $@ n会以n.o默认以以下命令链接$(CC) $(LDFLAGS) $^ $(LOADLIBES) $(LDLIBS) -o $@ 命令在命令前加@可以静默执行，make -s可以让所有命令静默执行每行命令的shell环境是独立的，但是可以用;在一行连接多个命令，然后用\\ 连接多个行 1234567891011all: cd .. # The cd above does not affect this line, because each command is effectively run in a new shell echo `pwd` # This cd command affects the next because they are on the same line cd ..;echo `pwd` # Same as above cd ..; \\ echo `pwd` shell变量shell环境变量和makefile变量是两种不同的东西，要使用shell环境变量，则要在变量名前加$$且不用括号包裹（这里类似转义） 1234567make_var = I am a make variableall: # Same as running &quot;sh_var='I am a shell variable'; echo $sh_var&quot; in the shell sh_var='I am a shell variable'; echo $$sh_var # Same as running &quot;echo I am a make variable&quot; in the shell echo $(make_var) 递归调用make如果需要在子文件夹中递归调用make则使用$(MAKE)命令而不是shell命令，因为前者会帮助传递makefile变量 export由export命令设置成环境变量的makefile变量可以被所有的rule和子makefile访问 12345shell_env_var=Shell env var, created inside of Makeexport shell_env_varall: echo $(shell_env_var) echo $$shell_env_var 这里输出的两行都是一样的 override带override修饰的变量会忽略来自命令行的传参override option_one = did_overrideoption_one永远是did_override target特化的变量1234567all: one = coolall: echo one is defined: $(one)other: echo one is nothing: $(one) 变量可以为不同的target设置不同的值,这里make all时one的值为cool,否则为空这里的target也可以用正则 1234567%.c: one = coolblah.c: echo one is defined: $(one)other: echo one is nothing: $(one) 条件表达式12345678foo = okall:ifeq ($(foo), ok) echo &quot;foo equals ok&quot;else echo &quot;nope&quot;endif 函数函数通过这两种模式的任意一种调用${fn,arguments},$(fn,arguments)第一个参数的参数前不要带空格，否则空格会被识别成参数字符串的一部分 字符串替换$(patsubst pattern,replacement,text)patsubst函数从text中筛选符合pattern的空格分隔的字符串并替换成replacement，这里通常结合正则使用 12foo := a.o b.o l.a c.oone := $(patsubst %.o,%.c,$(foo)) 批量修改$(foreach var,list,text)foreach函数把list中按空格分隔的每个字符串修改成新的，var是遍历时的变量，在text中使用，text是目标字符串 1234567foo := who are you# For each &quot;word&quot; in foo, output that same word with an exclamation afterbar := $(foreach wrd,$(foo),$(wrd)!)all: # Output is &quot;who! are! you!&quot; @echo $(bar) 过滤$(filter pattern,objects)filter从objects中按空格为分隔符筛选出符合pattern的字符串filter-out则是筛掉符合的 vpathvpath &lt;pattern&gt; &lt;directories, space/colon separated&gt;vpath是为指定pattern的文件添加搜索路径，pattern可以是%正则vpath %.h ../headers ../other-directory比如这个就会在headers里搜索.h文件 .PHONY.PHONY是伪目标宏,听起来很难懂，其实就是带.PHONY修饰的rule不管target状态如何都会执行 1234.PHONY: cleanclean: rm -f some_file rm -f clean","link":"/development/Makefile_tutorial/"},{"title":"compose 组件速查","text":"kotlin compose 学习笔记 综述compose基本就是类似react中的component，结合jetpack compose编译器生成可以组成成界面的函数块 如何设置函数为compose1234@Composablefun Greeting(name: String) { Text(text = &quot;Hello $name!&quot;)} 通过添加注释(@Composable)告诉jet compose编译器讲这个函数编译为compose Modifier123456@Composablefun GreetingText(message: String, modifier: Modifier = Modifier) { Text( text = message )} Modifier是compose中用于设置字体颜色等属性的对象，可以类比为CSS，对于一个compose不管你用不用modifier最好都传一个进去，因为你不能保证子元素也用不到，而且保持modifier传参可以提供配置一致性 MainActivityMainActivity需要从ComponentActivity()这个父类继承，google给出的一个示例如下 1234567891011121314151617181920class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContent { HappyBirthdayTheme { // A surface container using the 'background' color from the theme Surface( modifier = Modifier.fillMaxSize(), color = MaterialTheme.colorScheme.background ) { GreetingText( message = &quot;Happy Birthday Sam!&quot;, from = &quot;From Emma&quot;, modifier = Modifier.padding(8.dp) ) } } } }} 重点是setContent，用来设置要生成的内容 TextText是最基础的compose函数，用于显示文本使用text参数传递文本，另外也支持fontSize,modifier之类的格式参数 Row横向排版，把元素排成一行，可以使用尾随lambda语法添加需要的compose函数(因为content是最后一个参数，由row中的内容组成的lambda) 1234Row { Text(&quot;First Column&quot;) Text(&quot;Second Column&quot;)} Column纵向排版，其他和Row同理如果要使用滚动列表可以用lazyColumn Box重叠布局，可以把元素堆叠在一起，默认越先声明的元素在图层中的位置越低，也可以通过modifier的zIndex属性手动指定元素的高度 12345678910111213Box(modifier) { // 图片作为背景，Text在图片上方 Image( painter = image, contentDescription = null ) GreetingText( message = message, from = from, modifier = Modifier .fillMaxSize() .padding(8.dp) ) } Image用来渲染图片，图片资源通过R.drawable.resouceID管理,通过painterResource函数获取 123Image( painter = painterResource(R.drawable.androidparty)) ButtonButton是compose中的按钮元素，主要要设置onClick参数，这个参数接受一个lambda作为按钮触发的回调函数Button内部还可以添加元素，和布局一样用尾随lambda添加元素，比如添加按钮提示词Text之类的 Switch开关元素，一般就两个属性，checked表示开关是否选中，onCheckedChange是点击开关触发的回调 State / rememberState用来设置compose中的状态，用State定义的变量在更新时会触发compose的重组事件（即更新状态），State有State/MutableState两种，分别对应不可修改和可修改Compose函数每次更新状态实际上是重新执行一遍这个函数，所以如果用普通的State类型初始化状态的话实际上每次更新状态都会把状态重置回初始值管理状态的通用方法是使用remember委托设置状态，remember可以理解为一个闭包，可以在每次重置compose时保存状态要使用remember只要导入以下库 123import androidx.compose.runtime.rememberimport androidx.compose.runtime.getValueimport androidx.compose.runtime.setValue 一个通常的可修改状态一般定义如下 1var amountInput by remember { mutableStateOf(&quot;&quot;) } 其实这就是React同一套，学过React DOM的话应该上手挺快的 Input","link":"/development/compose_beginer/"},{"title":"kotlin备忘录速记","text":"记录一些速查的kotlin高频函数和API，省的太久不写忘了 定义约定常量1val Name : Type = initVal 变量var Name : Type = initVal 函数123(override... 修饰符) fun Name (para:paraType = deafultVal) : return Type{ } 可为null123456789val Name : Type? = initVal/null// 如果显式设置了类型,只有类型名后加?才可设为nullName!!.member // !!后缀表示断言该量一定不为null // 条件表达式也可以智能推断是否为null //val Name : Type = null?:deafultVal// ?:是 Elvis运算符，当运算符左侧的值为null时返回运算符右侧设置的默认值 类1234567891011// 主构造函数，参数前加val/var则无需在类主体中再次定义该成员// open说明该类可被继承// 父类的构造函数的调用接在主构造函数后// 实现的接口接在父构造函数后，用逗号链接(open) class Name(val member:Type,...) : FatherClassConstructor(para),interface{ val member = initVal get() set() // get,set为内置关键字，可选，紧跟在对应成员后 constructor(para):this(para)//重载构造函数，如果需要给主构造函数补参数} 修饰符123456class ClassName(){ public val member1 // 默认修饰符，可以任意访问 private val member2 // 仅可在类内部访问 protected val member3 // 只能被子类访问 internal val member4 // 只能在同一文件中被访问} 定义委托123var Name by delegateObject// 把变量的getter和setter委托给自定义类(即重载变量的getter和setter)// 委托类需实现ReadWriteProperty&lt;Any?, Type&gt;或ReadOnlyProperty&lt;Any?&gt;接口 储存函数1234567fun myFunc(){ ...}fun main(){ val FunctionVal = ::myFunc // 将函数作为变量存储须在函数名前加::} lambda1234567891011121314val Name:(paraType) -&gt; returnType = { para -&gt; body// 后置lambda语法// myFunc(Int,Int,(Int,Int)-&gt;Int)// 当函数的最后一个参数是lambda时可以在调用函数时直接把lambda写在调用后面myFunc(1,2){ x,y -&gt; x+y}}val 函数数据类型约定1(paraType1,ParaType2...) -&gt; returnType 泛型(模板类)约定12345class tempClass&lt;T&gt;(val para:Type,val tempPara:T){}val Name = tempClass&lt;Int&gt;(para1,2) 枚举类约定1234567enum class Name{ enumName1,enumName2}val enumNum:Name = Name.enumName1 数据类约定1234data class Name(val value1:Type,val value2:Type...){}//专用于处理数据的类，没有任何执行操作的方法//编译器会自动实现equals()，hashCode()，toString()，componentN()：component1()、component2() ... ，copy()这些方法 单例对象约定123object Name{}和类相同，但是全局只存在一个实例，且无须自己创建，必须在定义时就初始化 定义拓展属性12345678val typeName.extendPropertyName : dataTypeget()//为拓展属性设置getterfun typeName.extendFunctionName(para...) : returnType{}//拓展属性只能读取不能写入 接口12345interface InterfaceName{ val member:Type fun function(para):return Type //接口只声明不实现，继承接口的类必须实现接口声明的所有内容(override)} 分支约定if-else123456if(condition){}else{} when123456when(para){ condition1 -&gt; {body1} condition2 -&gt; {body2} .....} 特殊约定分支，lambda返回值分支,lambda的最后一个表达式的值会作为整个结构的返回值 123456789x= if(true){ &quot;1&quot;}else{ &quot;0&quot;}// x=&quot;1&quot;x={2} // x=2 字符串中嵌入表达式1&quot;x= ${x.value}&quot; 使用${}向字符串嵌入表达式 帮手函数repeat(times: Int, action: (Int) -&gt; Unit)重复执行某一操作，传入一个lambda，有一个从0开始的迭代器参数 12345678repeat(5){ it -&gt; println(it)}// 0// 1// 2// 3// 4 let()1234567891011//before letprintln(Obj.member1)println(Obj.member2)println(Obj.member3)// after letObj.let{ println(it.member1) println(it.member2) println(it.member3)} let后接一个lambda函数，可以把let前的对象用it关键字简写lambda 最后一条语句的返回值会被作为let的返回值 apply()1234567891011Obj.apply{ this.member= .... this.initFunc()}// tips : 可以实现链式调用Obj.apply{ member1 = ...}.apply{ member2 = ...}..... 对目标对象做一系列操作，通过this访问目标对象，返回操作完的目标对象 forEach(action: (T) -&gt; Unit)forEach传入一个lambda，对目标集(List,set…)中的每一个元素执行该lambda 12345val test1=setOf(1,2,3,4,5) test1.forEach{ println(it) }// 1,2,3,4,5 map对一个集合使用map，会返回一个数量相同的新集合，集合中的每个元素是原集合对应元素经过map中传入的lambda函数映射后所产生的 1234567var aList=listOf(1,2,3,4,5,6,7,8)var aAnotherList=aList.map{ it*2}fun main() { println(aAnotherList) // [2, 4, 6, 8, 10, 12, 14, 16]} filter与map类似返回一个新集合，filter接受一个lambda，这个lambda以集合中的单个元素为参数，如果lambda返回值为true则在新集合中保留该元素，否则不保留 1234567var aList=listOf(1,2,3,4,5,6,7,8)var aAnotherList=aList.filter{ it%2==0}fun main() { println(aAnotherList) // [2, 4, 6, 8]} fold()累加器或叫求和函数，但并不局限于加法，这个函数的第一个参数是一个初始值，第二个参数是一个lambda表达式需要确保lambda表达式的返回值和初始值的类型相同，lambda表达式接受两个参数，第一个参数被称作累加器，每次执行lambda初始值会被传进累加器，第二个参数是集合中的一个元素，用户可以自定义集合中的元素和累加器进行什么计算，最后fold会用lambda的返回值更新初始值，实现求和 1234567891011var aList=listOf(1,2,3,4,5,6,7,8,9,10)var sum=aList.fold(0){ tot,cur-&gt; val tmp=cur*2 tot+tmp}fun main() { println(aList) // [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] println(sum) // 110} sortedBy()返回一个集合经过排序的结果，接受一个lambda作为参数，要求lambda的返回值是可排序的（字符串或数值），会把每个元素在lambda中计算出的返回值作为排序的依据 123456789var aList=listOf(1,2,3,4,5,6,7,8,9,10)var reversedList=aList.sortedBy{ num -&gt; -num}fun main() { println(aList) // [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] println(reversedList) // [10, 9, 8, 7, 6, 5, 4, 3, 2, 1]} 数据管理数组 array123val array = arrayOf&lt;Type&gt;(elem1,elem2,....) // 使用arrayOf初始化，单一类型，长度不可变println(array[0]) // 使用下标访问val arrry12 = array1+array2 //拼接两个数组 列表(可变长数组) list1234567891011121314val aList=listOf(1,2,true,&quot;123&quot;) // 使用listOf初始化，可以混合类型，不可修改元素，不可增减元素println(aList.size) // 查询长度println(aList[0]) // 下标访问println(aList.indexOf(&quot;123)) // 3 ,若未找到返回-1for (elem in aList) { // 使用 for 遍历}anotherList=mutableListOf(1,2,true,&quot;123&quot;) // 可修改的列表anotherList.add(&quot;4&quot;) // [1,2,true,&quot;123&quot;,&quot;4&quot;] //向末尾添加元素anotherList.add(2,&quot;4&quot;) // [1,2,&quot;4&quot;,true,&quot;123&quot;,&quot;4&quot;] // 向中间插入anotherList.removeAt(0) // [2,&quot;4&quot;,true,&quot;123&quot;,&quot;4&quot;] // 按下标删除anotherList.remove(&quot;123&quot;) // [2,&quot;4&quot;,true,&quot;4&quot;] // 按值删除anotherList.contains(2) //查询是否存在2 in anotherList // 前者的另一写法 集合 setSet / mutableSet 同样 不可修/可修 123val aSet=mutableSetOf(&quot;123&quot;,true,32)// 有add，remove，contain，size，没有下标操作// 基于每个类的hashCode()实现 映射 mapMap / mutableMap 同样 不可修/可修 1234567val aMap=mutableMapOf( &quot;cake&quot; to 10, &quot;cookie&quot; to 5, true to 22)println(aMap[&quot;cake&quot;]) // 10 通过key访问value，不存在的key会返回null// 有size属性 Referencehttps://developer.android.com/courses/android-basics-compose/course","link":"/development/kotlin_beginer/"},{"title":"ACTF2025 unstoppable","text":"题目本身的意图挺好的，但出题人写的慢的和龟一样的图灵机实现多少有点史了因为龟一样的爆破速度我的二血变三血了frida还是太超模了 主函数进来先看主函数，输入有2703个，而且似乎有意对输入的范围做了检测，使其限定在0~5004input先进入sub_555555559560这个函数，这个函数里面乱七八糟的一堆指针操作乱飞，下面那个重命名为get_arg2的也是一样，让人非常怀疑这个v26和v22是不是结构体(图片里是已经修复过结构体定义的，懒得重新从原附件开始写了)，所以动调输入一些数检查下每次输入后给v22指向的地址命名标记可以看到确实是结构体，而且我们的输入也被存在了每个结构体中，另一个明显的特征是结构体里有大量互相指的指针，算法学的好的已经知道这是什么了，但万一我没打过acm怎么办呢，这里可以画图把每个结构体和他指向的对象连起来这一眼二叉搜索树了，也就是我们的输入被扔进了一颗二叉搜索树里，然后v22,v26都是相关的树节点类型，可以怀疑是根节点之类的，在下面的while循环中也有使用，二叉搜索树的重要性质就是先序遍历就是有序数列，合理怀疑这是在对我们的输入进行排序，我们把输入的组数patch少一点，到while处的逻辑中验证猜想另外注意到上面的循环会对我们的输入去重，如果输入的数已经在树中出现过就会把输入置0再插入树中 第二处循环再get_Input处下断点，可以发现v18确实是按从小到大取出的，但这时发现程序会卡死，经过二分法下断点发现是sub_555555559890这个函数导致了卡死，但巧合的是输入1不会卡死，输入2会，因为输入是排序的，经过多次尝试发现1,3,5均不会卡死（试出来几个不会卡死的方便动调下面的函数），再来看这个函数的逻辑，他接受v17作为传参，而v17在前一个函数进行初始化，经检查v17是一个指针数组，上面那个函数是负责把chiperlist中的数据刷入v17中，发现在取偏移时是按30的倍数取的，检查发现chiperlist正好是5005*30组数据，和我们输入的限制对应再看这个a是怎么出来的，sub_55555555A5B0的第一个参数是一个静态未初始化的全局量，第二个参数是我们取出的输入，我们查交叉引用看这个全局量哪来的可以看到是一个质数表，而且长度正好也是5005，结合动调确认就是查表获得质数表对应下标的数，那也就是说a和b都是查表查出来的，我们的输入其实是2703个合法下标用于在两次查表中获取对应的结果，如果输入不对则会在获取b的时候卡死在下面那个qpow就很清晰了，点进去直接能看出来是快速幂算法（看不出来我也没办法，和源码长得几乎完全一样了），下面那个函数是调用mod API进行取模操作总的来说这块就是把输入从小到大取出，分别进行两次查表获取$a,b$,然后计算$a^b$并累乘到v25上 哈希循环结束后有一个flatten过的函数，用d810解开后直接把整个函数体扔给ai识别，识别为MurmurHash3_x64_128哈希算法，不过他具体怎么样我们不关心，只要知道他会把v25作为种子，把congratulations的哈希值存入hashdest这个buffer即可，再看下面的输出格式，也就是flag主体其实就是这个hash 如何获取种子种子是累乘得到的，a就是查质数，难点在于获取b，可以去赌他获取b的算法在每次执行都是独立的，可以尝试输入(1,3,5),(3,5),(1,5),(1,3)做尝试，发现确实是独立的，那么考虑用frida主动调用去爆破合法的2703组回显，然后再主动调用他实现的qpow和mod函数结合素数表算出种子，最后动调把种子patch进hash函数获取flag 爆破脚本123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657from frida import *import sysimport threadingimport timedef kill(pid): device.kill(pid)device = get_local_device()res = []for i in range(2501, 5005): try: pid = device.spawn([&quot;./unstoppable&quot;]) session = device.attach(pid) except ProcessNotFoundError: print(f&quot;[!] {i:04x} Process not found, skip&quot;) continue js_code = f&quot;&quot;&quot; var baseOffset = 0x555555554000; var initopPtr = Module.getBaseAddress(&quot;unstoppable&quot;).sub(baseOffset).add(0x5555555596A0); var input = {i}; var initop = new NativeFunction(initopPtr, 'int64', ['pointer', 'pointer']); var opBuf = Memory.alloc(0x1000); var oplist = Module.getBaseAddress(&quot;unstoppable&quot;).sub(baseOffset).add(0x55555556D110); initop(opBuf, oplist.add(30 * input)); var vmPtr = Module.getBaseAddress(&quot;unstoppable&quot;).add(0x5890); var vm = new NativeFunction(vmPtr, 'int64', ['pointer']); var result = vm(opBuf); send(result); &quot;&quot;&quot; script = session.create_script(js_code) script.on('message', lambda message, data: res.append((message['payload'], i))) timer = threading.Timer(10, kill, args=[pid]) try: timer.start() device.resume(pid) script.load() time.sleep(10.1) except TransportError: print(f&quot;[!] {i:04x} transport closed, killed or hung&quot;) continue finally: timer.cancel() try: session.detach() except: passprint(f&quot;Total results: {len(res)}&quot;)print(res) 要注意的是使用frida爆破每次要重新起新进程，因为如果输入错了程序就会卡住，而主动调用是阻塞式的，然后每次起进程设置一个时限来分辨是正确输入还是卡死了，还要主动杀掉拉起的进程（不然跑5005轮马上cpu就爆了，frida不会主动杀掉自己拉起来的进程），至于这里为什么一次调用设10s时限就要问出题人的图灵机怎么写的这么卡了，可以把5005切成多片跑，以及做好要跑大半天的准备 调用qpow执行累乘为了防止出题人实现的mod抄错，所以干脆也用frida 12345678910111213141516171819202122232425262728293031323334setImmediate(function () { var baseOffset = 0x555555554000; var ModPtr = Module.getBaseAddress(&quot;unstoppable&quot;) .sub(baseOffset) .add(0x555555559160); var QpowPtr = Module.getBaseAddress(&quot;unstoppable&quot;) .sub(baseOffset) .add(0x5555555591A0); console.log(&quot;ModPtr: &quot; + ModPtr); console.log(&quot;QpowPtr: &quot; + QpowPtr); var qpow = new NativeFunction(QpowPtr, 'uint64', ['pointer', 'uint64', 'uint64']); var mod = new NativeFunction(ModPtr, 'uint64', ['pointer', 'uint64', 'uint64']); var seed = uint64(1); var junk = Memory.alloc(0x10); for (var i = 0; i &lt; blist.length; i++) { var j = blist[i][1]; var a = uint64(primelist[j]); var b = uint64(blist[i][0]); try { var tmp = qpow(junk, a, b); seed = mod(junk, seed, tmp); console.log(&quot;seed[&quot; + i + &quot;] = &quot; + seed); } catch (e) { console.error(&quot;error at i=&quot; + i, e); break; } } console.log(&quot;seed = &quot; + seed); send(seed);}); 脚本里的blist就是b的取值，是[[value,i]….]的形式,有两千多条就不放出来了最后跑完拿到种子 获取flag然后断点打在hash进入前，把v25修掉就行，记得把前面的输入循环整个去掉，不然又在while里卡死了flag直接就输出来了","link":"/ctf/WP/ACTF2025%20unstoppable/"},{"title":"selenium爬虫入门","text":"记录一下写的一个简单爬虫 简介selenium是基于浏览器DevTool模拟用户态行为的爬虫框架，与传统爬虫相比selenium最大的优点就是可以通过模拟行为绕过大部分的反爬，同时因为其本身基于浏览器，在对抗加密方面有天然的优势 常用APIwebDriver.Chrome.Options() : Option返回一个 option 对象，用于在之后为浏览器提供选项参数，最常见的用法如下 12options = webdriver.ChromeOptions()options.add_argument(&quot;disable-blink-features=AutomationControlled&quot;) 这段代码为option添加了一个参数将浏览器的 webdriver 属性置为false，该属性常用于检测浏览器是否处于调试模式，常见的反爬会检测该属性，该属性为true则会触发反爬此外还可以添加包括但不限于下列的属性，但用处都不大 123--disable-gpu # 禁用gpu加速--headless # 将浏览器设置为无头浏览器--windows-size=1920,1080 #设置浏览器窗口大小 webdriver.Chrome(options : Option ) : WebDriver创建一个浏览器对象，所有与浏览器的交互都会通过这个对象进行 1driver = webdriver.Chrome(options=options) driver.get(url : str ) : void打开一个页面 driver.find_element(by: str , value : str ) : WebElement在webdriver目前聚焦的页面中寻找对应html元素，并返回一个可以对找到的元素进行交互的对象， by 是 selenium.webdriver.common.by 中的枚举类， value 是搜索对应的值或表达式，这里只介绍 By.CSS_SELECTOR 和 By.LINK_TEXT，个人认为算是最通用的方法。这个方法只返回找到的第一个元素，且找不到则抛出错误，另一个类似的方法是 driver.find_elements 返回所有找到的元素，如果找不到就返回空列表 By.CSS_SELECTOR 利用CSS选择器查找元素，value 应为一个CSS选择器表达式下面是一些示例 12345678910111213value = &quot;div&quot; # 单独的名字表示筛选特定tag的元素value = &quot;.targetClass&quot; # class名前带.表示筛选带特定类的元素value = &quot;#ID&quot; # ID前带#表示筛选含特定id的元素value = &quot;[attribute]&quot; # 筛选带具备特定属性的元素value = '[attribute=&quot;value&quot;]' # 筛选带特定属性且属性值为value的元素，其中&quot;&quot;不可省略和替换value = &quot;div.targetClass#ID&quot; # 选择含多个条件的元素则将所有条件不加空格地组合在一起value = &quot;div#fatherDiv div#sonDiv&quot; # 如果要选择某个元素的后代元素则将两个元素的筛选条件以空格隔开value = &quot;div#faterDiv &gt; div#directSonDiv&quot; # 如果要选择直属于某个元素的子元素则在两个元素的筛选条件之间额外加入 &gt;value = &quot;:not()&quot; # 选择不符合特定条件的元素，()中可以嵌套另一个CSS选择器表达式 # 比如 &quot;div:not(.disabled)&quot; ,选择不为disable类的div元素 By.LINK_TEXT 筛选文本为 value 的&lt;a&gt;元素即超链接元素，执行严格匹配，另一个类似的方法是 By.PARTIAL_LINK_TEXT，只需提供的 value 是目标的子串就行，此方法用于快捷定位特定超链接对应的元素，方便爬虫在页面间进行跳转 1Page = driver.find_element(by=By.LINK_TEXT, value=&quot;下一页&quot;) # 这样我们就定位到了一个翻页按钮，可以用click之类的方法让我们的爬虫翻页 ActionChains(driver : WebDriver ) : ActionChains这是selenium提供的动作链类，用于模拟用户的操作输入 1234567actions = ActionChains(driver) # 指定所属的webdriver，还可以指定duration属性来控制每次操作的时间，用来绕过针对仿真行为的反爬actions.key_down(Keys.CONTROL).click( Page).key_up(Keys.CONTROL).perform() # 这个操作就模拟了ctrl+左键，即在新页面打开对应链接 # 使用连续调用来设计动作链，最后调用perform()执行 # click之类的要指定具体点击的webElement，否则点击鼠标指针所在位置 # 按键类的动作可以用selenium.webdriver.common.keys中的Keys枚举类来模拟按下ctrl之类的功能键，其他按键直接输入对应字符即可 driver.switch_to.window(window_name : str ) : void将浏览器的焦点切换至另一个页面，其中 window_name 可以通过 driver.window_handles 获取，这是webdriver类的一个列表成员，储存了当前浏览器所有窗口的 window_name 12driver.switch_to.window(driver.window_handles[-1]) # 切换至最右边的窗口，事实上这个列表里句柄的排列顺序是按窗口打开顺序排列的 driver.close() : void当一个页面的数据爬完了可能要关闭该页面，用close方法就能把当前页面关掉，但是注意driver并 不会自动切换聚焦到新窗口 ，所以close后要调用switch_to.window把焦点转移到新窗口 driver.quit() : void直接关闭浏览器 项目实战项目地址 =&gt; 基于selenium框架爬取avd.aliyun.com上的漏洞报告 阿里云的漏洞网站用了很恶心的加密算法，把本机的时间戳套了一堆加密做成token放进payload里做验证，如果验证不通过就无法进入漏洞库和漏洞报告，我们直接上selenium，只要我们全程模拟用户态行为就不用管加密，这点和逆向工程中的动态调试非常像，本质上是利用了应用自加密/自解密的性质 下面直接上代码 12345678#utility.pydef init_driver(url: str): options = webdriver.ChromeOptions() options.add_argument(&quot;disable-blink-features=AutomationControlled&quot;) driver = webdriver.Chrome(options=options) driver.get(url) return driver 他的加密算法会在加载时就读取 webdriver 标记的值，并且这个参数会被用于加密过程，如果是undefined或者true加密跑出来就是错的，而且非常恶心的是他并不直接从 navigator.webdriver 实时读取，而是加载时检测到 webdriver 不为false就让加密胡乱输出，所以我们加一个参数在网页加载前就把 webdriver 标记设置成false 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#Crawler.pydef runCrawler(catalog: str, number: int = 0, debug: bool = 0, sleepSecond: float = 1): ''' sleepSecond为每跳转一个页面的等待时长，过短可能会触发限流或反爬\\n 如果cve的命名不符合windows文件命名规范则会转换为url命名输出\\n catalog为要爬取的漏洞库的按钮文本{&quot;CVE 漏洞库&quot;,&quot;非CVE漏洞库&quot;,&quot;高危漏洞&quot;}\\n number为爬取的记录数量，若不指定则在调用函数时提示输入 ''' driver = init_driver(&quot;https://avd.aliyun.com/&quot;) Page = driver.find_element(by=By.LINK_TEXT, value=catalog) if debug: print(&quot;in &quot;+driver.title+&quot; at &quot;+driver.current_url) # input(&quot;continue&quot;) actions = ActionChains(driver) actions.key_down(Keys.CONTROL).click( Page).key_up(Keys.CONTROL).perform() # 进入漏洞库列表 sleep(sleepSecond*1.5) # 等待加载 if debug: print(&quot;sleep finished&quot;) driver.switch_to.window(driver.window_handles[-1]) # 切换至漏洞库窗口 links = driver.find_elements(By.TAG_NAME, &quot;a&quot;) # print(len(links)) if debug: # print(driver.window_handles) print(&quot;in &quot;+driver.title+&quot; at &quot;+driver.current_url) # input(&quot;continue&quot;) total = driver.find_element( by=By.CSS_SELECTOR, value=&quot;div.py-3.bg-light &gt; div.container.vuln-list-container &gt; div.py-3 &gt; div.d-flex.justify-content-between.align-items-center &gt; span.text-muted&quot;).text if debug: print(total[total.find(&quot;总计 &quot;)+3: total.find(&quot; 条记录&quot;)]) total = int(total[total.find(&quot;总计 &quot;)+3: total.find(&quot; 条记录&quot;)]) print(&quot;正在爬取 {}&quot;.format(catalog)) toDo = number if toDo == 0: toDo = int(input(&quot;输入要爬取的记录条数，范围为 &lt;={}\\n&quot;.format(total))) hasNextPage = 1 cnt = 0 while hasNextPage and cnt &lt; toDo: if debug: print(&quot;in&quot;+driver.current_url) for link in links: # 遍历所有超链接 if &quot;detail&quot; in link.get_attribute(&quot;href&quot;): link.click() # 进入cve sleep(sleepSecond) driver.switch_to.window( driver.window_handles[-1]) # 切换至新窗口 button = driver.find_elements( by=By.CSS_SELECTOR, value=&quot;.btn.btn-link.text-muted&quot;) if len(button): button[0].click() genRawDoc(driver, debug) cnt += 1 print(&quot;进度 {} / {}&quot;.format(cnt, toDo)) if debug: print(&quot;in &quot;+driver.title+&quot; at &quot;+driver.current_url) input(&quot;continue&quot;) driver.close() # input(&quot;closed&quot;) driver.switch_to.window(driver.window_handles[-1]) if debug: print(&quot;in &quot;+driver.title+&quot; at &quot;+driver.current_url) # input(&quot;continue&quot;) if cnt == toDo: break nextPageButton = driver.find_elements( by=By.CSS_SELECTOR, value=&quot;.px-3.btn.btn-sm.btn-outline-secondary.btn-bd-primary:not(.disabled)&quot;) if debug: print(len(nextPageButton)) hasNextPage = 0 for button in nextPageButton: if &quot;下一页&quot; in button.text: actions.key_down(Keys.CONTROL).click( button).key_up(Keys.CONTROL).perform() # driver.close() sleep(sleepSecond) driver.close() driver.switch_to.window(driver.window_handles[-1]) hasNextPage = 1 break driver.quit() 这段非常长，因为爬虫定位元素基本靠手工定位，有大量重复代码，我们看关键的部分 12345driver = init_driver(&quot;https://avd.aliyun.com/&quot;)Page = driver.find_element(by=By.LINK_TEXT, value=catalog)actions = ActionChains(driver)actions.key_down(Keys.CONTROL).click(Page).key_up(Keys.CONTROL).perform() # 进入漏洞库列表sleep(sleepSecond*1.5) # 等待加载 这里我们打开网站，然后网站首页有三个链接分别跳进不同分类的漏洞库，我们直接用文本定位然后在新页面打开，并且等待加载，这里不直接点击在原地跳转的原因是不知道为什么原地跳转会导致加密算法输出不正确，然后等待加载也很重要，如果不等页面完全加载完就跳转也会让加密算法输出不正确，尚不清楚原因 12driver.switch_to.window(driver.window_handles[-1]) # 切换至漏洞库窗links = driver.find_elements(By.TAG_NAME, &quot;a&quot;) 这段就是把这个页面里所有的超链接元素都抓下来 123total = driver.find_element( by=By.CSS_SELECTOR, value=&quot;div.py-3.bg-light &gt; div.container.vuln-list-container &gt; div.py-3 &gt; div.d-flex.justify-content-between.align-items-center &gt; span.text-muted&quot;).texttotal = int(total[total.find(&quot;总计 &quot;)+3: total.find(&quot; 条记录&quot;)]) 这段是找下总共有多少条记录，不是很重要 1234567891011121314151617while hasNextPage and cnt &lt; toDo: #.... nextPageButton = driver.find_elements( by=By.CSS_SELECTOR, value=&quot;.px-3.btn.btn-sm.btn-outline-secondary.btn-bd-primary:not(.disabled)&quot;) if debug: print(len(nextPageButton)) hasNextPage = 0 for button in nextPageButton: if &quot;下一页&quot; in button.text: actions.key_down(Keys.CONTROL).click( button).key_up(Keys.CONTROL).perform() # driver.close() sleep(sleepSecond) driver.close() #关闭当前页 driver.switch_to.window(driver.window_handles[-1]) #前往下一页 hasNextPage = 1 break 因为记录有很多页，我们要一页一页爬，先找到翻页按钮，然后发现能按和不能按的按钮有一个.disable类的区别，我们就一直翻直到”下一页”变成disable为止然后每次点开一个新的就把老的关了 123456789101112131415161718192021222324for link in links: # 遍历所有超链接 if &quot;detail&quot; in link.get_attribute(&quot;href&quot;): link.click() # 进入cve sleep(sleepSecond) driver.switch_to.window( driver.window_handles[-1]) # 切换至新窗口 button = driver.find_elements( by=By.CSS_SELECTOR, value=&quot;.btn.btn-link.text-muted&quot;) if len(button): button[0].click() genRawDoc(driver, debug) cnt += 1 print(&quot;进度 {} / {}&quot;.format(cnt, toDo)) if debug: print(&quot;in &quot;+driver.title+&quot; at &quot;+driver.current_url) input(&quot;continue&quot;) driver.close() # input(&quot;closed&quot;) driver.switch_to.window(driver.window_handles[-1]) if debug: print(&quot;in &quot;+driver.title+&quot; at &quot;+driver.current_url) # input(&quot;continue&quot;) if cnt == toDo: break 页面里有一堆超链接，我们肯定不能每个都跳进去，发现漏洞详情的超链接里有detail关键字，我们就只找含这个关键字的跳，也是点开，转移焦点，爬数据，关闭，把焦点切回来，同样注意每次等待一会，可以防止访问量过大导致限流或者直接被封ip然后跳进去后发现参考链接如果数量过多会只显示部分，要先点一下 .btn.btn-link.text-muted 的按钮把所有东西都展开genRawDoc里的内容就没什么营养了，目前已经进入具体报告界面，直接定位对应内容，保存下来写入文件就行","link":"/development/selenium0x1/"},{"title":"腾讯游戏安全大赛2023安卓初赛","text":"不算非常难的题，但是对于没有app逆向经验的新人来说是挺好的上手题目 dump libli2cpp.so进来先随便看看，unity题先看看c#的东西，il2cpp被加密过，ida里解析不出来，考虑运行时dump直接用frida读，注意到对frida默认的端口做了检测，所以要转发到别的端口上 1234567891011121314151617181920212223242526272829/*如何使用设置一个倒计时后dump指定的so文件，timeout单位是ms，默认为3000ms*/function dump(soName: string, timeout: number = 3000) { setTimeout(() =&gt; { let libSo = Process.getModuleByName(soName); let base = libSo.base; let size = libSo.size; let sectionRanges = libSo.enumerateRanges(&quot;&quot;); for (let i = 0; i &lt; sectionRanges.length; i++) { console.log(sectionRanges[i].base.sub(base), sectionRanges[i].size, sectionRanges[i].base.add(sectionRanges[i].size).sub(base), sectionRanges[i].protection); Memory.protect(sectionRanges[i].base, sectionRanges[i].size, 'rwx'); let buffer = sectionRanges[i].base.readByteArray(sectionRanges[i].size); console.log(`write ${sectionRanges[i].size} bytes sections`); send([&quot;dumpso&quot;, soName], buffer); if (i + 1 &lt; sectionRanges.length &amp;&amp; sectionRanges[i].base.add(sectionRanges[i].size).compare(sectionRanges[i + 1].base) !== 0) { let gap = Memory.alloc(sectionRanges[i + 1].base.sub(sectionRanges[i].base.add(sectionRanges[i].size)).toUInt32()); let buffer = gap.readByteArray(sectionRanges[i + 1].base.sub(sectionRanges[i].base.add(sectionRanges[i].size)).toUInt32()); console.log(`write ${sectionRanges[i + 1].base.sub(sectionRanges[i].base.add(sectionRanges[i].size)).toUInt32()} bytes gap`); send([&quot;dumpso&quot;, soName], buffer); } } console.log(&quot;base: &quot;, base); console.log(&quot;size: &quot;, size); console.log(&quot;base + size: &quot;, base.add(size)); }, timeout);}dump(&quot;libil2cpp.so&quot;); 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354import fridaimport sysimport timedef handleResigerNatives(message): print(&quot;----------------------------------------&quot;) print(&quot;Native Method in class: {}&quot;.format(message['payload'][1])) print(&quot;Native Method name: {}&quot;.format(message['payload'][2])) print(&quot;Native Method signature: {}&quot;.format(message['payload'][3])) print(&quot;Native Method address: {}&quot;.format(message['payload'][4])) print(&quot;Which file register It: {}&quot;.format(message['payload'][5]))def handleDumpSo(message, data): with open(&quot;dump_&quot;+message['payload'][1], &quot;ab&quot;) as f: f.write(data)def onMessage(message, data): if message['type'] == 'send': if message['payload'][0] == &quot;registerNatives&quot;: handleResigerNatives(message) elif message['payload'][0] == &quot;dumpso&quot;: handleDumpSo(message, data) else: print(&quot;[!!] Message from target: &quot;, message['payload']) else: print(&quot;Not a send type Message&quot;, message['stack'])with open('dumpso.js', &quot;r&quot;, encoding=&quot;utf-8&quot;) as f: jscode = f.read()targetProcessPackName = &quot;com.com.sec2023.rocketmouse.mouse&quot;device = frida.get_device_manager().add_remote_device(&quot;127.0.0.1:12345&quot;)try: pid = device.spawn(targetProcessPackName) session = device.attach(pid) print(pid)except frida.ProcessNotFoundError: print(&quot;No such process&quot;) sys.exit(0)# device.resume(pid)# input(&quot;continue&quot;)script = session.create_script(jscode)script.on('message', onMessage)script.load()device.resume(pid)sys.stdin.read() 这样so基本都出来了，再结合ll2cppDumper和apk里找到的global-metadata修复一下c#符号信息但是因为是dump的，所以偏移和节符号之类的多少有些损坏，这样直接扔进ida里是无法识别的，所以要修复elf，如果手动修的话就是把so扔进010里先跑一遍elf模板识别关键字段，然后把progame_table段里的物理地址值改成虚拟地址对应的值，把文件中的段大小改成内存中的段大小，具体原理就是因为dump下来的elf中数据的偏移都是还在内存中的偏移，同时因为内存中的elf会把一些像stack_segment之类只有在运行时才会占据实际空间的段拓展，所以有些段的位置会被挤歪，也就是物理地址和虚拟地址不符，而ida只识别物理地址，所以要把物理地址的值改成虚拟地址对应的值，还有把在文件中的大小改为在内存中的大小，这样才能定位真实的偏移节表的部分在dump时都会损坏，要去未解密的so里把节表的部分复制过来同理对节表（section_table）里的元素也做修正偏移的操作注意到节表里有个储存各字段名称的部分由elf头里的string_table_index定位这个值是节表的索引，对应的节表元素里储存了所有表头的名称，这个部分在dump的时候是会丢失的，手动修复就要去原来apk里的so中把对应的部分复制出来（因为表头名称是不加密的）这些都修完后按理就修好了，修的过程中发现有些elf的部分没识别出来是正常情况，因为没修好010模板无法识别，边修边f5就会逐渐把符号表，节表之类的都显示出来 但是主播主播，你的操作太麻烦了，有没有一把梭的方法有的有的，直接上soFixer,修之前记得先用ll2cpp dumper提取符号，然后在用soFixer修，不然修完后的ll2cpp dumper就不识别符号了，用soFixer只要输入dump时的基址就能一键修正偏移了 修完后就是用ll2cppdumper自带的ida脚本把符号信息导入ida，在ida的script file里选择ida_with_struct_py3.py这个脚本，然后按照提示依次选择script.json和il2cpp.h两个文件导入脚本，就可以在ida里恢复符号记得ida里也要设定基址，在edit-&gt;segment-&gt;rebase一栏中填入dump时的基址这样跑完后该有的符号就都有了，因为题目要求做注册机，token是用小键盘输入的，所以先搜下keyboard试试看能不能找到相关函数 分析注册机输入可以看到还是找到了，拿frida hook一下看看调用 这里虽然做的时候软件一直崩溃，但还是拿到了hook数据这里是按了一下1按了一下enter，可以看到最后都调用了SmallKeyboard__iI1Ii,看看这个函数什么情况可以看到这里针对keyType的三种不同情况做不同处理，其中type=2的情况又调用了别的函数，所以重点hook SmallKeyboard__iI1Ii_469567457968看看这个v23是什么，怀疑是我们的输入hook结果如下，这个0x7b就是我们输入的123，点进这个函数看，发现最终调用了一个导入函数，如果跳过去是jumpout就手动c一下把数据转成代码，可能是ida误判没有把代码反编译出来那么这里很有可能是加密了，我们得跳到sec2023这个so的导出表里找这个函数，这里指的是导出表的第十个元素上文的hook脚本如下 12345678910111213141516171819202122232425262728293031323334353637383940setTimeout(() =&gt; { let lib = Process.getModuleByName(&quot;libil2cpp.so&quot;); console.log(lib.base); let offset = 0x6EF9C28000; let addr = [0x0000006EFA08E300, 0x0000006EFA08E18C, 0x0000006EFA08D880, 0x0000006EFA08DAB0, 0x0000006EFA08DFDC, 0x0000006EFA08DE90, 0x0000006EFA08E184, 0x0000006EFA08E2F8, 0x0000006EFA08E3B0, 0x0000006EFA08E3A8 ] var name = [&quot;SmallKeyboard___ctor(SmallKeyboard_o *this, const MethodInfo *method)&quot;, &quot;SmallKeyboard__Start(SmallKeyboard_o *this, const MethodInfo *method)&quot;, &quot;void SmallKeyboard__iI1Ii(SmallKeyboard_o *this, SmallKeyboard_iII1i_o *info, const MethodInfo *method)&quot;, &quot;SmallKeyboard__iI1Ii_469567457968(SmallKeyboard_o *this, uint64_t i1I, const MethodInfo *method)&quot;, &quot;void SmallKeyboard__iI1Ii_476641288156(SmallKeyboard_o *this, UnityEngine_GameObject_o *go, const MethodInfo *method&quot;, &quot;SmallKeyboard__oO0oOo0(SmallKeyboard_o *this, const MethodInfo *method)&quot;, &quot;SmallKeyboard__oO0oOoO(SmallKeyboard_o *this, const MethodInfo *method)&quot;, &quot;SmallKeyboard___c__DisplayClass14_0___ctor(SmallKeyboard___c__DisplayClass14_0_o *this, const MethodInfo *method)&quot;, &quot;SmallKeyboard___c__DisplayClass14_0___Start_b__0(SmallKeyboard___c__DisplayClass14_0_o *this, const MethodInfo *method)&quot;, &quot;SmallKeyboard_iII1i___ctor(SmallKeyboard_iII1i_o *this, const MethodInfo *method)&quot; ] for (let i = 0; i &lt; addr.length; i++) { console.log(&quot;hook &quot; + name[i]); Interceptor.attach(lib.base.add(addr[i]).sub(offset), { onEnter: function () { console.log(&quot;called &quot; + name[i]); } }) } Interceptor.attach(lib.base.add(0x0000006EFA4839C4).sub(offset), { onLeave(retval) { console.log(retval); }, })}, 3000); 这里有间接跳转，可以把so的data段改成只读，这样bn会自动计算部分跳转地址，当然还是不怎么可看，最好结合trace分析控制流 CRC校验绕过我们hook sub_3b8cc这个函数时会发现app会跳出，可能是crc校验检测到了inline hook，去hook open，openat等都没有发现相关调用，感觉可能是使用svc来避免相关函数被frida hook，使用stackplz对内核跟踪后发现调用了openat这个时候根据调用栈去找检测的位置，基本上每个调用下面都紧跟一个cmp，我们hook 参数看看是否像是在判断检测的最终结果，不断排查可以往前跳到sub_353e0这个函数可以看到这个sleep其实就已经很说明问题了，因为app不是马上跳出，而是过一会再跳出的这个时候我们把0x3649c这个位置的w0给hook成0，app就不跳出了，说明找对位置了，继续分析加密 加密1第一处加密的参数是输入的高32位，点进去看看像是对每个字节分别做了两次计算可以hook下验证下想法 就是些计算，hook下看下具体计算流程，然后就可以写解密了 1234567891011# enc = [0x17, 0x6d, 0x22, 0x89]enc = [0x89, 0x22, 0x6d, 0x17]enc[0] = enc[0]+0x1cenc[1] = (enc[1]+8) ^ 0xd3 ^ 1enc[2] = ((enc[2]+16)+0x5e) ^ 2enc[3] = (enc[3]+24) ^ 0x86 ^ 3for i in range(0, 4): print(hex(enc[i] &amp; 0xFF)) 然后是一个byteswap宏，就是把加密完的部分的字节序反过来 加密2在下面是sub_3a924是调用native调用dex加密，hook GetStaticMethodID这个函数去找加密函数在dex中的位置 1234567891011121314151617181920212223242526272829303132333435/*如何使用这个gadget通过hook libart.so中的getStaticMethodID函数来获取so层获取的dex函数信息一般直接运行即可，注意本gadget依赖libart.so的加载配套python解析message的函数def handleGetStaticMethodID(message): print(&quot;----------------------------------------&quot;) print(&quot;JAVA method name: {}&quot;.format(message['payload'][1])) print(&quot;JAVA method signature: {}&quot;.format(message['payload'][2])) print(&quot;Which file get It: {}&quot;.format(message['payload'][3]))*/function hookJNIgetStaticMethodID() { console.log(&quot;hook JNIgetStaticMethodID&quot;); let symbols = Module.load(&quot;libart.so&quot;).enumerateSymbols(); for (let i = 0; i &lt; symbols.length; i++) { let symbol = symbols[i]; if (symbol.name.indexOf(&quot;art&quot;) &gt;= 0 &amp;&amp; symbol.name.indexOf(&quot;JNI&quot;) &gt;= 0 &amp;&amp; symbol.name.indexOf(&quot;GetStaticMethodID&quot;) &gt;= 0 &amp;&amp; symbol.name.indexOf(&quot;CheckJNI&quot;) &lt; 0) { console.log(symbol.name); Interceptor.attach(symbol.address, { onEnter: function (args) { var Name = args[2].readUtf8String(); var sig = args[3].readUtf8String(); let whoCallIt = DebugSymbol.fromAddress(this.returnAddress).toString(); send([&quot;getStaticMethodID&quot;, Name, sig, whoCallIt]); } }) } }}setTimeout(hookJNIgetStaticMethodID, 3000); 用frida-dexdump把dex dump下来，然后可以都扔进jeb里了，加密部分加了平坦化混淆，jeb效果好一点就是循环右移后进行异或和加法，可以写解密了 12345678910111213key = [50, -51, -1, -104, 25, -78, 0x7C, -102]b1 = [0xf8, 0xd0, 0x17, 0x96]b1 = list(reversed(b1))for i in range(0, 4): b1[i] = (b1[i]-i) &amp; 0xFF b1[i] = (b1[i] ^ key[i]) &amp; 0xFFv = (b1[0] &lt;&lt; 24) | (b1[1] &lt;&lt; 16) | (b1[2] &lt;&lt; 8) | b1[3]v = v &amp; 0xFFFFFFFFv1 = ((v &lt;&lt; 7) | (v &gt;&gt; 25)) &amp; 0xFFFFFFFFprint(hex(v1))# ret: 6d98b6d2# [dexcall] f8d01796 低32位注意虽然反编译没有直接显示低32位被扔进了enc1里，但其实低32位也经历了一次enc1，应该是类型识别导致的问题然后是把低32位字节序反过来，再一样扔进那个dexcall里最后是把高32位放在低位，低32位放在高位拼起来返回 跨文件跳转看到这里还根据一个全局导出变量做了跳转，但是静态不好算这个变量，hook一下看看位置 12345Interceptor.attach(lib.base.add(0x311a0), { onEnter: function () { console.log(DebugSymbol.fromAddress(this.context.x2)); }}) 跳回libil2cpp了，和基址算一下偏移再去找跳到哪了再跳过去发现其实就是之前跳到sec2023.so的加密的下面也就是说加密完的64位数被弄到这个函数里处理了 il2cpp中的加密前面搞了一大坨初始化，传入输入也被分为高低各两份放进了v21这个结构体里，跟踪这个结构体,最后是走到了一个vm加密里，至于为什么断定这是vm因为里面进去就是一个大while(1),而且看着也不像其他加密vm里面这一大坨重点关注那个get_Item的库函数,hook他的第二个参数看看下标都是什么看到种类不多，接下来该去找handle的实现了 123456Interceptor.attach(ll2.base.add(0x46AE1C), { onEnter: function () { console.log(&quot;[handle]&quot;, ptr(this.context.x9).sub(ll2.base).add(0x6D54207000)) }}) 这里简单trace下拿下handle的函数地址 vm分析handle里面有些和数值计算相关的地方用了mba算式混淆，ida9.0内置了解mba混淆的插件拿完handle后一个个写trace，把指令和参数拿下来 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111function main() { var ll2 = Process.getModuleByName(&quot;libil2cpp.so&quot;); var idabase = 0x6D54207000; var basePtr = ll2.base.sub(idabase); Interceptor.attach(basePtr.add(0x6D5466CBD0), { onEnter() { console.log(&quot;low32 of input: &quot;, this.context.x0); } }) Interceptor.attach(basePtr.add(0x6D5466CBF4), { onEnter() { console.log(&quot;hig32 of input: &quot;, this.context.x0); } }) Interceptor.attach(basePtr.add(0x6D5466CC3C), { onEnter() { console.log(&quot;ret: &quot;, this.context.x21, this.context.x22); } }) Interceptor.attach(basePtr.add(0x6D546725CC), { // pushU16toStack onEnter() { console.log(`stack[${this.context.x10}] = ${this.context.x8}`); } }) var heapIdx = 0, stackIdx = 0; // popStacktoHeap Interceptor.attach(basePtr.add(0x6D54672548), { onEnter() { stackIdx = this.context.x9; heapIdx = this.context.x8; let value = ptr(this.context.x10).add(this.context.x9 * 4 + 0x20).readU32(); console.log(`heap[${heapIdx}] = stack[${stackIdx}] // stack[${stackIdx}] = ${value}`) } }) // pushHeaptoStack Interceptor.attach(basePtr.add(0x6D54672438), { onEnter() { heapIdx = this.context.x8; } }) Interceptor.attach(basePtr.add(0x6D54672460), { onEnter() { stackIdx = this.context.x10; console.log(`stack[${stackIdx}] = heap[${heapIdx}] // heap[${heapIdx}] = ${this.context.x8}`) } }) // shiftR Interceptor.attach(basePtr.add(0x6D54672088), { onEnter() { console.log(`push ${this.context.x10} &gt;&gt; ${this.context.x11} to stack // ${this.context.x10 &gt;&gt; this.context.x11}`) } }) // and Interceptor.attach(basePtr.add(0x6D54672104), { onEnter() { console.log(`push ${this.context.x10} &amp; ${this.context.x11} to stack // ${this.context.x10 &amp; this.context.x11}`) } }) // sub Interceptor.attach(basePtr.add(0x6D54671F14), { onEnter() { console.log(`push ${this.context.x10} - ${this.context.x11} to stack // ${this.context.x10 - this.context.x11}`) } }) // less Interceptor.attach(basePtr.add(0x6D5467220C), { onEnter() { console.log(`push ${this.context.x10} &lt; ${this.context.x11} to stack // ${this.context.x10 &lt; this.context.x11}`) } }) // xor Interceptor.attach(basePtr.add(0x6D54672180), { onEnter() { console.log(`push ${this.context.x10} ^ ${this.context.x12} to stack // ${this.context.x10 ^ this.context.x12}`) } }) // loadi32toStack Interceptor.attach(basePtr.add(0x6D546723D8), { onEnter() { heapIdx = this.context.x10; let value = ptr(this.context.x11).add(this.context.x10 * 4 + 0x20).readU32(); console.log(`load heap[${heapIdx}] to stack // heap[${heapIdx}] = ${value}`) } }) // shiftL Interceptor.attach(basePtr.add(0x6D54672008), { onEnter() { console.log(`push ${this.context.x10} &lt;&lt; ${this.context.x11} to stack // ${this.context.x10 &lt;&lt; this.context.x11}`) } }) // add Interceptor.attach(basePtr.add(0x6D54671E98), { onEnter() { console.log(`push ${this.context.x10} + ${this.context.x11} to stack // ${this.context.x10 + this.context.x11}`) } }) Interceptor.attach(basePtr.add(0x6D5467232C), { onEnter() { console.log(&quot;jmp if zero&quot;); } }) Interceptor.attach(basePtr.add(0x6D546722C4), { onEnter() { console.log(&quot;jmp if not zero&quot;); } })}setTimeout(main, 1000); 这里注意有有几条指令(比如load i32 to stack) 执行操作的位置离ret非常近，如果frida inline hook的点选的不好会导致程序直接崩溃，因为注入点没有足够的空间容纳跳转指令 trace完大概长这样，大约350条 然后就可以手撕了，能复原出来加密算法如下 123456789101112131415161718192021222324252627low32 = 0x038217c2hig32 = 0xae869c8aa1 = [0, 0, 0, 0]for i in range(24, -1, -8): a1[i//8] = (low32 &gt;&gt; i) &amp; 0xffa2 = [0, 0, 0, 0]a2[0] = a1[0]-0x1ba2[1] = a1[1] ^ 0xc2a2[2] = a1[2]+0xa8a2[3] = a2[3] ^ 0x36res1 = 0for i in range(0, 25, 8): res1 |= (((a2[i//8] ^ i) &amp; 0xFF) &lt;&lt; i)a3 = [0, 0, 0, 0]for i in range(24, -1, -8): a3[i//8] = (hig32 &gt;&gt; i) &amp; 0xffa4 = [0, 0, 0, 0]a4[0] = a3[0]-0x2fa4[1] = a3[1] ^ 0xb6a4[2] = a3[2]+0x37a4[3] = a3[3] ^ 0x98res2 = 0for i in range(0, 25, 8): res2 |= (((a4[i//8] + i) &amp; 0xFF) &lt;&lt; i) 然后解密如下 12345678910111213141516171819202122232425262728def decodeVM(ret1, ret2): a1 = [0, 0, 0, 0] a2 = [0, 0, 0, 0] a3 = [0, 0, 0, 0] a4 = [0, 0, 0, 0] for i in range(0, 25, 8): a4[i//8] = (ret2 &gt;&gt; i) &amp; 0xff a4[i//8] = a4[i//8]-i a3[0] = a4[0]+0x2f a3[1] = a4[1] ^ 0xb6 a3[2] = a4[2]-0x37 a3[3] = a4[3] ^ 0x98 for i in range(0, 25, 8): a2[i//8] = (ret1 &gt;&gt; i) &amp; 0xff a2[i//8] = a2[i//8] ^ i a1[0] = a2[0]+0x1b a1[1] = a2[1] ^ 0xc2 a1[2] = a2[2]-0xa8 a1[3] = a2[3] ^ 0x36 res1 = 0 res2 = 0 for i in range(0, 25, 8): res1 |= (((a1[i//8] &amp; 0xFF) &lt;&lt; i)) res2 |= (((a3[i//8] &amp; 0xFF) &lt;&lt; i)) print(&quot;low&quot;, hex(res1)) print(&quot;hig&quot;, hex(res2)) return res1, res2 xtea魔改了一个xtea，这个随便逆下就行了，xtea的解密没什么好说的，注意用了两个sum以及sum的初始值key就动调拿一下就行 1234567Interceptor.attach(ll2.base.add(0x465C60), { onEnter() { for (let i = 0; i &lt; 12; i++) { console.log(`key[${i}]: `, this.context.x0.add(i * 4).readU32().toString(16)); } } }) 12345678910111213141516171819202122232425262728void xteaDecrypt(uint32_t *v, uint32_t *k){ uint32_t sum = 0, v0 = v[0], v1 = v[1]; uint32_t sum1 = -1091584273; uint32_t sum2 = -1650623010; uint32_t delta = 559038737; sum1 -= 64 * delta; sum2 -= 64 * delta; sum = delta * 32; uint32_t ks2 = (sum2 &gt;&gt; 13) &amp; 3; for (int i = 0; i &lt; 64; i++) { sum2 += delta; v1 -= (sum2 + k[(sum2 &gt;&gt; 13) &amp; 3]) ^ (((v0 &lt;&lt; 8) ^ (v0 &gt;&gt; 7)) - v0); sum1 += delta; v0 -= (sum1 - k[sum1 &amp; 3]) ^ (((v1 &lt;&lt; 7) ^ (v1 &gt;&gt; 8)) + v1); } v[0] = v0; v[1] = v1;}int main(){ uint32_t key[4] = {0x7b777c63, 0xc56f6bf2, 0x2b670130, 0x76abd7fe}; uint32_t plaintext[2] = {71807475, 0}; // {token , 0} xteaDecrypt((uint32_t *)plaintext, key); printf(&quot;%08X %08X&quot;, plaintext[0], plaintext[1]); return 0;} 总结解密输入转成64位整数先跳到libsec2023.so中分高低两份分别进行简单计算加密和字节翻转和dex中的混淆加密，然后高低两份调换位置重新拼成64位传入libil2cpp.so中传入一个vm算法中加密，然后结果再传入xtea中加密，加密完后高位部分和0比较，低位部分和token比较 把上面的解密拼一下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081def decodeVM(ret1, ret2): a1 = [0, 0, 0, 0] a2 = [0, 0, 0, 0] a3 = [0, 0, 0, 0] a4 = [0, 0, 0, 0] for i in range(0, 25, 8): a4[i//8] = (ret2 &gt;&gt; i) &amp; 0xff a4[i//8] = a4[i//8]-i a3[0] = a4[0]+0x2f a3[1] = a4[1] ^ 0xb6 a3[2] = a4[2]-0x37 a3[3] = a4[3] ^ 0x98 for i in range(0, 25, 8): a2[i//8] = (ret1 &gt;&gt; i) &amp; 0xff a2[i//8] = a2[i//8] ^ i a1[0] = a2[0]+0x1b a1[1] = a2[1] ^ 0xc2 a1[2] = a2[2]-0xa8 a1[3] = a2[3] ^ 0x36 res1 = 0 res2 = 0 for i in range(0, 25, 8): res1 |= (((a1[i//8] &amp; 0xFF) &lt;&lt; i)) res2 |= (((a3[i//8] &amp; 0xFF) &lt;&lt; i)) print(&quot;low&quot;, hex(res1)) print(&quot;hig&quot;, hex(res2)) return res1, res2def decode1(enc): print(hex(enc)) enc = [(enc &gt;&gt; 24) &amp; 0xFF, (enc &gt;&gt; 16) &amp; 0xFF, (enc &gt;&gt; 8) &amp; 0xFF, enc &amp; 0xFF] print(list(map(hex, enc))) # 65b0c4b07ac8b1d9 enc[0] = enc[0]+0x1c enc[1] = (enc[1]+8) ^ 0xd3 ^ 1 enc[2] = ((enc[2]+16)+0x5e) ^ 2 enc[3] = (enc[3]+24) ^ 0x86 ^ 3 print(hex((enc[0] &lt;&lt; 24) | (enc[1] &lt;&lt; 16) | (enc[2] &lt;&lt; 8) | enc[3])) return (enc[0] &lt;&lt; 24) | (enc[1] &lt;&lt; 16) | (enc[2] &lt;&lt; 8) | enc[3]def decodeDex(enc): key = [50, -51, -1, -104, 25, -78, 0x7C, -102] b1 = [(enc &gt;&gt; 24) &amp; 0xFF, (enc &gt;&gt; 16) &amp; 0xFF, (enc &gt;&gt; 8) &amp; 0xFF, enc &amp; 0xFF] print(enc) print(list(map(hex, b1))) # b1 = [0x0b, 0x9e, 0x7f, 0xc7] b1 = list(reversed(b1)) for i in range(0, 4): b1[i] = (b1[i]-i) &amp; 0xFF b1[i] = (b1[i] ^ key[i]) &amp; 0xFF v = (b1[0] &lt;&lt; 24) | (b1[1] &lt;&lt; 16) | (b1[2] &lt;&lt; 8) | b1[3] v = v &amp; 0xFFFFFFFF v1 = ((v &lt;&lt; 7) | (v &gt;&gt; 25)) &amp; 0xFFFFFFFF print(hex(v1)) return v1def byteswap(x): return ((x &amp; 0x000000FF) &lt;&lt; 24) | ((x &amp; 0x0000FF00) &lt;&lt; 8) | ((x &amp; 0x00FF0000) &gt;&gt; 8) | ((x &amp; 0xFF000000) &gt;&gt; 24)low32 = 0x7CD0D74Bhig32 = 0xEB77B65Blow32, hig32 = decodeVM(low32, hig32)low32, hig32 = hig32, low32low32 = decodeDex(low32)low32 = byteswap(low32)low32 = decode1(low32)print(&quot;low32:&quot;, hex(low32))hig32 = decodeDex(hig32)hig32 = byteswap(hig32)hig32 = decode1(hig32)print(&quot;hig32:&quot;, hex(hig32))print(hex((hig32 &lt;&lt; 32) | low32))print((byteswap(hig32) &lt;&lt; 32) | byteswap(low32)) 把xtea中解出来的部分分别扔进low32,hig32里，然后跑就行了","link":"/ctf/Android/%E8%85%BE%E8%AE%AF%E6%B8%B8%E6%88%8F%E5%AE%89%E5%85%A8%E5%A4%A7%E8%B5%9B2023%E5%AE%89%E5%8D%93%E5%88%9D%E8%B5%9B/"},{"title":"TGCTF 2025 RE部分WP","text":"re部分除了最后一道index都做了，index附件本身都跑不起来，而且wasm不好玩，不补了 水果忍者点进去直接就写明白了，iv，key和密文直接就有，cyberchef直接解HZNUCTF{de20-70dd-4e62-b8d0-06e} 蛇年的本命语言1先拿把exe解压一下拿到pyc变量名混淆过，先整理一下明显的z3，上面那个仔细观察后发现每个数字都对应一种字符的出现次数，结合z3求解 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115from z3 import *# v = [Int('v%d' % i) for i in range(6)]final = [BitVec('final[%d]' % i, 8) for i in range(30)]S = Solver()mes = r&quot;H1Z1N1U1C1T1F1{1a6b2c5d7e4f3}1&quot;for i in range(1, 30, 2): S.add(final[i] == ord(mes[i])) print(mes[i])S.add([ 7 * final[0] == 504, 9 * final[0] - 5 * final[1] == 403, (2 * final[0] - 5 * final[1]) + 10 * final[2] == 799, 3 * final[0] + 8 * final[1] + 15 * final[2] + 20 * final[3] == 2938, (5 * final[0] + 15 * final[1] + 20 * final[2] - 19 * final[3]) + 1 * final[4] == 2042, (7 * final[0] + 1 * final[1] + 9 * final[2] - 11 * final[3]) + 2 * final[4] + 5 * final[5] == 1225, 11 * final[0] + 22 * final[1] + 33 * final[2] + 44 * final[3] + 55 * final[4] + 66 * final[5] - 77 * final[6] == 7975, ((21 * final[0] + 23 * final[1] + 3 * final[2] + 24 * final[3] - 55 * final[4]) + 6 * final[5] - 7 * final[6]) + 15 * final[7] == 229, (2 * final[0] + 26 * final[1] + 13 * final[2] + 0 * final[3] - 65 * final[4] ) + 15 * final[5] + 29 * final[6] + 1 * final[7] + 20 * final[8] == 2107, (10 * final[0] + 7 * final[1] + -9 * final[2] + 6 * final[3] + 7 * final[4] + 1 * final[5] + 22 * final[6] + 21 * final[7] - 22 * final[8]) + 30 * final[9] == 4037, (15 * final[0] + 59 * final[1] + 56 * final[2] + 66 * final[3] + 7 * final[4] + 1 * final[5] - 122 * final[6]) + 21 * final[7] + 32 * final[8] + 3 * final[9] - 10 * final[10] == 4950, (((13 * final[0] + 66 * final[1] + 29 * final[2] + 39 * final[3] - 33 * final[4]) + 13 * final[5] - 2 * final[6]) + 42 * final[7] + 62 * final[8] + 1 * final[9] - 10 * final[10]) + 11 * final[11] == 12544, (((23 * final[0] + 6 * final[1] + 29 * final[2] + 3 * final[3] - 3 * final[4]) + 63 * final[5] - 25 * final[6] ) + 2 * final[7] + 32 * final[8] + 1 * final[9] - 10 * final[10]) + 11 * final[11] - 12 * final[12] == 6585, ((((223 * final[0] + 6 * final[1] - 29 * final[2] - 53 * final[3] - 3 * final[4]) + 3 * final[5] - 65 * final[6]) + 0 * final[7] + 36 * final[8] + 1 * final[9] - 15 * final[10]) + 16 * final[11] - 18 * final[12]) + 13 * final[13] == 6893, ((((29 * final[0] + 13 * final[1] - 9 * final[2] - 93 * final[3]) + 33 * final[4] + 6 * final[5] + 65 * final[6] + 1 * final[7] - 36 * final[8]) + 0 * final[9] - 16 * final[10]) + 96 * final[11] - 68 * final[12]) + 33 * final[13] - 14 * final[14] == 1883, (((69 * final[0] + 77 * final[1] - 93 * final[2] - 12 * final[3]) + 0 * final[4] + 0 * final[5] + 1 * final[6] + 16 * final[7] + 36 * final[8] + 6 * final[9] + 19 * final[10] + 66 * final[11] - 8 * final[12]) + 38 * final[13] - 16 * final[14]) + 15 * final[15] == 8257, ((((23 * final[0] + 2 * final[1] - 3 * final[2] - 11 * final[3]) + 12 * final[4] + 24 * final[5] + 1 * final[6] + 6 * final[7] + 14 * final[8] - 0 * final[9]) + 1 * final[10] + 68 * final[11] - 18 * final[12]) + 68 * final[13] - 26 * final[14]) + 15 * final[15] - 16 * final[16] == 5847, (((((24 * final[0] + 0 * final[1] - 1 * final[2] - 15 * final[3]) + 13 * final[4] + 4 * final[5] + 16 * final[6] + 67 * final[7] + 146 * final[8] - 50 * final[9]) + 16 * final[10] + 6 * final[11] - 1 * final[12]) + 69 * final[13] - 27 * final[14]) + 45 * final[15] - 6 * final[16]) + 17 * final[17] == 18257, ((((25 * final[0] + 26 * final[1] - 89 * final[2]) + 16 * final[3] + 19 * final[4] + 44 * final[5] + 36 * final[6] + 66 * final[7] - 150 * final[8] - 250 * final[9] ) + 166 * final[10] + 126 * final[11] - 11 * final[12]) + 690 * final[13] - 207 * final[14]) + 46 * final[15] + 6 * final[16] + 7 * final[17] - 18 * final[18] == 12591, (((((5 * final[0] + 26 * final[1] + 8 * final[2] + 160 * final[3] + 9 * final[4] - 4 * final[5]) + 36 * final[6] + 6 * final[7] - 15 * final[8] - 20 * final[9]) + 66 * final[10] + 16 * final[11] - 1 * final[12]) + 690 * final[13] - 20 * final[14]) + 46 * final[15] + 6 * final[16] + 7 * final[17] - 18 * final[18]) + 19 * final[19] == 52041, ((((((29 * final[0] - 26 * final[1]) + 0 * final[2] + 60 * final[3] + 90 * final[4] - 4 * final[5]) + 6 * final[6] + 6 * final[7] - 16 * final[8] - 21 * final[9]) + 69 * final[10] + 6 * final[11] - 12 * final[12]) + 69 * final[13] - 20 * final[14] - 46 * final[15]) + 65 * final[16] + 0 * final[17] - 1 * final[18]) + 39 * final[19] - 20 * final[20] == 20253, (((((((45 * final[0] - 56 * final[1]) + 10 * final[2] + 650 * final[3] - 900 * final[4]) + 44 * final[5] + 66 * final[6] - 6 * final[7] - 6 * final[8] - 21 * final[9]) + 9 * final[10] - 6 * final[11] - 12 * final[12]) + 69 * final[13] - 2 * final[14] - 406 * final[15]) + 651 * final[16] + 2 * final[17] - 10 * final[18]) + 69 * final[19] - 0 * final[20]) + 21 * final[21] == 18768, (((((555 * final[0] - 6666 * final[1]) + 70 * final[2] + 510 * final[3] - 90 * final[4]) + 499 * final[5] + 66 * final[6] - 66 * final[7] - 610 * final[8] - 221 * final[9]) + 9 * final[10] - 23 * final[11] - 102 * final[12]) + 6 * final[13] + 2050 * final[14] - 406 * final[15]) + 665 * final[16] + 333 * final[17] + 100 * final[18] + 609 * final[19] + 777 * final[20] + 201 * final[21] - 22 * final[22] == 111844, (((((((1 * final[0] - 22 * final[1]) + 333 * final[2] + 4444 * final[3] - 5555 * final[4]) + 6666 * final[5] - 666 * final[6]) + 676 * final[7] - 660 * final[8] - 22 * final[9]) + 9 * final[10] - 73 * final[11] - 107 * final[12]) + 6 * final[13] + 250 * final[14] - 6 * final[15]) + 65 * final[16] + 39 * final[17] + 10 * final[18] + 69 * final[19] + 777 * final[20] + 201 * final[21] - 2 * final[22]) + 23 * final[23] == 159029, (((520 * final[0] - 222 * final[1]) + 333 * final[2] + 4 * final[3] - 56655 * final[4]) + 6666 * final[5] + 666 * final[6] + 66 * final[7] - 60 * final[8] - 220 * final[9]) + 99 * final[10] + 73 * final[11] + 1007 * final[12] + 7777 * final[13] + 2500 * final[14] + 6666 * final[15] + 605 * final[16] + 390 * final[17] + 100 * final[18] + 609 * final[19] + 99999 * final[20] + 210 * final[21] + 232 * final[22] + 23 * final[23] - 24 * final[24] == 2762025, ((((1323 * final[0] - 22 * final[1]) + 333 * final[2] + 4 * final[3] - 55 * final[4]) + 666 * final[5] + 666 * final[6] + 66 * final[7] - 660 * final[8] - 220 * final[9]) + 99 * final[10] + 3 * final[11] + 100 * final[12] + 777 * final[13] + 2500 * final[14] + 6666 * final[15] + 605 * final[16] + 390 * final[17] + 100 * final[18] + 609 * final[19] + 9999 * final[20] + 210 * final[21] + 232 * final[22] + 23 * final[23] - 24 * final[24]) + 25 * final[25] == 1551621, (((((777 * final[0] - 22 * final[1]) + 6969 * final[2] + 4 * final[3] - 55 * final[4]) + 666 * final[5] - 6 * final[6]) + 96 * final[7] - 60 * final[8] - 220 * final[9]) + 99 * final[10] + 3 * final[11] + 100 * final[12] + 777 * final[13] + 250 * final[14] + 666 * final[15] + 65 * final[16] + 90 * final[17] + 100 * final[18] + 609 * final[19] + 999 * final[20] + 21 * final[21] + 232 * final[22] + 23 * final[23] - 24 * final[24]) + 25 * final[25] - 26 * final[26] == 948348, ((((((97 * final[0] - 22 * final[1]) + 6969 * final[2] + 4 * final[3] - 56 * final[4]) + 96 * final[5] - 6 * final[6]) + 96 * final[7] - 60 * final[8] - 20 * final[9]) + 99 * final[10] + 3 * final[11] + 10 * final[12] + 707 * final[13] + 250 * final[14] + 666 * final[15] + -9 * final[16] + 90 * final[17] + -2 * final[18] + 609 * final[19] + 0 * final[20] + 21 * final[21] + 2 * final[22] + 23 * final[23] - 24 * final[24]) + 25 * final[25] - 26 * final[26]) + 27 * final[27] == 777044, (((((177 * final[0] - 22 * final[1]) + 699 * final[2] + 64 * final[3] - 56 * final[4] - 96 * final[5] - 66 * final[6]) + 96 * final[7] - 60 * final[8] - 20 * final[9]) + 99 * final[10] + 3 * final[11] + 10 * final[12] + 707 * final[13] + 250 * final[14] + 666 * final[15] + -9 * final[16] + 0 * final[17] + -2 * final[18] + 69 * final[19] + 0 * final[20] + 21 * final[21] + 222 * final[22] + 23 * final[23] - 224 * final[24]) + 25 * final[25] - 26 * final[26]) + 27 * final[27] - 28 * final[28] == 185016, ((((((77 * final[0] - 2 * final[1]) + 6 * final[2] + 6 * final[3] - 96 * final[4] - 9 * final[5] - 6 * final[6]) + 96 * final[7] - 0 * final[8] - 20 * final[9]) + 99 * final[10] + 3 * final[11] + 10 * final[12] + 707 * final[13] + 250 * final[14] + 666 * final[15] + -9 * final[16] + 0 * final[17] + -2 * final[18] + 9 * final[19] + 0 * final[20] + 21 * final[21] + 222 * final[22] + 23 * final[23] - 224 * final[24]) + 26 * final[25] - -58 * final[26]) + 27 * final[27] - 2 * final[28]) + 29 * final[29] == 130106])if S.check() == sat: ans = S.model() print(ans) print(ans[final[14]].as_long()) for i in range(30): print(chr(ans[final[i]].as_long()), end=&quot;&quot;)# 1U1C1T1F1{1 a6 d2 75 f7 46 3 }1finalans = [0 for i in range(30)]finalans[0] = 72finalans[1] = 49finalans[2] = 90finalans[3] = 49finalans[4] = 78finalans[5] = 49finalans[6] = 85finalans[7] = 49finalans[8] = 67finalans[9] = 49finalans[10] = 84finalans[11] = 49finalans[12] = 70finalans[13] = 49finalans[14] = 123finalans[15] = 49finalans[16] = 97finalans[17] = 54finalans[18] = 100finalans[19] = 50finalans[20] = 55finalans[21] = 53finalans[22] = 102finalans[23] = 55finalans[24] = 13finalans[25] = 52finalans[26] = 54finalans[27] = 51finalans[28] = 125finalans[29] = 49for i in range(30): print(chr(finalans[i]), end=&quot;&quot;)# H1Z1N1U1C1T1F1{1 a6 d2 75 f7 x4 63}1 解完后发现出现4次的字符对应的是不可见字符，可能是z3有多解，尝试爆破，试出来那个位置还有一种解是-HZNUCTF{ad7fa-76a7-ff6a-fffa-7f7d6a} randomsystem点开有花，拿脚本去一去 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758from binaryninja import *import bisectdef matchPatterns(idx: int, bv: BinaryView, instructions: List[Tuple[List[InstructionTextToken], int]], address: List[int]): curInstruction = instructions[idx] if curInstruction[0][0].text == 'jz': # jz jnz if idx + 1 &lt; len(instructions): nextInstruction = instructions[idx + 1] if nextInstruction[0][0].text == 'jnz': if curInstruction[0][2].text == nextInstruction[0][2].text: # print(curInstruction[0], nextInstruction[0]) print(&quot;find jz jnz&quot;) return (curInstruction[1], curInstruction[0][2].value-1) if curInstruction[0][0].text == 'jnz': # jnz jz if idx + 1 &lt; len(instructions): nextInstruction = instructions[idx + 1] if nextInstruction[0][0].text == 'jz': if curInstruction[0][2].text == nextInstruction[0][2].text: # print(curInstruction[0], nextInstruction[0]) print(&quot;find jnz jz&quot;) return (curInstruction[1], curInstruction[0][2].value-1) if curInstruction[0][0].text == 'call': # call-return nextInstructionAddr = instructions[idx + 1][1] # print(curInstruction[0]) if len(curInstruction[0][2].text) and curInstruction[0][2].text[0] == '$': idx = find_instruction_idx(address, curInstruction[0][2].value) if idx != None: callInstruction: List[InstructionTextToken] = instructions[idx][0] if callInstruction[0].text == 'add' and len(callInstruction) == 11 and (callInstruction[8].text == r'%esp' or callInstruction[8].text == r'%rsp'): print(&quot;find call-return&quot;) print(&quot;nextInstructionAddr&quot;, nextInstructionAddr) print(&quot;callInstructionOffset&quot;, callInstruction[2].value) return (curInstruction[1], nextInstructionAddr+callInstruction[2].value-1)def find_instruction_idx(address, addr: int): # print(addr) idx = bisect.bisect_left(address, addr) # 二分说是 if idx &lt; len(address) and addr == address[idx]: return idx else: return Nonedef scanAllInstruction(bv: BinaryView): instructions = [ins for ins in bv.instructions] instructions = sorted(instructions, key=lambda x: x[1]) address = [addr[1] for addr in instructions] for i in range(0, len(instructions)): nopRange = matchPatterns(i, bv, instructions, address) if nopRange: bv.write(nopRange[0], b'\\x90' * (nopRange[1] - nopRange[0] + 1)) print(f&quot;Found NOP range: {hex(nopRange[0])} to {hex(nopRange[1])}&quot;)scanAllInstruction(bv) 点开里面一大坨，但发现前面乱七八杂糟的都在初始化dest这个量，而这个量的预期值直接明文给出了，直接动调patch进入下面的逻辑下面那个rand也不看，反正都是初始化，动调抓最后是一个异或，key直接动调拿到倒数第二个是一个矩阵乘，用z3反解 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475from z3 import *# v = [Int('v%d' % i) for i in range(6)]final = [Int('final[%d]' % i) for i in range(64)]S = Solver()S.add(298 == final[0] + final[8] + final[24] + final[48])S.add(257 == final[1] + final[9] + final[25] + final[49])S.add(255 == final[2] + final[10] + final[26] + final[50])S.add(400 == final[3] + final[11] + final[27] + final[51])S.add(327 == final[4] + final[12] + final[28] + final[52])S.add(300 == final[5] + final[13] + final[29] + final[53])S.add(216 == final[6] + final[14] + final[30] + final[54])S.add(307 == final[7] + final[15] + final[31] + final[55])S.add(302 == final[8] + final[16] + final[40] + final[56])S.add(264 == final[9] + final[17] + final[41] + final[57])S.add(244 == final[10] + final[18] + final[42] + final[58])S.add(359 == final[11] + final[19] + final[43] + final[59])S.add(303 == final[12] + final[20] + final[44] + final[60])S.add(310 == final[13] + final[21] + final[45] + final[61])S.add(264 == final[14] + final[22] + final[46] + final[62])S.add(342 == final[15] + final[23] + final[47] + final[63])S.add(341 == final[16] + final[24] + final[40] + final[48])S.add(258 == final[17] + final[25] + final[41] + final[49])S.add(244 == final[18] + final[26] + final[42] + final[50])S.add(385 == final[19] + final[27] + final[43] + final[51])S.add(356 == final[20] + final[28] + final[44] + final[52])S.add(296 == final[21] + final[29] + final[45] + final[53])S.add(265 == final[22] + final[30] + final[46] + final[54])S.add(310 == final[23] + final[31] + final[47] + final[55])S.add(196 == final[24] + final[40] + final[56])S.add(167 == final[25] + final[41] + final[57])S.add(249 == final[26] + final[42] + final[58])S.add(317 == final[27] + final[43] + final[59])S.add(204 == final[28] + final[44] + final[60])S.add(159 == final[29] + final[45] + final[61])S.add(211 == final[30] + final[46] + final[62])S.add(202 == final[31] + final[47] + final[63])S.add(204 == final[8] + final[32] + final[48])S.add(200 == final[9] + final[33] + final[49])S.add(206 == final[10] + final[34] + final[50])S.add(286 == final[11] + final[35] + final[51])S.add(204 == final[12] + final[36] + final[52])S.add(321 == final[13] + final[37] + final[53])S.add(209 == final[14] + final[38] + final[54])S.add(264 == final[15] + final[39] + final[55])S.add(151 == final[40] + final[56])S.add(113 == final[41] + final[57])S.add(147 == final[42] + final[58])S.add(196 == final[43] + final[59])S.add(148 == final[44] + final[60])S.add(111 == final[45] + final[61])S.add(156 == final[46] + final[62])S.add(145 == final[47] + final[63])S.add(152 == final[48] + final[56])S.add(107 == final[49] + final[57])S.add(154 == final[50] + final[58])S.add(213 == final[51] + final[59])S.add(147 == final[52] + final[60])S.add(154 == final[53] + final[61])S.add(112 == final[54] + final[62])S.add(98 == final[55] + final[63])S.add(204 == final[8] + final[16] + final[56])S.add(208 == final[9] + final[17] + final[57])S.add(199 == final[10] + final[18] + final[58])S.add(260 == final[11] + final[19] + final[59])S.add(203 == final[12] + final[20] + final[60])S.add(256 == final[13] + final[21] + final[61])S.add(165 == final[14] + final[22] + final[62])S.add(242 == final[15] + final[23] + final[63])if S.check() == sat: ans = S.model() # print(ans) for i in range(64): print(chr(ans[final[i]].as_long()), end=&quot;&quot;) 解出fd11v56d454r6f4acb-1ea8d-6fy80795af83zfrb8-cd6cdc24tca7559fa099-再往前就是交换混淆，这个直接往里面输入1，2，3，4，5…爆破交换映射然后重新映射回去即可解出flag 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;bits/stdc++.h&gt;using namespace std;int enc[] = {376, 356, 169, 501, 277, 329, 139, 342, 380, 365, 162, 258, 381, 339, 347, 307, 263, 359, 162, 484, 310, 333, 346, 339, 150, 194, 175, 344, 158, 250, 128, 175, 158, 173, 152, 379, 158, 292, 130, 365, 197, 20, 197, 161, 198, 10, 207, 244, 202, 14, 204, 176, 193, 255, 35, 7, 158, 181, 145, 353, 153, 357, 246, 151};unsigned char key[] = { 0x52, 0x65, 0x56, 0x65, 0x52, 0x65, 0x53, 0x65};int dw[64] = {1, 1, 0, 1, 0, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 1};int main(){ for (int i = 0; i &lt; 64; i++) { enc[i] ^= key[i % 8]; // get final } int k; // [esp+D0h] [ebp-20h] int j; // [esp+DCh] [ebp-14h] int i; // [esp+E8h] [ebp-8h] // for (i = 0; i &lt; 8; ++i) // { // for (j = 0; j &lt; 8; ++j) // { // // final[8 * i + j] = 0; // printf(&quot;S.add(%d == &quot;, enc[8 * i + j]); // for (k = 0; k &lt; 8; ++k) // if (dw[8 * i + k]) // { // printf(&quot;final[%d] +&quot;, 8 * k + j); // } // printf(&quot;)\\n&quot;); // // final[8 * i + j] += intDest[8 * k + j] * dw[8 * i + k]; // } // // result = i + 1; // } unsigned char mappingTable[] = { 37, 38, 39, 41, 36, 63, 58, 54, 44, 57, 49, 50, 33, 46, 45, 43, 55, 34, 42, 40, 56, 62, 35, 61, 52, 53, 47, 48, 64, 51, 59, 60, 13, 18, 23, 5, 1, 2, 3, 20, 4, 19, 16, 9, 15, 14, 27, 28, 11, 12, 30, 25, 26, 8, 17, 21, 10, 7, 31, 32, 24, 22, 6, 29}; char final[] = &quot;fd11v56d454r6f4acb-1ea8d-6fy80795af83zfrb8-cd6cdc24tca7559fa099-&quot;; char ans[65]; for (int i = 1; i &lt;= 64; i++) { ans[i] = final[mappingTable[i - 1] - 1]; } for (int i = 1; i &lt;= 64; i++) printf(&quot;%c&quot;, ans[i]); return 0; // fd11v56d454r6f4acb-1ea8d-6fy80795af83zfrb8-cd6cdc24tca7559fa099-} HZNUCTF{3zfb899ac5c256d-7a8r59f0tccd-4fa6b8vfd111-a44ffy4r0-6dce5679da58} exchange打开有一个很奇怪的算法，对比下输入输出可以看到是把输入以4个16进制位为一组，交换中间的两位并转字符串里面就是很明显的一个des，findCrypto可以找到盒然后这个des是魔改过的，工具没法解，众所周知Fesitel网络密码只要把轮函数反过来跑就能解密，des就是把key倒过来用动调抓一下key，发现这个key似乎是对称的，而且组数也太多了点，合理怀疑这是一个加解密一体的算法，后半部分就是解密用的反key直接把key的指针+32 (看一下当前传参时key的地址通过哪个寄存器转递，直接改寄存器值)然后把密文patch进输入里跑可以看到跑出来的结果十分好看然后写脚本把换位改回去转成hex 123456789char mes[] = &quot;333936147332632923d96353321d3345636826d26314621d3349330463126348&quot;; for (int i = 0; i &lt; 64; i += 4) { swap(mes[i + 1], mes[i + 2]); } for (int i = 0; i &lt; 64; i += 2) { printf(&quot;%c%c &quot;, mes[i], mes[i + 1]); } 直接解出 xteacbc模式的xtea，直接进去抄源码注意到这里有一个反调试，如果直接动调拿key的话种子不对写脚本 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;bits/stdc++.h&gt;using namespace std;void xteaDecrypt(uint32_t *v_0, uint32_t *v_1, uint32_t *k){ uint32_t sum = 0; // printf(&quot;%u %u\\n&quot;, v0, v1); uint32_t v0 = *v_0; uint32_t v1 = *v_1; uint32_t delta = 2654435769u; for (int i = 0; i &lt; 32; i++) sum -= delta; for (int i = 0; i &lt; 32; i++) { v1 -= (k[(sum &gt;&gt; 11) &amp; 3] + sum) ^ (v0 + ((v0 &gt;&gt; 5) ^ (16 * v0))); sum += delta; v0 -= (k[sum &amp; 3] + sum) ^ (v1 + ((v1 &gt;&gt; 5) ^ (16 * v1))); } *v_0 = v0; *v_1 = v1;}int main(){ srand(0x7e8); uint32_t key[4] = {6651, 15290, 20313, 4631}; for (int i = 0; i &lt; 4; i++) key[i] = rand(); uint32_t enc[8] = { 2362123044u, 161969178u, 4215039885u, 4127734393u, 4056687643u, 972708338u, 4071350732u, 387489650u}; for (int j = 6; j &gt;= 0; j--) xteaDecrypt(&amp;enc[j], &amp;enc[j + 1], key); for (int j = 0; j &lt; 32; j += 4) { for (int i = j + 3; i &gt;= j; i--) printf(&quot;%c&quot;, ((char *)enc)[i]); } return 0;} HZNUCTF{ae6-9f57-4b74-b423-98eb} conforanddie检测有ollvm，先尝试用d810解一下解完还是很丑，每个函数都有几百行，但是出题人没删符号表，定位几个关键点众所周知rc4跑两次等于没跑，所以我们尝试用frida去手动调用rc4检查initbox的部分，发现引入了随机数种子，且种子未给出但注意到这个随机数的范围被限定在了0~255(S盒里的元素是uint8)，且rand只调用了这一次所以我们可以hook rand的返回值，爆破所有情况写frida脚本 123456789101112131415161718192021222324252627282930313233343536var lib = Process.findModuleByName(&quot;conforand&quot;);var sym = lib.enumerateSymbols();for (var i = 0; i &lt; sym.length; i++) { console.log(sym[i].name);}var randPtr = Module.findExportByName(&quot;libc.so.6&quot;, &quot;rand&quot;);console.log(&quot;randPtr: &quot; + randPtr);var rc4Ptr = lib.findSymbolByName(&quot;rc4&quot;);var rand = new NativeFunction(randPtr, 'int', []);var rc4 = new NativeFunction(rc4Ptr, 'void', ['pointer', 'int', 'pointer', 'int']);var rc4Key = Memory.alloc(9);rc4Key.writeUtf8String(&quot;JustDoIt!&quot;);let randRet = 0Interceptor.attach(randPtr, { onLeave: function (retval) { retval.replace(randRet); }})for (let i = 0; i &lt; 256; i++) { randRet = i; // console.log(rand()); var Input = Memory.alloc(42); Input.writeByteArray([0x83, 0x1e, 0x9c, 0x48, 0x7a, 0xfa, 0xe8, 0x88, 0x36, 0xd5, 0x0a, 0x08, 0xf6, 0xa7, 0x70, 0x0f, 0xfd, 0x67, 0xdd, 0xd4, 0x3c, 0xa7, 0xed, 0x8d, 0x51, 0x10, 0xce, 0x6a, 0x9e, 0x56, 0x57, 0x83, 0x56, 0xe7, 0x67, 0x9a, 0x67, 0x22, 0x24, 0x6e, 0xcd, 0x2f]); rc4(Input, 42, rc4Key, 9); try { console.log(Input.readUtf8String(41)); } catch (e) { console.log(&quot;Error: &quot; + e); }} 123456789101112131415161718192021222324252627282930313233343536import fridaimport sysimport timedef onMessage(message, data): if message['type'] == 'send': print(&quot;[!!] Message from target: &quot;, message['payload']) else: print(&quot;Not a send type Message&quot;, message['stack'])with open('FridaScript.js', &quot;r&quot;, encoding=&quot;utf-8&quot;) as f: jscode = f.read()targetProcessPackName = &quot;./conforand&quot;device = frida.get_local_device()try: pid = device.spawn(targetProcessPackName) session = device.attach(pid) print(pid)except frida.ProcessNotFoundError: print(&quot;No such process&quot;) sys.exit(0)device.resume(pid)time.sleep(2)# input(&quot;continue&quot;)script = session.create_script(jscode)script.on('message', onMessage)script.load()# device.resume(pid)sys.stdin.read() 解出HZNUCTF{489b88-1305-411e-b1f4-88a3070a73}","link":"/ctf/WP/TGCTF%202025/"},{"title":"掌控内核 - ebpf整体概念和入门","text":"这篇其实算是ebpf0x0 什么是ebpfebpf由bpf演变而来，其最初的作用是数据链路层的报文过滤框架，之后随着bpf的功能不断拓展有了ebpf框架，除了报文过滤外还添加了追踪/拦截系统调用的功能根据docs.ebpf.io中的介绍，ebpf主要有以下几个核心内容 Programsebpf程序，ebpf本质上是一个c语言编写，llvm（通常来说是这样）编译的.o二进制文件，使用linux的loader library(libbpf)动态加载到内核中，从而实现用户态和内核态的交互以及监视内核行为与通常的c语言程序不同，为了确保内核安全，loader会对程序做检查，禁用循环等可能产生危险的行为（你也不想你内核里有个程序卡死吧） Helper functions一些内置的函数，用于在ebpf程序中执行一些高级操作 KFuncs作用和Helper functions相同，都是提供一些高级操作，因为Helper functions属于UAPI，为了稳定性考虑Helper functions实际上是不更新的，所以KFuncs负责拓展功能，但与之相对的KFuncs在不同linux版本之间不保证api兼容性 Maps分为array_map和hash_map(任意键值对)，实际上就是ebpf中管理内存的方式（malloc是危险的），但是Maps提供的功能远比管理内存强大，Maps是内核共享的，所以能实现bpf程序之间，bpf程序和用户态程序之间的数据交互 Objectsebpf程序和maps都是对象，由ebpf loader创建，并且每个对象都会获得一个fd作为它的唯一标识符，对象的生命周期采用一种智能的管理方法，会在所有指向其的引用消失后自动回收，fd是内核共享的，用户态程序可以通过这些fd共享ebpf程序的信息，fd还可以通过pining储存在bpf file system中，pining的对象会由bpf file system维持其引用，也就是不会被回收 使用环境ebpf作为一个比较新的框架功能迭代非常快，如果条件允许可以尽量使用新的内核版本，一般来说建议使用5.10以上的版本，然后发行版镜像一般不会开启完整的ebpf功能，如果有条件可以自行编译内核开启完整功能（比如syscall 和 ftrace），不过依靠kprobe已经能实现不少功能,这个系列文章基于的设备是内核序列号为oriole-bp2a.250605.031.a2的pixel 6，使用官方出厂镜像，只使用KernelSU添加了root，无其他修改 考虑到bcc本身搭建环境比较复杂，而且在编写内核态程序时使用的是类c的语法，所以本文章不使用bcc，而是采用在linux虚拟机（桌面平台）中交叉编译后直接push可执行文件到手机的方案，采用的加载器是libbpf，这样所有编码都采用c/c++实现（我不会写go所以用不了cilium） 交叉编译关于交叉编译，如果想简单体验的话可以直接用这个项目开始libbpf-bootstrap-android,这是libbpf-bootstrap的安卓迁移版本，修改了makefile配置使其支持交叉编译，同时也准备了zlib.a和libelf.a两个静态链接库，除了要自己下载ndk工具链外基本不需要准备任何依赖 如果想研究自行交叉编译，可以参考下面的脚本，这应该是ebpf最简单的交叉编译方法 1234567891011121314151617181920aarch64-linux-android35-clang \\ # 使用ndk-clang编译内核态.o文件 -I./libbpf_include \\ # 给编译器添加libbpf相关的头文件搜索路径 -I./zlib_include \\ # 添加zlib相关头文件搜索路径 -I./libelf_include \\ # 添加libelf相关头文件搜索路径 -I/home/sgsg/android-ndk-r27c/toolchains/llvm/prebuilt/linux-x86_64/sysroot/usr/include/aarch64-linux-android \\ # 添加arm64 linux c头文件搜索路径，不然的话编译器会去/usr下找x86的头文件，然后编译就挂了 -g -O2 -Wall -target bpf -D__TARGET_ARCH_aarch64 \\ # 指定目标格式为bpf，指定架构为arm64 -c bpf_test.bpf.c \\ # 添加源代码文件 -o bpf_test.bpf.o -static # 静态链接，避免依赖问题bpftool gen skeleton bpf_test.bpf.o &gt; bpf_test.skel.h # libbpf建议使用skeleton加载，具体就是在内核态elf生成完毕后，使用bpftool生成.h文件，这个.h文件里包含了内核态文件完整的字节码和对应的加载函数，直接在用户态中引入这个头文件调用预生成的函数就可以加载程序到内核了aarch64-linux-gnu-gcc test_bpf_loader.c \\ # 添加源代码文件 -I./libbpf_include \\ # 同样添加头文件路径 -I./zlib_include \\ -I./libelf_include \\ -I/home/sgsg/android-ndk-r27c/toolchains/llvm/prebuilt/linux-x86_64/sysroot/usr/include/aarch64-linux-android \\ ./libs/libbpf.a \\ # 静态链接依赖 ./libs/libz.a \\ ./libs/libelf.a \\ -o loader -static # 静态编译，可以省去很多跨平台兼容性问题，就是产物会稍微大一点 项目文件结构如下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364── bpf_test.bpf.c├── bpf_test.bpf.o├── bpf_test.skel.h├── build.sh├── libbpf_include│ └── bpf│ ├── bpf_core_read.h│ ├── bpf_endian.h│ ├── bpf.h│ ├── bpf_helper_defs.h│ ├── bpf_helpers.h│ ├── bpf_tracing.h│ ├── btf.h│ ├── hashmap.h│ ├── libbpf_common.h│ ├── libbpf.h│ ├── libbpf_internal.h│ ├── libbpf_legacy.h│ ├── libbpf_version.h│ ├── relo_core.h│ ├── skel_internal.h│ └── usdt.bpf.h├── libelf_include│ ├── elf-knowledge.h│ ├── gelf.h│ ├── libelf.h│ ├── nlist.h│ └── version.h├── libs│ ├── libbpf.a│ ├── libelf.a│ └── libz.a├── test_bpf_loader.c├── vmlinux.h└── zlib_include ├── blast.h ├── crc32.h ├── crypt.h ├── deflate.h ├── gzguts.h ├── gzlog.h ├── infback9.h ├── inffast.h ├── inffix9.h ├── inffixed.h ├── inflate9.h ├── inflate.h ├── inftree9.h ├── inftrees.h ├── ioapi.h ├── iowin32.h ├── mztools.h ├── puff.h ├── trees.h ├── unzip.h ├── zconf.h ├── zconf.h.cmakein ├── zconf.h.in ├── zfstream.h ├── zip.h ├── zlib.h ├── zlib_how.html ├── zstream.h └── zutil.h 其中这些依赖和头文件可以去libbpf-bootstrap-android中获取，libbpf.a需要运行一次make后在example/c/libbpf中获取，vmlinux.h需要使用bpftool在手机上运行bpftool btf dump file /sys/kernel/btf/vmlinux format c，如果你的手机没有该文件说明不支持bpf头文件（稍微新一点的基本都支持），那就要使用libbpf-bootstrap-android中提供的头文件想要查看手机支持ebpf的哪些特性可以通过运行bpftool feature查看 demo123456789101112// bpf_test.bpf.c#include &lt;linux/bpf.h&gt;#include &lt;bpf/bpf_helpers.h&gt;SEC(&quot;kprobe/kernel_clone&quot;)int bpf_prog(void *ctx){ bpf_printk(&quot;Hello from eBPF with Skeleton!&quot;); return 0;}char _license[] SEC(&quot;license&quot;) = &quot;GPL&quot;; 12345678910111213141516171819// bpf_test_loader.c#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &quot;bpf_test.skel.h&quot;int main(int argc, char **argv){ struct bpf_test_bpf *skel; int err; skel = bpf_test_bpf__open_and_load(); bpf_test_bpf__attach(skel); printf(&quot;BPF skeleton loaded and attached successfully. Press enter to exit...\\n&quot;); getchar(); bpf_test_bpf__destroy(skel); return 0;} 这是一个简单的demo，用来跟踪clone命令内置的kprobe挂载点，只要clone命令触发（任何创建新进程的行为都需要调用clone）就会在sys/kernel/tracing/trace_pipe这个文件（比较新的内核都是这个路径，老一点的是在debug路径下的，如果没有的话手动挂载一下tracingFS和debugFS）中输出Hello from eBPF with Skeleton!在使用前需要在/sys/kernel/tracing/tracing_on中输入1开启跟踪echo 1 &gt; tracing_on然后运行loader程序就可以看跟踪结果了 12345678910111213141516171819202122232425262728130|oriole:/sys/kernel/tracing # echo 1 &gt; tracing_onoriole:/sys/kernel/tracing # cat trace_pipe Lite Thread #2-10604 [003] d..3 36892.084632: bpf_trace_printk: Hello from eBPF with Skeleton! Lite Thread #1-10088 [005] d..3 36892.087729: bpf_trace_printk: Hello from eBPF with Skeleton! lowpool[756]-1210 [000] d..3 36892.151596: bpf_trace_printk: Hello from eBPF with Skeleton! servicemanager-480 [003] d..3 36892.805585: bpf_trace_printk: Hello from eBPF with Skeleton! roid.apps.turbo-6207 [003] d..3 36892.929320: bpf_trace_printk: Hello from eBPF with Skeleton! BG Thread #0-6234 [000] d..3 36892.942382: bpf_trace_printk: Hello from eBPF with Skeleton! BG Thread #0-6234 [000] d..3 36892.944007: bpf_trace_printk: Hello from eBPF with Skeleton! servicemanager-480 [001] d..3 36893.813645: bpf_trace_printk: Hello from eBPF with Skeleton! servicemanager-480 [001] d..3 36894.820207: bpf_trace_printk: Hello from eBPF with Skeleton! servicemanager-480 [002] d..3 36895.824630: bpf_trace_printk: Hello from eBPF with Skeleton! servicemanager-480 [002] d..3 36896.828603: bpf_trace_printk: Hello from eBPF with Skeleton! POSIX timer 3-2540 [003] d..3 36897.530348: bpf_trace_printk: Hello from eBPF with Skeleton! servicemanager-480 [003] d..3 36897.832404: bpf_trace_printk: Hello from eBPF with Skeleton! POSIX timer 3-2540 [003] d..3 36898.688762: bpf_trace_printk: Hello from eBPF with Skeleton! servicemanager-480 [002] d..3 36898.840582: bpf_trace_printk: Hello from eBPF with Skeleton! servicemanager-480 [002] d..3 36899.845768: bpf_trace_printk: Hello from eBPF with Skeleton! POSIX timer 3-2540 [000] d..3 36900.606367: bpf_trace_printk: Hello from eBPF with Skeleton! servicemanager-480 [000] d..3 36900.850164: bpf_trace_printk: Hello from eBPF with Skeleton! servicemanager-480 [002] d..3 36901.857614: bpf_trace_printk: Hello from eBPF with Skeleton! POSIX timer 3-2540 [001] d..3 36902.128525: bpf_trace_printk: Hello from eBPF with Skeleton! servicemanager-480 [001] d..3 36902.862111: bpf_trace_printk: Hello from eBPF with Skeleton! servicemanager-480 [001] d..3 36903.866426: bpf_trace_printk: Hello from eBPF with Skeleton! servicemanager-480 [003] d..3 36904.872046: bpf_trace_printk: Hello from eBPF with Skeleton! servicemanager-480 [003] d..3 36905.876475: bpf_trace_printk: Hello from eBPF with Skeleton! POSIX timer 3-2540 [000] d..3 36906.276747: bpf_trace_printk: Hello from eBPF with Skeleton! kthreadd-2 [004] d..3 36906.461608: bpf_trace_printk: Hello from eBPF with Skeleton! 可以看到系统服务创建新进程的行为都被捕捉到了 next","link":"/ctf/ebpf/ebpf0x1/"},{"title":"让我看看你的系统调用 - ebpf常见挂载点","text":"基本上所有设备都能用的常见挂载点，目前考虑6.1内核，可惜的是pixel 6 的6.1内核还不支持fentry/fexit KprobeKprobe是比较常见的附加到内核函数的方法，kprobe/kretprobe分别负责在进入前和返回前hook内核函数用法是使用SEC(kprobe/name),直接使用内核函数的签名即可，比如SEC(kprobe/kernel_clone)，这个签名可以在/proc/kallsym中获取获取调用参数有两种方案，最基础的方法是使用struct pt_regs *ctx作为参数，这个ctx结构体是具有架构依赖的，然后使用PT_REGS_PARM*(ctx)宏读取参数，arm64架构中这个可以填1~8 123456789101112131415161718192021222324#include &quot;vmlinux.h&quot;#include &lt;bpf/bpf_helpers.h&gt;#include &lt;bpf/bpf_tracing.h&gt;SEC(&quot;kprobe/kernel_clone&quot;)int bpf_prog(struct pt_regs *ctx) { const u64 CLONE_THREAD = 0x00010000; struct kernel_clone_args *args_ptr = (struct kernel_clone_args *)PT_REGS_PARM1(ctx); struct kernel_clone_args args; int ret = bpf_probe_read_kernel(&amp;args, sizeof(args), args_ptr); if (ret != 0) { bpf_printk(&quot;Failed to read kernel_clone_args: %d\\n&quot;, ret); return ret; } u64 flags = args.flags; u64 id = bpf_get_current_pid_tgid(); if (args.kthread == 0) { bpf_printk(&quot;new %s created by PID : %d&quot;, flags &amp; CLONE_THREAD ? &quot;thread&quot; : &quot;process&quot;, id &gt;&gt; 32); } return 0;}char _license[] SEC(&quot;license&quot;) = &quot;GPL&quot;; 这就是一个比较简单的探测kernel_clone这个函数的kprobe探针，使用PT_REGS_PARM1读取第一个参数（每个具体参数要查阅内核源代码中的定义），使用bpf_probe_read_kernel读取这个指针指向的参数列表结构体（直接解引用会被检查器拒绝加载，因为这是不安全的行为），然后根据flag这个掩码参数简单区分下进程和线程，通过bpf_get_current_pid_tgid获取调用clone的进程pid，使用printk输出到trace_pipe中可以看到捕捉到了adb服务的活动，和新创建的shell的活动除了直接声明函数还可以使用BPF_KPROBE这个宏，上述的代码可以写成如下等价形式 12345678910111213141516171819202122#include &quot;vmlinux.h&quot;#include &lt;bpf/bpf_helpers.h&gt;#include &lt;bpf/bpf_tracing.h&gt;SEC(&quot;kprobe/kernel_clone&quot;)int BPF_KPROBE(handle_enter_kernel_clone, struct kernel_clone_args *args_ptr) { const u64 CLONE_THREAD = 0x00010000; struct kernel_clone_args args; int ret = bpf_probe_read_kernel(&amp;args, sizeof(args), args_ptr); if (ret != 0) { bpf_printk(&quot;Failed to read kernel_clone_args: %d\\n&quot;, ret); return ret; } u64 flags = args.flags; u64 id = bpf_get_current_pid_tgid(); if (args.kthread == 0) { bpf_printk(&quot;new %s created by PID : %d&quot;, flags &amp; CLONE_THREAD ? &quot;thread&quot; : &quot;process&quot;, id &gt;&gt; 32); } return 0;}char _license[] SEC(&quot;license&quot;) = &quot;GPL&quot;; 这个宏的第一个参数是声明的函数名，之后接受最多五个参数，作为前5个传参寄存器中读取的参数（PT_REGS_PARM1~5），写起来会比第一种写法简洁一点，基本所有探针类型都有类似的宏以及对于这些宏，触发探针时的上下文环境会被以*ctx保存，可以通过ctx访问上下文环境，所以不要在函数中再次使用ctx作为变量名另外还有一种libbpf提供的语法糖ksyscall，因为linux syscall函数的命名通常遵循一定标准，ksyscall可以根据部分提供的函数名自动选择对应的函数附加（比如ksyscall/openat就会选择一种openat的实现），不过由于syscall通常由多种实现所以这种方法很容易漏掉调用，所以其实不大好用 UprobeUprobe是用来hook用户态函数的探针，原理是把目标地址的指令替换成int3（其他架构上就是对应的中断指令）跳到内核态执行hook逻辑（类似条件断点脚本），但是和调试器相比隐蔽性更强，这篇文章中总结了一些Uprobe的对抗手段https://www.cnxct.com/defeating-ebpf-uprobe-monitoring/总结一下的话就是一下几点 扫描中断指令 在maps中扫描[uprobe]内存段(用于储存被中断替换的指令) 将保护目标.text段的权限设置为VM_WRITE使得uprobe的valid_vma函数校验不通过(前提是要对目标二进制文件有修改权限) Uprobe可以做到任意位置插入，因为只有一条断点指令所以也不会出现短指令问题（说的就是你frida），监测性能也会高很多，下面是几种UPROBE探针的示例 完整demo1234567891011121314151617181920212223242526272829303132333435363738// bpf_test.bpf.c#include &quot;vmlinux.h&quot;#include &lt;bpf/bpf_core_read.h&gt;#include &lt;bpf/bpf_helpers.h&gt;#include &lt;bpf/bpf_tracing.h&gt;SEC(&quot;uprobe&quot;)int BPF_UPROBE(hookTestFunc1, int a, int b) { bpf_printk(&quot;hookTestFunc1 called with args: %d, %d\\n&quot;, a, b); return 0;}SEC(&quot;uprobe&quot;)int BPF_UPROBE(hookTestFunc2, int a, int b) { bpf_printk(&quot;hookTestFunc2 called with args: %d, %d\\n&quot;, a, b); return 0;}SEC(&quot;uretprobe&quot;)int BPF_URETPROBE(hookTestFunc3, int ret) { bpf_printk(&quot;hookTestFunc3 called with return value: %d\\n&quot;, ret); return 0;}SEC(&quot;uprobe&quot;)int BPF_UPROBE(insideFuncHook) { bpf_printk(&quot;insideFuncHook called\\n&quot;); bpf_printk(&quot;w8 = %lld ,w9 = %lld&quot;, ctx-&gt;regs[8], ctx-&gt;regs[9]); return 0;}SEC(&quot;uprobe&quot;)int BPF_UPROBE(modifyArgProbe) { bpf_printk(&quot;modify args...&quot;); int valueToWrite = 114514; bpf_probe_write_user((void *)(ctx-&gt;sp + 12), (void *)&amp;valueToWrite, sizeof(int)); valueToWrite = 1919810; bpf_probe_write_user((void *)(ctx-&gt;sp + 8), (void *)&amp;valueToWrite, sizeof(int)); return 0;}char _license[] SEC(&quot;license&quot;) = &quot;GPL&quot;; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122// bpf_test_loader.cpp// SPDX-License-Identifier: (LGPL-2.1 OR BSD-2-Clause)/* Copyright (c) 2021 Sartura * Based on minimal.c by Facebook */#include &quot;bpf_test.skel.h&quot;#include &lt;bpf/libbpf.h&gt;#include &lt;cerrno&gt;#include &lt;csignal&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;format&gt;#include &lt;sys/resource.h&gt;#include &lt;unistd.h&gt;static int libbpf_print_fn(enum libbpf_print_level level, const char *format, va_list args) { return vfprintf(stderr, format, args);}size_t getFunctionOffsetReal(const char *soName, size_t staticOffset, int pid) { char path[256]; snprintf(path, sizeof(path), &quot;/proc/%d/maps&quot;, pid); FILE *fp = fopen(path, &quot;r&quot;); if (!fp) { perror(&quot;fopen&quot;); return -1; } size_t start, end, base, inode, imageBase = -1; char buf[5], dn[6], filePath[256]; bool found = 0; while (fscanf(fp, &quot;%zx-%zx %s %zx %s %lu %s\\n&quot;, &amp;start, &amp;end, buf, &amp;base, dn, &amp;inode, filePath) == 7) { if (imageBase == -1 &amp;&amp; strstr(filePath, soName)) { imageBase = start; } if (buf[2] == 'x' &amp;&amp; strstr(filePath, soName) != nullptr) { printf(&quot;target excuteable segment found : %zx-%zx base: %zx file: %s\\n&quot;, start, end, base, filePath); found = 1; break; } } fclose(fp); if (!found) { printf(&quot;can't find %s in /proc/%d/maps\\n&quot;, soName, pid); return -1; } return imageBase + staticOffset - start + base;}int main(int argc, char **argv) { if (argc != 2) { printf(&quot;need exact one pid\\n&quot;); return 1; } int pid = atoi(argv[1]); struct bpf_test_bpf *skel; int err; /* Set up libbpf errors and debug info callback */ libbpf_set_print(libbpf_print_fn); /* Open load and verify BPF application */ skel = bpf_test_bpf__open_and_load(); if (!skel) { fprintf(stderr, &quot;Failed to open BPF skeleton\\n&quot;); return 1; } err = bpf_test_bpf__attach(skel); if (err) { fprintf(stderr, &quot;Failed to attach BPF skeleton\\n&quot;); goto cleanup; } printf(&quot;binary path: &quot;); printf(&quot;%s\\n&quot;, std::format(&quot;/proc/{}/exe&quot;, pid).c_str()); skel-&gt;links.hookTestFunc1 = bpf_program__attach_uprobe(skel-&gt;progs.hookTestFunc1, false, pid, std::format(&quot;/proc/{}/exe&quot;, pid).c_str(), getFunctionOffsetReal(&quot;test&quot;, 0x1830, pid)); if (!skel-&gt;links.hookTestFunc1) { fprintf(stderr, &quot;Failed to attach uprobes1\\n&quot;); goto cleanup; } skel-&gt;links.hookTestFunc2 = bpf_program__attach_uprobe(skel-&gt;progs.hookTestFunc2, false, pid, std::format(&quot;/proc/{}/exe&quot;, pid).c_str(), getFunctionOffsetReal(&quot;test&quot;, 0x1864, pid)); if (!skel-&gt;links.hookTestFunc2) { fprintf(stderr, &quot;Failed to attach uprobes2\\n&quot;); goto cleanup; } skel-&gt;links.hookTestFunc3 = bpf_program__attach_uprobe(skel-&gt;progs.hookTestFunc3, true, pid, std::format(&quot;/proc/{}/exe&quot;, pid).c_str(), getFunctionOffsetReal(&quot;test&quot;, 0x1884, pid)); if (!skel-&gt;links.hookTestFunc3) { fprintf(stderr, &quot;Failed to attach uprobes3\\n&quot;); goto cleanup; } skel-&gt;links.insideFuncHook = bpf_program__attach_uprobe(skel-&gt;progs.insideFuncHook, false, pid, std::format(&quot;/proc/{}/exe&quot;, pid).c_str(), getFunctionOffsetReal(&quot;test&quot;, 0x1878, pid)); if (!skel-&gt;links.insideFuncHook) { fprintf(stderr, &quot;Failed to attach insideFuncHook\\n&quot;); goto cleanup; } skel-&gt;links.modifyArgProbe = bpf_program__attach_uprobe(skel-&gt;progs.modifyArgProbe, false, pid, std::format(&quot;/proc/{}/exe&quot;, pid).c_str(), getFunctionOffsetReal(&quot;test&quot;, 0x1870, pid)); if (!skel-&gt;links.modifyArgProbe) { fprintf(stderr, &quot;Failed to attach modifyArgProbe\\n&quot;); goto cleanup; } printf(&quot;while 1 \\n&quot;); while (1) ;cleanup: bpf_test_bpf__destroy(skel); return -err;} 1234567891011121314151617181920212223// 测试程序 test.cpp#include &lt;cstdio&gt;#include &lt;unistd.h&gt;using namespace std;struct Args { int a; int b; int c;};void testFunc1(int a, int b) { printf(&quot;atest :%d %d\\n&quot;, a, b); }int testFunc2(int a, int b) { return a + b; }int testFunc3(Args args) { return args.a + args.b + args.c; }int main() { while (1) { testFunc1(1, 2); printf(&quot;%d\\n&quot;, testFunc2(3, 4)); printf(&quot;%d\\n&quot;, testFunc3({1, 2, 3})); printf(&quot;next trigger after 5s\\n&quot;); sleep(5); } return 0;} 关于hook地址获取不是很清楚linux内核的开发者是怎么想的，uprobe接受的偏移是目标地址相对其所在段起点的偏移再加上所在段的偏移值，而不是相对其所在二进制文件起点的偏移，通常就是理解为相对.text段起点的偏移加上maps中读取到的text段的偏移值如下图所示，权限掩码带x的段就是可执行的段，我们在ida里看到的是这样的这里.plt和.text在运行时被合并了，不过这个不重要，我们的目标函数如下图所示，显然是在.text段里的，然后0x1830这个地址，是base为0的情况下，相对二进制文件起始位置的偏移，也就是我们在frida等框架中使用的函数地址，在uprobe中不能直接传这个地址，在运行时，前面长度总计0x730的其他段会因为对齐变为长0x1000，然后经过计算，实际上要传入的地址应该是0x830（因为读取到的段偏移值为00000），也就是 目标实际地址(相对文件起点的偏移+基址)-所在段的基地址+所在段的偏移值显然这一坨不可能每次手算然后硬编码，我们用一个函数把反编译工具中获取的偏移值转换为uprobe认可的偏移值 12345678910111213141516171819202122232425262728293031size_t getFunctionOffsetReal(const char *soName, size_t staticOffset, int pid) { char path[256]; snprintf(path, sizeof(path), &quot;/proc/%d/maps&quot;, pid); // 读取maps获得内存布局 FILE *fp = fopen(path, &quot;r&quot;); if (!fp) { perror(&quot;fopen&quot;); return -1; } size_t start, end, base, inode, imageBase = -1; char buf[5], dn[6], filePath[256]; bool found = 0; while (fscanf(fp, &quot;%zx-%zx %s %zx %s %lu %s\\n&quot;, &amp;start, &amp;end, buf, &amp;base, dn, &amp;inode, filePath) == 7) { // 解析maps各字段，重点关注start,buf,base,filePath if (imageBase == -1 &amp;&amp; strstr(filePath, soName)) { // 这里采用匹配字串的方法，目标二进制文件第一次出现的段的起点肯定是这个二进制文件的基地址 imageBase = start; } if (buf[2] == 'x' &amp;&amp; strstr(filePath, soName) != nullptr) { //寻找可执行段，应该一个二进制文件在maps通常只有一个可执行段吧，大概，可能加上内存区间的校验会更保险一点(start&lt;=staticOffset+imageBase&lt;=end) printf(&quot;target excuteable segment found : %zx-%zx base: %zx file: %s\\n&quot;, start, end, base, filePath); found = 1; break; } } fclose(fp); if (!found) { printf(&quot;can't find %s in /proc/%d/maps\\n&quot;, soName, pid); return -1; } return imageBase + staticOffset - start + base; //根据我们的公式计算出正确地址} hookTestFunc11234567891011// probeSEC(&quot;uprobe&quot;)int BPF_UPROBE(hookTestFunc1, int a, int b) { bpf_printk(&quot;hookTestFunc1 called with args: %d, %d\\n&quot;, a, b); return 0;}// loadskel-&gt;links.hookTestFunc1 = bpf_program__attach_uprobe(skel-&gt;progs.hookTestFunc1, false, pid, std::format(&quot;/proc/{}/exe&quot;, pid).c_str(), getFunctionOffsetReal(&quot;test&quot;, 0x1830, pid)); uprobe也可以使用BPF_UPROBE宏,事实上这个宏就是BPF_KPROBE的别名(ebpf将uprobe和kprobe视为等价的)然后我们采用手动链接的方式（自动链接不能指定地址），注意这里hook可执行文件的话，我们的二进制文件要选/proc/pid/exe，这是对源文件的一个符号链接（快捷方式），这样我们就不用自己输入路径了，我们指定pid只hook测试文件，并设置uretprobe为false hookTestFunc21int testFunc2(int *a, int *b) { return *a + *b; } // 突然发现test2和test1一样，遂修改 12345678910111213SEC(&quot;uprobe&quot;)int BPF_UPROBE(hookTestFunc2, int *a, int *b) { int argA, argB; bpf_probe_read_user(&amp;argA, sizeof(int), a); bpf_probe_read_user(&amp;argB, sizeof(int), b); bpf_printk(&quot;hookTestFunc2 called with args: %d, %d\\n&quot;, argA, argB); return 0;}skel-&gt;links.hookTestFunc2 = bpf_program__attach_uprobe(skel-&gt;progs.hookTestFunc2, false, pid, std::format(&quot;/proc/{}/exe&quot;, pid).c_str(), getFunctionOffsetReal(&quot;test&quot;, 0x1864, pid)); 如果要从用户空间读内存，则需要使用bpf_probe_read_user，原因和上文的bpf_probe_read_kernel同理 hookTestFunc312345678910SEC(&quot;uretprobe&quot;)int BPF_URETPROBE(hookTestFunc3, int ret) { bpf_printk(&quot;hookTestFunc3 called with return value: %d\\n&quot;, ret); return 0;}skel-&gt;links.hookTestFunc3 = bpf_program__attach_uprobe(skel-&gt;progs.hookTestFunc3, true, pid, std::format(&quot;/proc/{}/exe&quot;, pid).c_str(), getFunctionOffsetReal(&quot;test&quot;, 0x1884, pid)); uretprobe直接在宏里定义返回值即可，libbpf会根据 调用约定 自动解析返回值对应的寄存器并读取到ret里这里就要设置uretprobe为true了，注意uretprobe只能设置在函数开头，然后会把函数return的地址替换成 蹦床 的地址（用于执行hook逻辑） 并保存原return地址，在执行完hook逻辑后跳回原执行流，因此uretprobe只能由return触发，灵活性要较差 insideFuncHook1234567891011SEC(&quot;uprobe&quot;)int BPF_UPROBE(insideFuncHook) { bpf_printk(&quot;insideFuncHook called\\n&quot;); bpf_printk(&quot;w8 = %lld ,w9 = %lld&quot;, ctx-&gt;regs[8], ctx-&gt;regs[9]); return 0;}skel-&gt;links.insideFuncHook = bpf_program__attach_uprobe(skel-&gt;progs.insideFuncHook, false, pid, std::format(&quot;/proc/{}/exe&quot;, pid).c_str(), getFunctionOffsetReal(&quot;test&quot;, 0x1878, pid)); 这里我们想读w8和w9寄存器的值，直接在对应位置hook然后读取ctx里regs[8]和regs[9]即可 modifyArgProbe1234567891011121314151617SEC(&quot;uprobe&quot;)int BPF_UPROBE(modifyArgProbe) { bpf_printk(&quot;modify args...&quot;); int valueToWrite = 114514; bpf_probe_write_user((void *)(ctx-&gt;sp + 12), (void *)&amp;valueToWrite, sizeof(int)); valueToWrite = 1919810; bpf_probe_write_user((void *)(ctx-&gt;sp + 8), (void *)&amp;valueToWrite, sizeof(int)); return 0;}char _license[] SEC(&quot;license&quot;) = &quot;GPL&quot;;skel-&gt;links.modifyArgProbe = bpf_program__attach_uprobe(skel-&gt;progs.modifyArgProbe, false, pid, std::format(&quot;/proc/{}/exe&quot;, pid).c_str(), getFunctionOffsetReal(&quot;test&quot;, 0x1870, pid)); 注意到对uprobe来说寄存器是只读的，所以如果参数通过寄存器传递，我们没办法直接替换参数，只能通过这种修改栈变量的方式简介修改参数，操作性比较差 运行情况 几点不足uprobe最大的问题是没法修改寄存器，导致其很难影响用户空间的行为，同时uretprobe虽然可以通过bpf_override_return替换返回值，但前提是内核开启了CONFIG_KPROBE_OVERRIDE，而pixel 6的内核是未开启的，必须得重编译，如此下来用uprobe做拦截操作就非常不优雅，stackplz的解决方案是联动frida使用ipc调用来干涉用户空间，个人也认为联动frida或者集成ptrace做修改操作会比较好，而且集成ptrace可以在需要修改时才附加ptrace，可以同时发挥uprobe的隐蔽性和ptrace的修改能力 TracepointtracepointTracepoint其实没啥好说的，就是内核预埋的一些检测点，内核支持的Tracepoint全部在/sys/kernel/tracing/events目录下了，对应的区段名为SEC(tp/catalog/name)，比如sys_enter对应的就是SEC(tp/raw_syscalls/sys_enter)，对应事件目录下的format文件描述了这个检测点获取的参数列表对逆向分析而言我们主要关注raw_syscalls，里面的sys_enter和sys_exit是所有libc函数调用syscall时都到经过的 12345678910111213oriole:/sys/kernel/tracing # cat events/raw_syscalls/sys_enter/formatname: sys_enterID: 23format: field:unsigned short common_type; offset:0; size:2; signed:0; field:unsigned char common_flags; offset:2; size:1; signed:0; field:unsigned char common_preempt_count; offset:3; size:1; signed:0; field:int common_pid; offset:4; size:4; signed:1; field:long id; offset:8; size:8; signed:1; field:unsigned long args[6]; offset:16; size:48; signed:0;print fmt: &quot;NR %ld (%lx, %lx, %lx, %lx, %lx, %lx)&quot;, REC-&gt;id, REC-&gt;args[0], REC-&gt;args[1], REC-&gt;args[2], REC-&gt;args[3], REC-&gt;args[4], REC-&gt;args[5] 123456789101112name: sys_exitID: 24format: field:unsigned short common_type; offset:0; size:2; signed:0; field:unsigned char common_flags; offset:2; size:1; signed:0; field:unsigned char common_preempt_count; offset:3; size:1; signed:0; field:int common_pid; offset:4; size:4; signed:1; field:long id; offset:8; size:8; signed:1; field:long ret; offset:16; size:8; signed:1;print fmt: &quot;NR %ld = %ld&quot;, REC-&gt;id, REC-&gt;ret 这里重点关注id,args,ret即可，这里其实就是svc指令 123456789101112131415161718192021222324#include &quot;vmlinux.h&quot;#include &lt;bpf/bpf_core_read.h&gt;#include &lt;bpf/bpf_helpers.h&gt;#include &lt;bpf/bpf_tracing.h&gt;SEC(&quot;tp/raw_syscalls/sys_enter&quot;)int handle_sys_enter(struct trace_event_raw_sys_enter *args) { int id = args-&gt;id; // unsigned long callArgs[6]; // bpf_probe_read_kernel(callArgs, sizeof(callArgs), // (void *)BPF_CORE_READ(args, args)); bpf_printk(&quot;sys_enter: id=%d, pid=%d\\n&quot;, id, bpf_get_current_pid_tgid() &gt;&gt; 32); return 0;}SEC(&quot;tp/raw_syscalls/sys_exit&quot;)int handle_sys_exit(struct trace_event_raw_sys_exit *args) { int id = args-&gt;id; long ret = args-&gt;ret; bpf_printk(&quot;sys_exit: id=%d, pid=%d, ret=%ld\\n&quot;, id, bpf_get_current_pid_tgid() &gt;&gt; 32, ret); return 0;}char _license[] SEC(&quot;license&quot;) = &quot;GPL&quot;; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// SPDX-License-Identifier: (LGPL-2.1 OR BSD-2-Clause)/* Copyright (c) 2021 Sartura * Based on minimal.c by Facebook */#include &quot;bpf_test.skel.h&quot;#include &lt;bpf/libbpf.h&gt;#include &lt;cerrno&gt;#include &lt;csignal&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;format&gt;#include &lt;sys/resource.h&gt;#include &lt;unistd.h&gt;static int libbpf_print_fn(enum libbpf_print_level level, const char *format, va_list args) { return vfprintf(stderr, format, args);}int main(int argc, char **argv) { // if (argc != 2) { // printf(&quot;need exact one pid\\n&quot;); // return 1; // } // int pid = atoi(argv[1]); struct bpf_test_bpf *skel; int err; /* Set up libbpf errors and debug info callback */ libbpf_set_print(libbpf_print_fn); /* Open load and verify BPF application */ skel = bpf_test_bpf__open_and_load(); if (!skel) { fprintf(stderr, &quot;Failed to open BPF skeleton\\n&quot;); return 1; } err = bpf_test_bpf__attach(skel); if (err) { fprintf(stderr, &quot;Failed to attach BPF skeleton\\n&quot;); goto cleanup; } printf(&quot;while 1 \\n&quot;); while (1) ;cleanup: bpf_test_bpf__destroy(skel); return -err;} 之前的格式表中的前8个字节的common_字段是不能直接读的，要用bpf_read_kernel或BPF_CORE_READ读，下面的字段都是可以直接读取的运行可以发现调用了101,64两个调用号，查表发现是nanosleep , write，符合我们的预期，之后根据不同调用号写case解析数据就可以实现stackplz相同的监控功能 btf_raw_tracepointbtf_raw_tracepoint是相对tracepoint更加原始的检测点，使用的内存段是SEC(tp_btf/name)，btf_raw_tracepoint和raw_tracepoint类似，访问的都是调用的原始参数，即直接返回调用号和寄存器信息pt_regs，而不是类似tracepoint的返回整理过的参数结构体，好处是通过raw_tracepoint可以获取全部的寄存器信息而不只是前6个，btf_的意思是使用btf类型增强兼容性，在应用中通常使用btf_raw_tracepoint 1234567891011121314#include &quot;vmlinux.h&quot;#include &lt;bpf/bpf_helpers.h&gt;SEC(&quot;tp_btf/sys_enter&quot;)int handle_enter(u64 *ctx) { long int syscall_id = ctx[1]; struct pt_regs *regs = (struct pt_regs *)ctx[0]; if (syscall_id == 0x40) { // write bpf_printk(&quot;%s %d\\n&quot;, regs-&gt;regs[1], regs-&gt;regs[2]); } return 0;}char _license[] SEC(&quot;license&quot;) = &quot;GPL&quot;; 上述就是一个简单的监测write的demo，其中ctx[0]是上下文信息(寄存器)，ctx[1]是调用号，具体的参数需要自己查syscall表，arm64的write的话就是x0是fd，x1是buf，x2是len; Syscall如果内核开启了CONFIG_FTRACE_SYSCALLS的话就可以使用，使用方法是SEC(tp/syscall/name)宏，大部分手机的原厂镜像应该是不支持的 fentry/fexit如果内核支持fentry可以使用，和kprobe语法类似，SEC(fentry/name)，与kprobe不同的是fentry/fexit对每个内核函数提供了参数结构体，可以直接使用Args-&gt;fieldname的方法访问参数 pre — next","link":"/ctf/ebpf/ebpf0x2/"},{"title":"连接用户与内核 -  ebpf之ringBuffer与全局变量","text":"还在用perf Buffer? ringBuffer真王朝了 内核态向用户态的通信在前面两篇文章的demo中，我们通过bpf_printk输出采集到的数据，但bpf_printk有几点不便，一是其不支持超过5个的格式化参数，二是其只能往trace_pipe流输出数据，在查看时不方便，因此一种更可行的方式是将ebpf内核态程序采集到的数据传输到用户态空间，然后主要在用户态对这些数据进行处理和输出，在linux5.8以前，这项工作主要由perf Buffer实现，从linux5.8开始，内核引入ringBuffer数据结构，后者在多数情况下被证明是从内核向用户态传输数据的最佳选择 此外就是我们也希望从用户态向内核态传递一些配置参数，比如针对pid进行采集进程过滤，针对这种少量的数据我们可以通过内核态全局变量传递 什么是ringBuffer引用bpf-developer-tutorial中对ringBuffer特性的描述(这也是一套非常好的ebpf开发教程) 123456789101112131415161718### eBPF ringbuf vs eBPF perfbuf只要 BPF 程序需要将收集到的数据发送到用户空间进行后处理和记录，它通常会使用 BPF perf buffer（perfbuf）来实现。Perfbuf 是每个CPU循环缓冲区的集合，它允许在内核和用户空间之间有效地交换数据。它在实践中效果很好，但由于其按CPU设计，它有两个主要的缺点，在实践中被证明是不方便的：内存的低效使用和事件的重新排序。为了解决这些问题，从Linux 5.8开始，BPF提供了一个新的BPF数据结构（BPF map）。BPF环形缓冲区（ringbuf）。它是一个多生产者、单消费者（MPSC）队列，可以同时在多个CPU上安全共享。BPF ringbuf 支持来自 BPF perfbuf 的熟悉的功能:- 变长的数据记录。- 能够通过内存映射区域有效地从用户空间读取数据，而不需要额外的内存拷贝和/或进入内核的系统调用。- 既支持epoll通知，又能以绝对最小的延迟进行忙环操作。同时，BPF ringbuf解决了BPF perfbuf的以下问题:- 内存开销。- 数据排序。- 浪费的工作和额外的数据复制。 总的来说，可以将其理解为一块内核和用户的共享空间，可以借助其进行一些数据交换 如何使用声明Rbringbuf属于BPF_MAP，通常通过匿名结构体的形式定义在.maps段中 123456const int PAGESIZE = 4096;struct { __uint(type, BPF_MAP_TYPE_RINGBUF); __uint(max_entries, PAGESIZE * 16);} ringbuf_map SEC(&quot;.maps&quot;); 这里使用btf宏进行定义，这是一种推荐的写法。我们指定type为BPF_MAP_TYPE_RINGBUF，然后设置max_entries（对于ringbuf而言就是缓冲区大小）根据ebpf.io的说明，max_entries必须设置为页对齐的，且大小必须是2的幂，这里就设置为4kb * 16的大小，实际使用过程中注意别设置太小导致缓冲区爆掉就行 分配空间1234567struct mydata { // 这里我们把要传输的数据打包到一个结构体中 char buf[256]; int pid; int syscallID;};struct mydata *data;data = (struct mydata *)bpf_ringbuf_reserve(&amp;ringbuf_map,sizeof(struct mydata), 0); 通过bpf_ringbuf_reserve从我们声明的ringbuf中分配一块空间用于存储准备传输的数据然后就正常的把数据写入这个data即可，最后通过bpf_ringbuf_submit提交数据，提交时选择的flag有发送通知信号，不发送通知信号和自主决定是否发送信号(flag=0)三种，根据情况选择即可，完整的探针代码如下 1234567891011121314151617181920212223242526272829303132333435const int PAGESIZE = 4096;struct { __uint(type, BPF_MAP_TYPE_RINGBUF); __uint(max_entries, PAGESIZE * 16);} ringbuf_map SEC(&quot;.maps&quot;);volatile int targetPid = 0;SEC(&quot;tp/raw_syscalls/sys_enter&quot;)int handle_sys_enter(struct trace_event_raw_sys_enter *args) { int id = args-&gt;id; struct mydata *data; if (bpf_get_current_pid_tgid() &gt;&gt; 32 != targetPid) { return 0; } data = (struct mydata *)bpf_ringbuf_reserve(&amp;ringbuf_map, sizeof(struct mydata), 0); if (!data) { bpf_printk(&quot;Failed to reserve space in ring buffer\\n&quot;); return 0; } data-&gt;pid = bpf_get_current_pid_tgid() &gt;&gt; 32; data-&gt;syscallID = id; bpf_printk(&quot;sys_enter: id=%d, pid=%d\\n&quot;, id, bpf_get_current_pid_tgid() &gt;&gt; 32); char buf[256]; bpf_probe_read_user_str(buf, sizeof(buf), (void *)(args-&gt;args[1])); if (id == 0x40) { __builtin_memcpy(data-&gt;buf, buf, sizeof(data-&gt;buf)); bpf_printk(&quot;count: %d&quot;, args-&gt;args[2]); bpf_printk(&quot;write : %s&quot;, buf); } bpf_ringbuf_submit(data, 0); return 0;} 接收数据12345678910111213141516int rbHandle(void *ctx, void *data, unsigned long dataSize) { const struct mydata *mydata = (struct mydata *)data; if (mydata-&gt;syscallID == 0x40) { printf(&quot;write information to rb: pid=%d, buf=%s \\n&quot;, mydata-&gt;pid, mydata-&gt;buf); } else { printf(&quot;other syscall : id=%d, pid=%d \\n&quot;, mydata-&gt;syscallID, mydata-&gt;pid); } return 0;}struct ring_buffer *rb;rb = ring_buffer__new(bpf_map__fd(skel-&gt;maps.ringbuf_map), rbHandle, NULL, NULL);while (1) { ring_buffer__poll(rb, -1);} 在用户侧程序中，我们通过ring_buffer__new在用户态空间同样声明rb，然后绑定rbHandle作为回调，之后轮询ring_buffer__poll不断获取数据，这里回调的的第一个参数是上下文，第二个参数是数据结构体，第三个参数是数据大小ring_buffer__poll是一种带超时的阻塞式轮询方法，会对获取的每一个数据触发回调，适合简单的demo 通过全局变量传递配置数据注意到上文中在内核侧程序中声明了一个全局变量targetPid用于指定pid过滤设置 1volatile int targetPid = 0; 我们直接在skel加载后向这个变量赋值即可传递数据，这个等价于直接往内核态程序对应的内存位置写数据 12skel = bpf_test_bpf__open_and_load();skel-&gt;bss-&gt;targetPid = atoi(argv[1]); // 全局变量在bss段 这样我们就不用每次都去trace_pipe里看输出了，而且对数据处理的自由度也更高 完整demo代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &quot;mydata.h&quot;#include &quot;vmlinux.h&quot;#include &lt;bpf/bpf_core_read.h&gt;#include &lt;bpf/bpf_helpers.h&gt;#include &lt;bpf/bpf_tracing.h&gt;const int PAGESIZE = 4096;struct { __uint(type, BPF_MAP_TYPE_RINGBUF); __uint(max_entries, PAGESIZE * 16);} ringbuf_map SEC(&quot;.maps&quot;);volatile int targetPid = 0;SEC(&quot;tp/raw_syscalls/sys_enter&quot;)int handle_sys_enter(struct trace_event_raw_sys_enter *args) { int id = args-&gt;id; struct mydata *data; if (bpf_get_current_pid_tgid() &gt;&gt; 32 != targetPid) { return 0; } data = (struct mydata *)bpf_ringbuf_reserve(&amp;ringbuf_map, sizeof(struct mydata), 0); if (!data) { bpf_printk(&quot;Failed to reserve space in ring buffer\\n&quot;); return 0; } data-&gt;pid = bpf_get_current_pid_tgid() &gt;&gt; 32; data-&gt;syscallID = id; bpf_printk(&quot;sys_enter: id=%d, pid=%d\\n&quot;, id, bpf_get_current_pid_tgid() &gt;&gt; 32); char buf[256]; bpf_probe_read_user_str(buf, sizeof(buf), (void *)(args-&gt;args[1])); if (id == 0x40) { __builtin_memcpy(data-&gt;buf, buf, sizeof(data-&gt;buf)); bpf_printk(&quot;count: %d&quot;, args-&gt;args[2]); bpf_printk(&quot;write : %s&quot;, buf); } bpf_ringbuf_submit(data, 0); return 0;}SEC(&quot;tp/raw_syscalls/sys_exit&quot;)int handle_sys_exit(struct trace_event_raw_sys_exit *args) { int id = args-&gt;id; long ret = args-&gt;ret; bpf_printk(&quot;sys_exit: id=%d, pid=%d, ret=%ld\\n&quot;, id, bpf_get_current_pid_tgid() &gt;&gt; 32, ret); return 0;}char _license[] SEC(&quot;license&quot;) = &quot;GPL&quot;; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465// SPDX-License-Identifier: (LGPL-2.1 OR BSD-2-Clause)/* Copyright (c) 2021 Sartura * Based on minimal.c by Facebook */#include &quot;bpf_test.skel.h&quot;#include &quot;mydata.h&quot;#include &lt;bpf/libbpf.h&gt;#include &lt;cerrno&gt;#include &lt;csignal&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;format&gt;#include &lt;sys/resource.h&gt;#include &lt;unistd.h&gt;static int libbpf_print_fn(enum libbpf_print_level level, const char *format, va_list args) { return vfprintf(stderr, format, args);}int rbHandle(void *ctx, void *data, unsigned long dataSize) { const struct mydata *mydata = (struct mydata *)data; if (mydata-&gt;syscallID == 0x40) { printf(&quot;write information to rb: pid=%d, buf=%s \\n&quot;, mydata-&gt;pid, mydata-&gt;buf); } else { printf(&quot;other syscall : id=%d, pid=%d \\n&quot;, mydata-&gt;syscallID, mydata-&gt;pid); } return 0;}int main(int argc, char **argv) { struct bpf_test_bpf *skel; struct ring_buffer *rb; int err; if (argc != 2) { printf(&quot;need exact one pid&quot;); return 0; } /* Set up libbpf errors and debug info callback */ libbpf_set_print(libbpf_print_fn); /* Open load and verify BPF application */ skel = bpf_test_bpf__open_and_load(); skel-&gt;bss-&gt;targetPid = atoi(argv[1]); if (!skel) { fprintf(stderr, &quot;Failed to open BPF skeleton\\n&quot;); return 1; } err = bpf_test_bpf__attach(skel); if (err) { fprintf(stderr, &quot;Failed to attach BPF skeleton\\n&quot;); goto cleanup; } rb = ring_buffer__new(bpf_map__fd(skel-&gt;maps.ringbuf_map), rbHandle, NULL, NULL); if (!rb) { fprintf(stderr, &quot;Failed to create ring buffer\\n&quot;); goto cleanup; } printf(&quot;while 1 \\n&quot;); while (1) { ring_buffer__poll(rb, -1); }cleanup: bpf_test_bpf__destroy(skel); ring_buffer__free(rb); return -err;} pre — next","link":"/ctf/ebpf/ebpf0x3/"},{"title":"AES","text":"简介AES是在DES被证明不安全后出现的加密算法，是经典的块加密算法，可以使用128bit,192bit,256bit三种长度的密钥，数据块长度固定为128bit(16字节)，整个加密过程在一个4*4的矩阵中进行，AES加密基于代换-置换网络，主要操作有轮密钥加，字节代换，行位移，列混合四种，其中数值运算相关的操作都是定义在$GF(2^8)$这个有限域下的（可以理解为为了防止溢出损失信息），对于有限域下的数值计算如何处理会在实现中说明,AES的运算采用 大端序 特征以AES128为例，在主循环中会依次执行字节代换，行位移，列混合，轮密钥加四个操作共9轮，第十轮不进行列混合操作，不过这个因为编译器会把加密操作优化的面目全非所以不一定看得出来其次是S盒，AES有一个256位的S盒用于进行字节代换操作标准S盒如下 12345678910111213141516const uint8_t S[16][16] = {0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76, 0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0, 0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15, 0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75, 0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84, 0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b, 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf, 0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8, 0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2, 0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73, 0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb, 0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79, 0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08, 0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a, 0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e, 0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf, 0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16}; 以及十个轮常量用于参与密钥拓展算法标准轮常量如下 12345const uint32_t Rcon[10] = {0x01000000, 0x02000000, 0x04000000, 0x08000000, 0x10000000, 0x20000000, 0x40000000, 0x80000000, 0x1b000000, 0x36000000}; 实现AES首先进行密钥拓展，AES的密钥由原本128位密钥组成的4个uint32_t为基础，拓展出10轮，总计44个共11组密钥因为加密是在4*4矩阵上进行操作，且矩阵是列优先排列的，所以先将密文按块转化为矩阵，加密完成后在转换回去 $s_0$ $s_1$ $s_2$ … $s_{14}$ $s_{15}$ 转换后变为： $s_0$ $s_4$ $s_8$ $s_{12}$ $s_1$ $s_5$ $s_9$ $s_{13}$ $s_2$ $s_6$ $s_{10}$ $s_{14}$ $s_3$ $s_7$ $s_{11}$ $s_{15}$ 一开始先进行初始密钥加操作，然后循环9轮，最后再进行第十轮，第十轮中不进行列混合 1234567891011121314151617181920212223242526272829303132void convertToStateArray(uint8_t s[16], uint8_t a[4][4]){ for (int i = 0; i &lt; 4; i++) { for (int j = 0; j &lt; 4; j++) { a[j][i] = s[i * 4 + j]; } }}void AES(uint8_t *message, uint64_t messageLen, uint8_t *key){ extendKey(key); uint8_t sArray[4][4]; for (int i = 0; i &lt; messageLen; i += 16) { convertToStateArray(message + i, sArray); // 转换为状态矩阵 addRoundKey(sArray, 0); // 初始轮密钥加 for (int j = 1; j &lt; 10; j++) // 1~9 { subbytes(sArray); // 字节代换 shiftRows(sArray); // 行移位 columnMix(sArray); // 列混合 addRoundKey(sArray, j); // 轮密钥加 } subbytes(sArray); shiftRows(sArray); addRoundKey(sArray, 10); // 最终轮密钥加 convertToStr(sArray, message + i); // 转换回字符串 }} 字节拓展操作首先把密钥按大端序转换为32位字$W_0$ ~ $W_3$，然后按照以下规则进行拓展出$W_4$ ~ $W_{43}$：$$W_i =\\begin{cases}W_{i-4} \\oplus T(W_{i-1}), &amp; \\text{if } i \\bmod 4 = 0 \\W_{i-4} \\oplus W_{i-1}, &amp; \\text{otherwise}\\end{cases}$$ 其中T是密钥拓展使用的轮函数，由字节偏移，字节代换，轮常量异或三个操作组成 123456789101112131415161718192021222324252627282930uint32_t T(uint32_t w, int round){ w = (w &gt;&gt; 24) | (w &lt;&lt; 8); // 字节偏移，循环左移一字节 uint8_t temp[4]; convertToWordArray(w, temp); // 转换为字节数组 for (int i = 0; i &lt; 4; i++) { temp[i] = S[temp[i] &gt;&gt; 4][temp[i] &amp; 0x0F]; // 字节代换 } w = convertToWord(temp); w ^= Rcon[round]; // 轮常量异或 return w;}void extendKey(uint8_t *key){ for (int i = 0; i &lt; 4; i++) { w[i] = getBigEndian(key + i * 4); // 转大端序 } for (int i = 4, j = 0; i &lt; 44; i++) // 密钥拓展 { if (i % 4 == 0) { w[i] = w[i - 4] ^ T(w[i - 1], j); j++; } else w[i] = w[i - 4] ^ w[i - 1]; }} 轮密钥加操作就是将当前轮对应的密钥与数据进行异或，因为在$GF(2^8)$下的加法与异或等价 123456789101112void addRoundKey(uint8_t sArray[4][4], int round) // 轮密钥加{ uint8_t wArray[4]; for (int i = 0; i &lt; 4; i++) { convertToWordArray(w[round * 4 + i], wArray); // 转换为字节数组 for (int j = 0; j &lt; 4; j++) { sArray[j][i] ^= wArray[j]; // 异或操作 } }} 行位移操作就是把整个矩阵第一行不动，第二行循环左移1位，第三行2位，第四行3位，可以直接模拟 1234567891011121314151617181920212223242526void shiftRows(uint8_t sArray[4][4]){ // 第0行不移位 // 第1行左移1位 uint8_t temp = sArray[1][0]; sArray[1][0] = sArray[1][1]; sArray[1][1] = sArray[1][2]; sArray[1][2] = sArray[1][3]; sArray[1][3] = temp; // 第2行左移2位 uint8_t temp1 = sArray[2][0]; uint8_t temp2 = sArray[2][1]; sArray[2][0] = sArray[2][2]; sArray[2][1] = sArray[2][3]; sArray[2][2] = temp1; sArray[2][3] = temp2; // 第3行左移3位 temp = sArray[3][0]; sArray[3][0] = sArray[3][3]; sArray[3][3] = sArray[3][2]; sArray[3][2] = sArray[3][1]; sArray[3][1] = temp;} 字节代换操作就是将矩阵中一个字节的高4位作为行号，低四位作为列号在S盒中查表 123456void subbytes(uint8_t sArray[4][4]){ for (int i = 0; i &lt; 4; i++) for (int j = 0; j &lt; 4; j++) sArray[i][j] = S[sArray[i][j] &gt;&gt; 4][sArray[i][j] &amp; 0x0F]; // 字节代换} 列混合操作是使用一个事先准备好的4*4矩阵和当前矩阵进行矩阵乘法，GF(2^8)下的乘法满足交换律，结合律和分配律，且与二相乘可以等价于如下操作：1.左移一位2.如果左移前最高位为1，则与0x1B异或所以只要实现乘二就能实现所有情况下的乘法 12345678910111213141516171819202122232425262728293031323334353637383940414243uint8_t GFMul(uint8_t s, int n){ if (n == 1) { return s; } if (n == 2) { uint8_t result = s &lt;&lt; 1; if (s &amp; 0x80) { result = result ^ 0x1b; } return result; } if (n % 2 == 0) return GFMul(GFMul(s, n / 2), 2); else return GFMul(s, n - 1) ^ s;}const uint8_t colM[4][4] = {2, 3, 1, 1, 1, 2, 3, 1, 1, 1, 2, 3, 3, 1, 1, 2}; void columnMix(uint8_t sArray[4][4]){ uint8_t tempArray[4][4]; for (int i = 0; i &lt; 4; i++) for (int j = 0; j &lt; 4; j++) tempArray[i][j] = sArray[i][j]; for (int j = 0; j &lt; 4; j++) { for (int i = 0; i &lt; 4; i++) { sArray[i][j] = GFMul(tempArray[0][j], colM[i][0]) ^ GFMul(tempArray[1][j], colM[i][1]) ^ GFMul(tempArray[2][j], colM[i][2]) ^ GFMul(tempArray[3][j], colM[i][3]); } }} 最后整个流程的图示如下所示 加密完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209#include &lt;bits/stdc++.h&gt;using namespace std;int w[44];uint32_t getBigEndian(uint8_t a[4]){ uint32_t res = 0; res = (a[0] &lt;&lt; 24) | (a[1] &lt;&lt; 16) | (a[2] &lt;&lt; 8) | a[3]; return res;}void convertToStateArray(uint8_t s[16], uint8_t a[4][4]){ for (int i = 0; i &lt; 4; i++) { for (int j = 0; j &lt; 4; j++) { a[j][i] = s[i * 4 + j]; } }}void convertToStr(uint8_t a[4][4], uint8_t s[16]){ for (int i = 0; i &lt; 4; i++) for (int j = 0; j &lt; 4; j++) s[i * 4 + j] = a[j][i];}void convertToWordArray(uint32_t W, uint8_t w[4]){ w[0] = (W &gt;&gt; 24) &amp; 0xFF; w[1] = (W &gt;&gt; 16) &amp; 0xFF; w[2] = (W &gt;&gt; 8) &amp; 0xFF; w[3] = W &amp; 0xFF;}uint32_t convertToWord(uint8_t w[4]){ uint32_t res = 0; res = (w[0] &lt;&lt; 24) | (w[1] &lt;&lt; 16) | (w[2] &lt;&lt; 8) | w[3]; return res;}const uint8_t S[16][16] = {0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76, 0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0, 0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15, 0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75, 0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84, 0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b, 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf, 0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8, 0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2, 0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73, 0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb, 0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79, 0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08, 0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a, 0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e, 0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf, 0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16};const uint32_t Rcon[10] = {0x01000000, 0x02000000, 0x04000000, 0x08000000, 0x10000000, 0x20000000, 0x40000000, 0x80000000, 0x1b000000, 0x36000000};uint32_t T(uint32_t w, int round){ w = (w &gt;&gt; 24) | (w &lt;&lt; 8); // 字节偏移，循环左移一字节 uint8_t temp[4]; convertToWordArray(w, temp); // 转换为字节数组 for (int i = 0; i &lt; 4; i++) { temp[i] = S[temp[i] &gt;&gt; 4][temp[i] &amp; 0x0F]; // 字节代换 } w = convertToWord(temp); w ^= Rcon[round]; // 轮常量异或 return w;}void extendKey(uint8_t *key){ for (int i = 0; i &lt; 4; i++) { w[i] = getBigEndian(key + i * 4); // 转大端序 } for (int i = 4, j = 0; i &lt; 44; i++) // 密钥拓展 { if (i % 4 == 0) { w[i] = w[i - 4] ^ T(w[i - 1], j); j++; } else w[i] = w[i - 4] ^ w[i - 1]; }}void addRoundKey(uint8_t sArray[4][4], int round) // 轮密钥加{ uint8_t wArray[4]; for (int i = 0; i &lt; 4; i++) { convertToWordArray(w[round * 4 + i], wArray); // 转换为字节数组 for (int j = 0; j &lt; 4; j++) { sArray[j][i] ^= wArray[j]; // 异或操作 } }}void subbytes(uint8_t sArray[4][4]){ for (int i = 0; i &lt; 4; i++) for (int j = 0; j &lt; 4; j++) sArray[i][j] = S[sArray[i][j] &gt;&gt; 4][sArray[i][j] &amp; 0x0F]; // 字节代换}void shiftRows(uint8_t sArray[4][4]){ // 第0行不移位 // 第1行左移1位 uint8_t temp = sArray[1][0]; sArray[1][0] = sArray[1][1]; sArray[1][1] = sArray[1][2]; sArray[1][2] = sArray[1][3]; sArray[1][3] = temp; // 第2行左移2位 uint8_t temp1 = sArray[2][0]; uint8_t temp2 = sArray[2][1]; sArray[2][0] = sArray[2][2]; sArray[2][1] = sArray[2][3]; sArray[2][2] = temp1; sArray[2][3] = temp2; // 第3行左移3位 temp = sArray[3][0]; sArray[3][0] = sArray[3][3]; sArray[3][3] = sArray[3][2]; sArray[3][2] = sArray[3][1]; sArray[3][1] = temp;}const uint8_t colM[4][4] = {2, 3, 1, 1, 1, 2, 3, 1, 1, 1, 2, 3, 3, 1, 1, 2};uint8_t GFMul(uint8_t s, int n){ if (n == 1) { return s; } if (n == 2) { uint8_t result = s &lt;&lt; 1; if (s &amp; 0x80) { result = result ^ 0x1b; } return result; } if (n % 2 == 0) return GFMul(GFMul(s, n / 2), 2); else return GFMul(s, n - 1) ^ s;}void columnMix(uint8_t sArray[4][4]){ uint8_t tempArray[4][4]; for (int i = 0; i &lt; 4; i++) for (int j = 0; j &lt; 4; j++) tempArray[i][j] = sArray[i][j]; for (int j = 0; j &lt; 4; j++) { for (int i = 0; i &lt; 4; i++) { sArray[i][j] = GFMul(tempArray[0][j], colM[i][0]) ^ GFMul(tempArray[1][j], colM[i][1]) ^ GFMul(tempArray[2][j], colM[i][2]) ^ GFMul(tempArray[3][j], colM[i][3]); } }}void AES(uint8_t *message, uint64_t messageLen, uint8_t *key){ extendKey(key); uint8_t sArray[4][4]; for (int i = 0; i &lt; messageLen; i += 16) { convertToStateArray(message + i, sArray); // 转换为状态矩阵 addRoundKey(sArray, 0); // 初始轮密钥加 for (int j = 1; j &lt; 10; j++) // 1~9 { subbytes(sArray); // 字节代换 shiftRows(sArray); // 行移位 columnMix(sArray); // 列混合 addRoundKey(sArray, j); // 轮密钥加 } subbytes(sArray); shiftRows(sArray); addRoundKey(sArray, 10); // 最终轮密钥加 convertToStr(sArray, message + i); // 转换回字符串 }}int main(){ char key[] = &quot;0123456789abcdef&quot;; char message[] = &quot;0123456789abcdef&quot;; AES((uint8_t *)message, strlen(message), (uint8_t *)key); for (int i = 0; i &lt; 16; i++) { printf(&quot;%02X &quot;, message[i] &amp; 0xFF); } return 0;} 解密因为是对称加密算法，AES的每一步操作都可以对其实现逆操作，只要把逆操作都实现出来然后按照加密的顺序反向执行就可以解密逆字节代换就是根据S盒可以准备一个反S盒，同样是查表替换 12345678910111213141516171819202122const uint8_t S2[16][16] = {0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb, 0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb, 0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e, 0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25, 0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92, 0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84, 0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06, 0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b, 0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73, 0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e, 0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b, 0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4, 0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f, 0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef, 0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61, 0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d};void deSubBytes(uint8_t sArray[4][4]){ for (int i = 0; i &lt; 4; i++) for (int j = 0; j &lt; 4; j++) sArray[i][j] = S2[sArray[i][j] &gt;&gt; 4][sArray[i][j] &amp; 0x0F]; // 字节代换} 逆行位移把循环左移改为循环右移 1234567891011121314151617181920212223242526void deShiftRows(uint8_t sArray[4][4]){ // 第0行不移位 // 第1行右移1位 uint8_t temp = sArray[1][3]; sArray[1][3] = sArray[1][2]; sArray[1][2] = sArray[1][1]; sArray[1][1] = sArray[1][0]; sArray[1][0] = temp; // 第2行右移2位 uint8_t temp1 = sArray[2][0]; uint8_t temp2 = sArray[2][1]; sArray[2][0] = sArray[2][2]; sArray[2][1] = sArray[2][3]; sArray[2][2] = temp1; sArray[2][3] = temp2; // 第3行右移3位 temp = sArray[3][0]; sArray[3][0] = sArray[3][1]; sArray[3][1] = sArray[3][2]; sArray[3][2] = sArray[3][3]; sArray[3][3] = temp;} 逆列混合因为是矩阵乘法，所以只要构造出colM的逆矩阵就行 1234567891011121314151617const uint8_t deColM[4][4] = {0xe, 0xb, 0xd, 0x9, 0x9, 0xe, 0xb, 0xd, 0xd, 0x9, 0xe, 0xb, 0xb, 0xd, 0x9, 0xe};void deMixColumns(uint8_t sArray[4][4]){ uint8_t tempArray[4][4]; for (int i = 0; i &lt; 4; i++) for (int j = 0; j &lt; 4; j++) tempArray[i][j] = sArray[i][j]; for (int j = 0; j &lt; 4; j++) for (int i = 0; i &lt; 4; i++) sArray[i][j] = GFMul(tempArray[0][j], deColM[i][0]) ^ GFMul(tempArray[1][j], deColM[i][1]) ^ GFMul(tempArray[2][j], deColM[i][2]) ^ GFMul(tempArray[3][j], deColM[i][3]);} 轮密钥加因为是异或，所以不用额外实现反向操作可以给出完整解密如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687const uint8_t S2[16][16] = {0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb, 0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb, 0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e, 0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25, 0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92, 0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84, 0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06, 0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b, 0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73, 0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e, 0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b, 0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4, 0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f, 0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef, 0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61, 0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d};void deSubBytes(uint8_t sArray[4][4]){ for (int i = 0; i &lt; 4; i++) for (int j = 0; j &lt; 4; j++) sArray[i][j] = S2[sArray[i][j] &gt;&gt; 4][sArray[i][j] &amp; 0x0F]; // 字节代换}void deShiftRows(uint8_t sArray[4][4]){ // 第0行不移位 // 第1行右移1位 uint8_t temp = sArray[1][3]; sArray[1][3] = sArray[1][2]; sArray[1][2] = sArray[1][1]; sArray[1][1] = sArray[1][0]; sArray[1][0] = temp; // 第2行右移2位 uint8_t temp1 = sArray[2][0]; uint8_t temp2 = sArray[2][1]; sArray[2][0] = sArray[2][2]; sArray[2][1] = sArray[2][3]; sArray[2][2] = temp1; sArray[2][3] = temp2; // 第3行右移3位 temp = sArray[3][0]; sArray[3][0] = sArray[3][1]; sArray[3][1] = sArray[3][2]; sArray[3][2] = sArray[3][3]; sArray[3][3] = temp;}const uint8_t deColM[4][4] = {0xe, 0xb, 0xd, 0x9, 0x9, 0xe, 0xb, 0xd, 0xd, 0x9, 0xe, 0xb, 0xb, 0xd, 0x9, 0xe};void deMixColumns(uint8_t sArray[4][4]){ uint8_t tempArray[4][4]; for (int i = 0; i &lt; 4; i++) for (int j = 0; j &lt; 4; j++) tempArray[i][j] = sArray[i][j]; for (int j = 0; j &lt; 4; j++) for (int i = 0; i &lt; 4; i++) sArray[i][j] = GFMul(tempArray[0][j], deColM[i][0]) ^ GFMul(tempArray[1][j], deColM[i][1]) ^ GFMul(tempArray[2][j], deColM[i][2]) ^ GFMul(tempArray[3][j], deColM[i][3]);}void AESdecrypt(uint8_t *message, uint64_t messageLen, uint8_t *key){ extendKey(key); uint8_t sArray[4][4]; for (int i = 0; i &lt; messageLen; i += 16) { convertToStateArray(message + i, sArray); // 转换为状态矩阵 addRoundKey(sArray, 10); // 初始轮密钥加 deShiftRows(sArray); // 行移位 deSubBytes(sArray); // 字节代换 for (int j = 9; j &gt;= 1; j--) { addRoundKey(sArray, j); // 轮密钥加 deMixColumns(sArray); // 列混合 deShiftRows(sArray); // 行移位 deSubBytes(sArray); // 字节代换 } addRoundKey(sArray, 0); // 最终轮密钥加 convertToStr(sArray, message + i); }} referenceAES-wikipedia 对称加密目录","link":"/ctf/%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86/AES/"},{"title":"栈数据的采集与使用 - ebpf番外篇之解析perf_event","text":"在研究stackplz的代码时发现其是用perf_event_open进行栈数据的采集，并且因为libbpf的perf_event_open并没有带上PERF_SAMPLE_STACK_USER标记所以还要修改libbpf代码，感觉总体实现并不是很好并且perf_buffer性能也不咋地，所以研究有无其他获取栈数据的方式 perf_event_open采集项开关根据linux syscall手册，perf_event返回的数据通过attr结构体中的一系列掩码决定,其中开启采集栈数据的就是PERF_SAMPLE_STACK_USER stackplz的解决方案stackplz是在libbpf调用perf_event_open时手动为掩码添加新采集项 perf_event_open如何获取栈数据既然bpf程序对用户内存有读取权限，不如考虑有没有直接把目标栈内存整个读下来的方案，先来看看perf_event_open是如何获取栈数据的可以看到这里只是注册了perf事件，触发事件的回调在perf_event_output这里关键的函数是perf_output_sample，负责把数据拷贝到目标缓冲区里根据对应开关我们找到perf_output_sample_ustack这个函数检查一下这个stack_user_size是怎么初始化的可以跟到perf_prepare_sample这个函数中，这样和前面的逻辑是对的上的这里通过perf_sample_ustack_size获取栈大小，可以看到用户传递的attr.stack_size只是参考，真正dump的大小要根据perf_sample_ustack_size得到这里进一步通过perf_ustack_task_size计算栈大小 这里perf_ustack_task_size是计算栈不从用户地址空间溢出的前提下的最大大小，然后和用户指定的大小取min，再和perf事件一次最多采样65535字节的限制取min，最后算出最多能采多少数据 这里先是提交了dump_size作为预期dump的大小，再通过__output_copy_user从sp开始拷贝栈数据，最后提交dyn_size作为实际拷贝成功的大小这里主要关注这个dyn_size是怎么计算出来的，因为unwindstack需要这个数据 这个__output_copy_user宏最后可以跟到__copy_from_user_inatomic这个函数 最后从raw_copy_from_user继续跟，就是内联汇编的代码了，这里真正执行了拷贝操作这里只找到了x86的代码，但估计arm的也是差不多的rep movsb指令是字符串复制指令，其行为是 从rsi读一个字节并写入rdi 递增rsi和rdi 递减rcx 循环直到rcx变为0 _ASM_EXTABLE_UA（1b,2b）是注册了一个异常处理事件，在内核访问用户内存发生异常时跳到2:处继续执行而不是崩溃 最后是把c变量绑定到寄存器，这里是把len绑定到rcx，把to绑定到rdi，把from绑定到rsi，其中to和from都只是储存，而len则是更新并储存，可以理解为len的值始终和rcx相同可以发现这里return的话返回的值就是还剩多少没拷贝（比如发生了页错误），和前面的stack_size相减算出了实际的dyn_size bpf_probe_read_user既然本质是从sp开始读数据，那没道理说直接拿bpf_probe_read_user读就不行，一个比较直接的思路是直接拿到stack段的基地址，然后和sp减一下算出来一段合法的区间，直接去读这段区间的内存，唯一的缺点是和内联汇编相比遇到错误整个读取都会失败 如何确定栈基址目前的思路是通过解析maps文件获取栈基址，属于栈内存的区段会有stack标记，具体规则是单独的[stack]属于主线程，[stack:xxxxx]是对应的子线程内存，[stack:main]不确定是什么东西，但查看了多个进程都发现这个段只有4kb(一个页)，估计不是很重要 效果采用了这个方案后在部分场景确实能正确获取栈数据，但是在追踪某社交平台app时还是出现了回溯截断现象，推测是在复杂场景中获取的内存数据有错误（毕竟是野路子，没错误处理，还直接从sp开始硬读），也可能是大型app的回溯本身就需要很多其他数据，后续如果想解析vdex符号还是直接上remote_unwinder吧，bpf侧只需要发送中断信号和读取寄存器数据就好了","link":"/ctf/ebpf/ebpf0x4.5/"},{"title":"顶不住了还是go吧 - ebpf-go框架之cilium-ebpf","text":"被libbpf交叉编译折磨烂了，具体来说就是libbpf只支持gnu/glibc，但是需要用到的unwindstack库又需要ndk-clang来提供很多安卓的api，两个实在没法编到一起，只能迁移到go然后把unwindstack以cgo动态库的形式加入到项目中 整体框架cilium-ebpf 是libbpf的go语言封装，用c写完bpf内核程序后，使用bpf2go工具将其转换为go框架代码，然后再使用go build将其嵌入到go语言用户程序中，剩下想加其他的功能就用c编成动态库之后挂在go程序下 构建脚本12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576TC:= /home/sgsg/ebpf/android-ndk-r27c/toolchains/llvm/prebuilt/linux-x86_64/binCC:=$(TC)/aarch64-linux-android35-clangCXX:=$(TC)/aarch64-linux-android35-clang++AR:=$(TC)/llvm-arAPP:=stackunwinder-gostack_src:= $(wildcard stack/*.cpp)ANDROID_SYSROOT:= $(TC)/../sysrootstack_LDPATH:= -L/home/sgsg/ebpf/libunwindstack/build -L/home/sgsg/ebpf/android-ndk-r27c/toolchains/llvm/prebuilt/linux-x86_64/sysroot/usr/libstack_LDFLAGS:= $(stack_LDPATH) -lunwindstack -lbase -ldexfile_stub -llzma -lprocinfo -lziparchive -llog -lzstack_INCLUDES:= -I$(ANDROID_SYSROOT)/usr/include/aarch64-linux-android -I$(ANDROID_SYSROOT)/usr/include -I/home/sgsg/ebpf/libunwindstack/libunwindstack/includestack_CXXFLAGS:= -std=c++20 -O2 -Wall -fPIC app: $(APP)stackHelp.so: $(stack_src) $(CXX) $(stack_CXXFLAGS) -shared -o $@ $^ $(stack_LDFLAGS) $(stack_INCLUDES).PHONY: cleanclean: rm -f stackHelp.so rm -f $(wildcard stackunwinder/probes__bpfel.*) rm -f $(APP) rm -f linker/libwrapper.a rm -f linker/wrapper.oBPF_CLANG:=$(TC)/aarch64-linux-android35-clangBPF_CFLAGS:=-O2 -g -target bpfBPF_SKEL:=stackunwinder/probes__bpfel.go$(BPF_SKEL): $(wildcard kernel/*.c) @echo &quot;=== Generating BPF Go bindings ===&quot; @echo &quot;Using BPF_CLANG: $(BPF_CLANG)&quot; @echo &quot;Using BPF_CFLAGS: $(BPF_CFLAGS)&quot; cd stackunwinder &amp;&amp; \\ BPF_CLANG=&quot;$(BPF_CLANG)&quot; \\ BPF_CFLAGS=&quot;$(BPF_CFLAGS)&quot; \\ go run github.com/cilium/ebpf/cmd/bpf2go \\ -go-package stackunwinder \\ -target bpfel \\ -cc &quot;$(BPF_CLANG)&quot; \\ -cflags &quot;$(BPF_CFLAGS)&quot; \\ -type sysEnterData \\ probes_ ../kernel/probes.c cd .. @echo &quot;=== BPF Go bindings generated successfully ===&quot;WRAPPER_CFLAGS:=-I./linker -O2 -c -g -Wall -fPIClinker/libwrapper.o: linker/wrapper.c linker/wrapper.h $(CC) $(WRAPPER_CFLAGS) -c linker/wrapper.c -o linker/wrapper.olinker/libwrapper.a: linker/wrapper.o $(AR) rcs $@ linker/wrapper.o$(APP): linker/libwrapper.a main.go $(BPF_SKEL) stackHelp.so @echo [include settings] $(stack_INCLUDES) @echo [ld settings] $(stack_LDFLAGS) CGO_ENABLED=1 \\ CC=$(CC) \\ CXX=$(CXX) \\ CGO_CFLAGS=&quot;-I./linker&quot; \\ CGO_LDFLAGS=&quot;-L./linker -lwrapper&quot; \\ GOOS=android \\ GOARCH=arm64 \\ go build -o $@ . cp $(APP) ..# CGO_CFLAGS=&quot;-I./linker&quot; # CGO_LDFLAGS=&quot;-L./linker&quot; 在安卓上运行这里GOOS要选android不然他会去链接pthread但是安卓的这玩意是集成到libc里的，然后不出所料cilium的系统检查会因为GOOS不是linux把程序拦下来（幽默），这里要去platform.go中把isLinux这个变量改了才行加上android这一项，然后就不会报平台不兼容错误了 这里几个目标的构建基本是独立的，这篇文章主要关注bpf探针的部分，下篇文章会将怎么添加栈回溯功能 生成bpf框架这里使用bpf2go生成框架，网上有不少教程是把命令写到go generate里，这里把它拆出来写在makefile里，基本大差不差 1234567go run github.com/cilium/ebpf/cmd/bpf2go \\-go-package stackunwinder \\-target bpfel \\-cc &quot;$(BPF_CLANG)&quot; \\-cflags &quot;$(BPF_CFLAGS)&quot; \\-type sysEnterData \\probes_ ../kernel/probes.c 这里cc和cflag字段就是指定生成bpf目标文件时使用的cc和cflag，然后go-package字段是指定生成的go框架文件的包名，target是指定目标的端序，默认是大小端序都生成一份，这里我们只编译安卓的版本所以指定小端序即可,然后type字段是告诉bpf2go哪些bpf程序中的c类型要生成go声明，否则我们在go用户程序中是用不了这些类型的，比如这里的sysEnterData 12345678struct sysEnterData { u64 regs[31], pc, sp; char stackData[16384]; uint64_t stackSize; u8 comm[32]; u8 argBuf[3][512]; u64 syscall_id;}; 然后probes_是指定的框架名称，这个和后续自动生成的bpf对象和一些框架函数的名称会有关 最后是指定源文件 probes.c 构建可执行文件1234567CC=$(CC) \\CXX=$(CXX) \\CGO_CFLAGS=&quot;-I./linker&quot; \\CGO_LDFLAGS=&quot;-L./linker -lwrapper&quot; \\GOOS=android \\GOARCH=arm64 \\go build -o $@ . 这里因为后续还要添加一些cgo的功能，所以制定了CC之类的，实际上只要指定GOOS,GOARCH这两项即可构建，bpf目标文件会自动被嵌入到go产物中 bpf探针代码bpf探针部分使用的仍然是libbpf的内容，和之前一样写即可 go用户程序go部分代码如下，这里和libbpf的内容其实非常类似，只不过换成了go语言，个人感觉cilium封装完的api相对更简单一点，但同时给用户的自由度也低一点 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117package stackunwinder// #include &quot;../linker/wrapper.h&quot;import &quot;C&quot;import ( &quot;bytes&quot; &quot;encoding/binary&quot; &quot;flag&quot; &quot;fmt&quot; &quot;log&quot; &quot;os&quot; &quot;path&quot; &quot;unsafe&quot; &quot;github.com/cilium/ebpf&quot; &quot;github.com/cilium/ebpf/link&quot; &quot;github.com/cilium/ebpf/ringbuf&quot; &quot;github.com/cilium/ebpf/rlimit&quot;)func initLibs(){ exe, _ := os.Executable() exeDir := path.Dir(exe) C.setupLibEnv(C.CString(exeDir)) // initialize the C library if isDebug{ C.test_CGO(12345)}}var ProbeObjs *probes_Objects=nilfunc Main(){ var( targetPid = flag.Uint(&quot;pid&quot;, 0, &quot;target pid&quot;) _isDebug = flag.Bool(&quot;d&quot;, false, &quot;enable debug mode&quot;) ) flag.Parse() setDebugMode(*_isDebug) initLibs() debug(&quot;target pid %d \\n&quot;, *targetPid) if err:=rlimit.RemoveMemlock(); err != nil { // remove kernel memory lock limit log.Fatal(err) } objs:=probes_Objects{} if err:=loadProbes_Objects(&amp;objs,nil); err != nil { log.Fatalf(&quot;loading objects: %v&quot;, err) } defer objs.Close() ProbeObjs=&amp;objs // save the probes objects globally objs.TargetPid.Set(uint32(*targetPid)) // set target pid in eBPF program debug(&quot;self pid: %d\\n&quot;, uint32(os.Getpid())) debug(&quot;bpf obj loaded\\n&quot;) sysEnterTp,err:=link.AttachTracing(link.TracingOptions{Program: objs.SysEnter,AttachType:ebpf.AttachTraceRawTp}) // attach to sys_enter if err!=nil{ log.Fatal(err) } defer sysEnterTp.Close() if isDebug{log.Printf(&quot;tp attached\\n&quot;)} sysEnterRb,err:=ringbuf.NewReader(objs.SysEnterRb) if(err!=nil){ log.Fatal() } defer sysEnterRb.Close() debug(&quot;sysEnter ringbuf reader created\\n&quot;) var sysEnterData probes_SysEnterData for{ data,err:=sysEnterRb.Read() if err!=nil{ log.Printf(&quot;reading err: %v&quot;, err) continue } if err:=binary.Read(bytes.NewBuffer(data.RawSample), binary.LittleEndian, &amp;sysEnterData); err != nil { log.Printf(&quot;reading event err: %v&quot;, err) continue } // log.Printf(&quot;pid: %d nr: %d\\n&quot;, sysEnterData.Pid, sysEnterData.SyscallId) switch sysEnterData.SyscallId { case getSyscallId(objs.OPENAT): fmt.Printf(&quot;pid: [%d] comm: [%s] openat: %s \\n&quot;,*targetPid, sysEnterData.Comm, sysEnterData.ArgBuf[0]) case getSyscallId(objs.READ): fmt.Printf(&quot;pid: [%d] comm: [%s] read: %s \\n&quot;,*targetPid, sysEnterData.Comm, sysEnterData.ArgBuf[0]) case getSyscallId(objs.WRITE): fmt.Printf(&quot;pid: [%d] comm: [%s] write: %s \\n&quot;,*targetPid, sysEnterData.Comm, sysEnterData.ArgBuf[0]) default: fmt.Printf(&quot;pid: [%d] comm: [%s] syscall %d\\n&quot;, *targetPid, sysEnterData.Comm, sysEnterData.SyscallId) } data,err=sysEnterRb.Read() if err!=nil { log.Printf(&quot;reading sysEnter err: %v&quot;, err) continue } if err:=binary.Read(bytes.NewBuffer(data.RawSample), binary.LittleEndian, &amp;sysEnterData); err != nil { log.Printf(&quot;reading sysEnterData err: %v&quot;, err) continue } debug(&quot;stacksize %d\\n&quot;,sysEnterData.StackSize) debug(&quot;pc %x\\n&quot;,sysEnterData.Pc) debug(&quot;sp %x\\n&quot;,sysEnterData.Sp) var tmp C.struct_Data for i := 0; i &lt; 31; i++ { tmp.regs[i] = C.uint64_t(sysEnterData.Regs[i]) } tmp.pc=C.uint64_t(sysEnterData.Pc) tmp.sp=C.uint64_t(sysEnterData.Sp) for i := range tmp.stackData { tmp.stackData[i] = C.char(sysEnterData.StackData[i]) } tmp.stackSize=C.uint64_t(sysEnterData.StackSize) C.unwind(C.int(*targetPid), (*C.struct_Data)(unsafe.Pointer(&amp;tmp))) }} 这里我们只关注基本的加载部分 12345objs:=probes_Objects{}if err:=loadProbes_Objects(&amp;objs,nil); err != nil { log.Fatalf(&quot;loading objects: %v&quot;, err)}defer objs.Close() 这里的probes就是和我们上面指定的框架名相关，我们初始化一个bpf框架对象，这个对象是我们和bpf对象交互的唯一途径，然后调用自动生产的load函数初始化这个框架 1objs.TargetPid.Set(uint32(*targetPid)) 这里是对bpf程序中的全局变量做设置，直接调用Set就行，注意到这里要严格保证go和c值的内存布局是相同的，否则会出问题 12345sysEnterTp,err:=link.AttachTracing(link.TracingOptions{Program: objs.SysEnter,AttachType:ebpf.AttachTraceRawTp}) // attach to sys_enterif err!=nil{ log.Fatal(err)}defer sysEnterTp.Close() 这里是链接到bpf程序，这里是一个btf_tp的例子，选择Tracing类型，然后把配置通过TracingOptions传进去 12345sysEnterRb,err:=ringbuf.NewReader(objs.SysEnterRb)if(err!=nil){ log.Fatal()}defer sysEnterRb.Close() 这里是初始化一个rb的reader，没啥好说的 123456789var sysEnterData probes_SysEnterDatadata,err:=sysEnterRb.Read()if err!=nil{ log.Printf(&quot;reading err: %v&quot;, err) continue}if err:=binary.Read(bytes.NewBuffer(data.RawSample), binary.LittleEndian, &amp;sysEnterData); err != nil {log.Printf(&quot;reading event err: %v&quot;, err)} ringbuf的reader读的是纯二进制数据，这里用binary库把读到的数据重新序列化成结构体 这里基本就这样了，下篇文章补充一下如何利用采集到的数据实现栈回溯","link":"/ctf/ebpf/ebpf0x4/"},{"title":"BASE64","text":"简介BASE64是目前最常见的编码算法，用于将二进制数据表示为可打印字符串，具体的转换方式由一个64个字符组成的查找表决定，但都是将三个字节（24bit）转换为4个字符（base64中一个字符可以表示6bit的状态，所以也是24bit） 特征base64主要的特征一个是输出的结果是大量乱七八糟的可打印字符串，事实上如果看到大量乱七八糟的字符串都可以怀疑是base系列，因为如果是其他加密算法基本上不会输出为可打印字符串另一个特征就是base64算法会带一个64个字符组成的查找表 实现主要是实现3个8bit对6个4bit的映射，编解码都差不多，下面三张wikipedia的图很好的解释了映射逻辑如果输入不是3的倍数就对缺的部分补padding，默认标准是补”=” 123456789101112131415161718192021222324252627string encode(string input){ string res = &quot;&quot;; for (size_t i = 0; i &lt; input.size(); i += 3) { uint32_t tmp = 0; int pad = 3; for (size_t j = i; j &lt; i + 3; j++) { if (j &lt; input.size()) { tmp = (tmp &lt;&lt; 8) | input[j]; pad--; } else tmp &lt;&lt;= 8; } for (int j = 0; j &lt; 4 - pad; j++) { uint32_t mask = (1 &lt;&lt; 6) - 1; res += base64Table[(tmp &gt;&gt; (6 * (3 - j))) &amp; mask]; } while (pad--) res += paddingCode; } return res;} 解码1234567891011121314151617181920212223string decode(string input) { string res = &quot;&quot;; for (size_t i = 0; i &lt; input.size(); i += 4) { uint32_t tmp = 0; int validChars = 0; for (size_t j = i; j &lt; i + 4 &amp;&amp; j &lt; input.size() &amp;&amp; input[j] != paddingCode; j++) { tmp = (tmp &lt;&lt; 6) | find(base64Table, input[j]); validChars++; } if (validChars &gt;= 2) { int shiftBits = (4 - validChars) * 6; tmp &lt;&lt;= shiftBits; res += (char)((tmp &gt;&gt; 16) &amp; 0xFF); if (validChars &gt;= 3) res += (char)((tmp &gt;&gt; 8) &amp; 0xFF); if (validChars &gt;= 4) res += (char)(tmp &amp; 0xFF); } } return res;} 完整代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;bits/stdc++.h&gt;using namespace std;string base64Table = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;;char paddingCode = '=';char find(string &amp;table, char ch){ for (size_t i = 0; i &lt; table.size(); i++) { if (table[i] == ch) return (char)i; } return -1;}string encode(string input){ string res = &quot;&quot;; for (size_t i = 0; i &lt; input.size(); i += 3) { uint32_t tmp = 0; int pad = 3; for (size_t j = i; j &lt; i + 3; j++) { if (j &lt; input.size()) { tmp = (tmp &lt;&lt; 8) | input[j]; pad--; } else tmp &lt;&lt;= 8; } for (int j = 0; j &lt; 4 - pad; j++) { uint32_t mask = (1 &lt;&lt; 6) - 1; res += base64Table[(tmp &gt;&gt; (6 * (3 - j))) &amp; mask]; } while (pad--) res += paddingCode; } return res;}string decode(string input) { string res = &quot;&quot;; for (size_t i = 0; i &lt; input.size(); i += 4) { uint32_t tmp = 0; int validChars = 0; for (size_t j = i; j &lt; i + 4 &amp;&amp; j &lt; input.size() &amp;&amp; input[j] != paddingCode; j++) { tmp = (tmp &lt;&lt; 6) | find(base64Table, input[j]); validChars++; } if (validChars &gt;= 2) { int shiftBits = (4 - validChars) * 6; tmp &lt;&lt;= shiftBits; res += (char)((tmp &gt;&gt; 16) &amp; 0xFF); if (validChars &gt;= 3) res += (char)((tmp &gt;&gt; 8) &amp; 0xFF); if (validChars &gt;= 4) res += (char)(tmp &amp; 0xFF); } } return res;}int main(){ string inputCode; getline(cin, inputCode); cout &lt;&lt; encode(inputCode) &lt;&lt; &quot;\\n&quot;; cout &lt;&lt; decode(encode(inputCode)); return 0;} referencewikipedia-base64 对称加密目录","link":"/ctf/%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86/BASE64/"},{"title":"RC4","text":"简介RC4是一种比较简单的流加密算法，流加密的特点是逐字节加密，相邻字节间相互独立RC4的密钥不能超过256个字节，这点从初始化密钥流的部分也能看出，因为初始化密钥流使用了swap，整个操作失去线性，所以可以保证密钥流一定的随机性RC4大部分的操作都是在初始化密钥盒，最后只是进行了异或，可以说拿到了密钥盒就是破解了RC4 特征虽然说本文的重点不在特征，但还是指出RC4的一些比较明显的特征，一个是置换盒初始化算法，一个就是最后密钥流对输入的异或 实现1234567891011121314151617181920212223242526272829#include &lt;bits/stdc++.h&gt;using namespace std;int main(){ uint8_t initBox[256]; for (int i = 0; i &lt; 256; i++) initBox[i] = i; // 初始化向量 int j = 0; char key[] = &quot;Eleven&quot;; for (int i = 0; i &lt; 256; i++) { j = (j + initBox[i] + key[i % strlen(key)]) % 256; // 初始化密钥流向量 swap(initBox[i], initBox[j]); } char rawInput[] = &quot;thisIsASecretMessage&quot;; int len = strlen(rawInput); int i = 0; j = 0; for (int k = 0; k &lt; len; k++) { i = (i + 1) % 256; j = (j + initBox[i]) % 256; swap(initBox[i], initBox[j]); int t = (initBox[i] + initBox[j]) % 256; int K = initBox[t]; // 密钥流 rawInput[k] = rawInput[k] ^ K; // 将密钥与输入异或 } return 0;} 破解逐字节异或，一般逆向中其实怎么都能破解，可以动调获取box,或者直接把密文输进去，或者在RC4入口点把输入的内容patch成密文，根据异或的性质RC4的加密算法就是解密算法，跑两遍等于没跑，一般题目会在key上做文章，或者在每轮异或后额外异或一个常数之类的，防止直接拿到key后一把梭继续观察源码注意到这个t其实还能加入偏移，K也能加入常数或偏移，初始化向量也可能事先打乱而不是0,1,2,3…，甚至向量的位数也可以魔改，实战中要具体观察实现 referencewikipedia 对称加密目录","link":"/ctf/%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86/RC4/"},{"title":"DES","text":"简介DES加密是经典的基于Feistel网络结构的块加密，DES标准中字节的处理方式为大端序，DES接受一个64位（64bit）的明文和一个64位的key，返回64位的密文在DES流程的开始，64位的key被传入PC1函数生成56位的真正密钥，因为原密钥中有8位是校验位而这56位的密钥会再被拆分成左右两个各28位的密钥 123456789101112131415161718pair&lt;uint32_t, uint32_t&gt; PC1(uint64_t key){ uint8_t pc1L[] = {57, 49, 41, 33, 25, 17, 9, 1, 58, 50, 42, 34, 26, 18, 10, 2, 59, 51, 43, 35, 27, 19, 11, 3, 60, 52, 44, 36}; uint8_t pc1R[] = {63, 55, 47, 39, 31, 23, 15, 7, 62, 54, 46, 38, 30, 22, 14, 6, 61, 53, 45, 37, 29, 21, 13, 5, 28, 20, 12, 4}; pair&lt;uint32_t, uint32_t&gt; keyPair{0, 0}; for (int i = 0; i &lt; 28; i++) { keyPair.first |= ((key &gt;&gt; (64 - pc1L[i])) &amp; 1) &lt;&lt; (27 - i); keyPair.second |= ((key &gt;&gt; (64 - pc1R[i])) &amp; 1) &lt;&lt; (27 - i); } return keyPair;} 两个28位密钥分别左旋特定位数后进入PC2用于生成16个48位子密钥，PC2中有一个盒用于决定选择哪48位来作为密钥 123456789101112131415161718192021222324252627void keyGen(pair&lt;uint32_t, uint32_t&gt; keyPair){ uint8_t offsets[] = {1, 1, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 1}; for (int i = 0; i &lt; 16; i++) { keyPair.first = leftRotate(keyPair.first, offsets[i]); keyPair.second = leftRotate(keyPair.second, offsets[i]); Keys[i] = PC2(((uint64_t)keyPair.first &lt;&lt; 28) | keyPair.second); }}uint64_t PC2(uint64_t key){ uint8_t pc2[] = {14, 17, 11, 24, 1, 5, 3, 28, 15, 6, 21, 10, 23, 19, 12, 4, 26, 8, 16, 7, 27, 20, 13, 2, 41, 52, 31, 37, 47, 55, 30, 40, 51, 45, 33, 48, 44, 49, 39, 56, 34, 53, 46, 42, 50, 36, 29, 32}; uint64_t subKey = 0; for (int i = 0; i &lt; 48; i++) { subKey |= ((key &gt;&gt; (56 - pc2[i])) &amp; 1) &lt;&lt; (47 - i); } return subKey;} 至此为止密钥全部准备完毕，明文被分为左右各32位进入Feistel网络循环流程 1234567891011121314void desEncrypt(uint64_t *plain, uint64_t key){ keyGen(PC1(key)); uint64_t afterIP = IP(*plain); uint32_t l = afterIP &gt;&gt; 32, r = afterIP &amp; 0xFFFFFFFF; for (int i = 0; i &lt; 16; i++) { pair&lt;uint32_t, uint32_t&gt; lr = goRound(l, r, Keys[i]); l = lr.first; r = lr.second; } *plain = ((uint64_t)r &lt;&lt; 32) | l; *plain = FP(*plain);} 明文在进入和结束加密时还要经历IP,FP两次置换，这两次置换只是简单映射 12345678910111213141516171819202122232425262728293031323334uint64_t IP(uint64_t messagge){ uint64_t afterIP = 0; uint8_t ip[] = {58, 50, 42, 34, 26, 18, 10, 2, 60, 52, 44, 36, 28, 20, 12, 4, 62, 54, 46, 38, 30, 22, 14, 6, 64, 56, 48, 40, 32, 24, 16, 8, 57, 49, 41, 33, 25, 17, 9, 1, 59, 51, 43, 35, 27, 19, 11, 3, 61, 53, 45, 37, 29, 21, 13, 5, 63, 55, 47, 39, 31, 23, 15, 7}; for (int i = 0; i &lt; 64; i++) { afterIP |= ((messagge &gt;&gt; (64 - ip[i])) &amp; 1) &lt;&lt; (63 - i); } return afterIP;}uint64_t FP(uint64_t messagge){ uint64_t afterFP = 0; uint8_t fp[] = {40, 8, 48, 16, 56, 24, 64, 32, 39, 7, 47, 15, 55, 23, 63, 31, 38, 6, 46, 14, 54, 22, 62, 30, 37, 5, 45, 13, 53, 21, 61, 29, 36, 4, 44, 12, 52, 20, 60, 28, 35, 3, 43, 11, 51, 19, 59, 27, 34, 2, 42, 10, 50, 18, 58, 26, 33, 1, 41, 9, 49, 17, 57, 25}; for (int i = 0; i &lt; 64; i++) { afterFP |= ((messagge &gt;&gt; (64 - fp[i])) &amp; 1) &lt;&lt; (63 - i); } return afterFP;} Feistel轮函数如下所示 1234567891011uint32_t feistel(uint32_t a, uint64_t key){ uint64_t t = expand(a) ^ key; uint32_t afterS = S(t); afterS = P(afterS); return afterS;}pair&lt;uint32_t, uint32_t&gt; goRound(uint32_t l, uint32_t r, uint64_t key){ return {r, l ^ feistel(r, key)};} 数据先经过E盒拓展为48位后与48位密钥异或，然后进入S盒重新映射为32位，最后由P盒再进行一轮置换后输出 1234567891011121314151617uint64_t expand(uint32_t a){ uint8_t e[] = {32, 1, 2, 3, 4, 5, 4, 5, 6, 7, 8, 9, 8, 9, 10, 11, 12, 13, 12, 13, 14, 15, 16, 17, 16, 17, 18, 19, 20, 21, 20, 21, 22, 23, 24, 25, 24, 25, 26, 27, 28, 29, 28, 29, 30, 31, 32, 1}; uint64_t afterE = 0; for (int i = 0; i &lt; 48; i++) { afterE |= ((a &gt;&gt; (32 - e[i])) &amp; 1) &lt;&lt; (47 - i); } return afterE;} S盒有8个，每个S盒是一个4*16的结构，48位的输出被分为8个6位的块分别进入对应的S盒，每块的第1和第6个位用于索引行(0x00 ~ 0x11)，其余四位用于索引列(0x0000 ~ 0x1111)，S盒中的数都是4位的，最后合起来得到一个32位的输出 1234567891011uint64_t S(uint64_t a){ uint32_t res = 0; for (int i = 0; i &lt; 8; i++) { uint8_t row = ((((a &gt;&gt; (i * 6)) &amp; 0x20)) &gt;&gt; 4) | ((a &gt;&gt; (i * 6)) &amp; 1); uint8_t col = ((a &gt;&gt; (i * 6)) &amp; 0x1E) &gt;&gt; 1; res |= S_box[i][row * 16 + col] &lt;&lt; (i * 4); } return res;} P置换就是再次打乱S盒的输出 1234567891011121314151617uint32_t P(uint64_t a){ uint8_t p[] = {16, 7, 20, 21, 29, 12, 28, 17, 1, 15, 23, 26, 5, 18, 31, 10, 2, 8, 24, 14, 32, 27, 3, 9, 19, 13, 30, 6, 22, 11, 4, 25}; uint32_t afterP = 0; for (int i = 0; i &lt; 32; i++) { afterP |= ((a &gt;&gt; (32 - p[i])) &amp; 1) &lt;&lt; (31 - i); } return afterP;} 至此DES的流程全部结束，按照图例的话如下图所示 特征因为DES的代码过于庞大，且涉及大量位操作，在反编译器中观察DES的特征非常困难，但是DES有非常多的盒，其中部分盒是精心设计的，修改这部分盒会严重影响DES在对抗暴力破解时的安全性，所以我们可以通过这些一般不会修改的盒识别DES S盒S盒引入了非线性操作，且S盒的每一位都设计过用以抵抗差分和线性密码分析，一般不会修改S盒 123456789101112131415161718192021222324252627282930313233uint8_t S_box[8][64] = {{14, 4, 13, 1, 2, 15, 11, 8, 3, 10, 6, 12, 5, 9, 0, 7, 0, 15, 7, 4, 14, 2, 13, 1, 10, 6, 12, 11, 9, 5, 3, 8, 4, 1, 14, 8, 13, 6, 2, 11, 15, 12, 9, 7, 3, 10, 5, 0, 15, 12, 8, 2, 4, 9, 1, 7, 5, 11, 3, 14, 10, 0, 6, 13},{15, 1, 8, 14, 6, 11, 3, 4, 9, 7, 2, 13, 12, 0, 5, 10, 3, 13, 4, 7, 15, 2, 8, 14, 12, 0, 1, 10, 6, 9, 11, 5, 0, 14, 7, 11, 10, 4, 13, 1, 5, 8, 12, 6, 9, 3, 2, 15, 13, 8, 10, 1, 3, 15, 4, 2, 11, 6, 7, 12, 0, 5, 14, 9},{10, 0, 9, 14, 6, 3, 15, 5, 1, 13, 12, 7, 11, 4, 2, 8, 13, 7, 0, 9, 3, 4, 6, 10, 2, 8, 5, 14, 12, 11, 15, 1, 13, 6, 4, 9, 8, 15, 3, 0, 11, 1, 2, 12, 5, 10, 14, 7, 1, 10, 13, 0, 6, 9, 8, 7, 4, 15, 14, 3, 11, 5, 2, 12},{7, 13, 14, 3, 0, 6, 9, 10, 1, 2, 8, 5, 11, 12, 4, 15, 13, 8, 11, 5, 6, 15, 0, 3, 4, 7, 2, 12, 1, 10, 14, 9, 10, 6, 9, 0, 12, 11, 7, 13, 15, 1, 3, 14, 5, 2, 8, 4, 3, 15, 0, 6, 10, 1, 13, 8, 9, 4, 5, 11, 12, 7, 2, 14},{2, 12, 4, 1, 7, 10, 11, 6, 8, 5, 3, 15, 13, 0, 14, 9, 14, 11, 2, 12, 4, 7, 13, 1, 5, 0, 15, 10, 3, 9, 8, 6, 4, 2, 1, 11, 10, 13, 7, 8, 15, 9, 12, 5, 6, 3, 0, 14, 11, 8, 12, 7, 1, 14, 2, 13, 6, 15, 0, 9, 10, 4, 5, 3},{12, 1, 10, 15, 9, 2, 6, 8, 0, 13, 3, 4, 14, 7, 5, 11, 10, 15, 4, 2, 7, 12, 9, 5, 6, 1, 13, 14, 0, 11, 3, 8, 9, 14, 15, 5, 2, 8, 12, 3, 7, 0, 4, 10, 1, 13, 11, 6, 4, 3, 2, 12, 9, 5, 15, 10, 11, 14, 1, 7, 6, 0, 8, 13},{4, 11, 2, 14, 15, 0, 8, 13, 3, 12, 9, 7, 5, 10, 6, 1, 13, 0, 11, 7, 4, 9, 1, 10, 14, 3, 5, 12, 2, 15, 8, 6, 1, 4, 11, 13, 12, 3, 7, 14, 10, 15, 6, 8, 0, 5, 9, 2, 6, 11, 13, 8, 1, 4, 10, 7, 9, 5, 0, 15, 14, 2, 3, 12},{13, 2, 8, 4, 6, 15, 11, 1, 10, 9, 3, 14, 5, 0, 12, 7, 1, 15, 13, 8, 10, 3, 7, 4, 12, 5, 6, 11, 0, 14, 9, 2, 7, 11, 4, 1, 9, 12, 14, 2, 0, 6, 10, 13, 15, 3, 5, 8, 2, 1, 14, 7, 4, 10, 8, 13, 15, 12, 9, 0, 3, 5, 6, 11}}; P盒P盒的特殊设计使得每一轮由同一个S盒输出的4个bit在下一轮都被分散到另外4个不同S盒中进行处理（增强扩散性） 123456789uint8_t p[] = {16, 7, 20, 21, 29, 12, 28, 17, 1, 15, 23, 26, 5, 18, 31, 10, 2, 8, 24, 14, 32, 27, 3, 9, 19, 13, 30, 6, 22, 11, 4, 25}; E盒E盒负责将32位的输入扩展到48位，对混淆能力由很大影响 123456789uint8_t e[] = {32, 1, 2, 3, 4, 5,4, 5, 6, 7, 8, 9,8, 9, 10, 11, 12, 13,12, 13, 14, 15, 16, 17,16, 17, 18, 19, 20, 21,20, 21, 22, 23, 24, 25,24, 25, 26, 27, 28, 29,28, 29, 30, 31, 32, 1}; 实现考虑到DES现在已经被证明不安全，且其加密过程严重依赖系统端序，DES标准为大端序，而现代计算机大多数为小端序，故不给出完整实现，如果遇到需要手动解密的DES，只需要根据Feistel网络的性质，将16个子密钥倒着使用即可解密 referenceDES-wikipedia 对称加密目录","link":"/ctf/%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86/DES/"},{"title":"bn脚本笔记","text":"由于BinaryNinja脚本的官方文档完全就是把api按字典序堆在一起，故开一篇随笔存一些常见api的使用方法，随机更新中 笔记中所有的bv均为BinaryView类，即与bn交互的主要接口 bv.instructions返回当前二进制文件的所有指令，返回形式为元组组成的列表，元组的第一个元素为该指令的Token按空格切片形成的列表，第二个元素为指令地址这个token有很多附加的属性(或者说解释的方式，比如token.text就是返回文本,token.value就是把token按数值转换为int (假设这个token是数值))，不只是单纯的text，在简单输出时体现为text 12for instruction in bv.instructions: print(instruction) bv.linear_disassembly和 bv.instructions 很像，但是这个真就是直接把指令文本一条条打出来，返回的是一个迭代器 get_disassembly(addr: int)返回目标地址指令的文本(str) bv.get_instruction_length(addr : int)返回目标地址指令的长度 1234for instruction in bv.instructions: if instruction[0][0].text == 'jz' or instruction[0][0].text == 'jnz': print(instruction[0][0]) print(&quot;len = &quot;, bv.get_instruction_lengt(instruction[1])) bv.write(addr : int ,data : bytes)直接往目标地址覆写一段数据，patch的主要手段 bv.read(addr : int ,length : int)读取以目标地址为起点一定长度的数据，返回字节流(bytes)","link":"/ctf/re-hints/BinaryNinjaScript/"},{"title":"TEA","text":"简介TEA加密是一种经典的块加密，使用64位密文和128位(4个uint_32t)密钥，并使用Feistel框架进行加密Feistel框架指的是将密文分成两个等长块，每轮加密对两个块分别施加轮加密函数并进行交换，这点在TEA中体现为v0的累加值由v1计算得到，反之亦然注意使用TEA加密时如果密文小于64位(bit)要填充0字节占位，否则由于指针类型转换会将垃圾数据引入加密，当密文大于64位时要将密文分块分别执行TEA加密 特征应主要关注其Feistel网络结构而不是关注常量，因为TEA加密的加密计算方式，计算轮次，累加常量均可以魔改，但是密文被分为两个块并在每轮加密中采用相似的加密函数这个特点是不会变的，同时关注每轮中v0,v1分别由v1,v0计算得到，密钥通常为128位即4个uint_32t 实现12345678910111213void teaEncrypt(uint32_t *v, uint32_t *k){ uint32_t sum = 0, v0 = v[0], v1 = v[1]; // 将输入分为两个32位的块 uint32_t delta = 0x9E3779B9; //初始常量，可以为任何数 for (int i = 0; i &lt; 32; i++) { v0 += ((v1 &lt;&lt; 4) + k[0]) ^ (v1 + sum) ^ ((v1 &gt;&gt; 5) + k[1]); // 轮加密函数 sum += delta; v1 += ((v0 &lt;&lt; 4) + k[2]) ^ (v0 + sum) ^ ((v0 &gt;&gt; 5) + k[3]); // 轮加密函数 } v[0] = v0; // 应用修改 v[1] = v1;} 解密因为TEA加密是由Feistel框架设计来的，所以解密Feistel密码的方式对TEA也适用，我们只需根据加密完的最后状态，反向执行同样轮次的轮加密，就能解出明文 1234567891011121314void teaDecrypt(uint32_t *v, uint32_t *k){ uint32_t sum = 0, v0 = v[0], v1 = v[1]; uint32_t delta = 0x9E3779B9; sum = delta * 32; // 获取最终状态的累加和 for (int i = 0; i &lt; 32; i++) { v1 -= ((v0 &lt;&lt; 4) + k[2]) ^ (v0 + sum) ^ ((v0 &gt;&gt; 5) + k[3]); // 因为v1是最后被计算的，所以解密时要先计算v1 sum -= delta; // 累加改为递减 v0 -= ((v1 &lt;&lt; 4) + k[0]) ^ (v1 + sum) ^ ((v1 &gt;&gt; 5) + k[1]); } v[0] = v0; v[1] = v1;} 完整代码12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;bits/stdc++.h&gt;using namespace std;void teaEncrypt(uint32_t *v, uint32_t *k){ uint32_t sum = 0, v0 = v[0], v1 = v[1]; uint32_t delta = 0x9E3779B9; for (int i = 0; i &lt; 32; i++) { v0 += ((v1 &lt;&lt; 4) + k[0]) ^ (v1 + sum) ^ ((v1 &gt;&gt; 5) + k[1]); sum += delta; v1 += ((v0 &lt;&lt; 4) + k[2]) ^ (v0 + sum) ^ ((v0 &gt;&gt; 5) + k[3]); } v[0] = v0; v[1] = v1;}void teaDecrypt(uint32_t *v, uint32_t *k){ uint32_t sum = 0, v0 = v[0], v1 = v[1]; uint32_t delta = 0x9E3779B9; sum = delta * 32; for (int i = 0; i &lt; 32; i++) { v1 -= ((v0 &lt;&lt; 4) + k[2]) ^ (v0 + sum) ^ ((v0 &gt;&gt; 5) + k[3]); sum -= delta; v0 -= ((v1 &lt;&lt; 4) + k[0]) ^ (v1 + sum) ^ ((v1 &gt;&gt; 5) + k[1]); } v[0] = v0; v[1] = v1;}int main(){ uint32_t key[4] = {0x01234567, 0x89ABCDEF, 0xFEDCBA98, 0x76543210}; char plaintext[] = &quot;Eleven11&quot;; teaEncrypt((uint32_t *)plaintext, key); for (int i = 0; i &lt; 8; i++) printf(&quot;%02X &quot;, plaintext[i] &amp; 0xFF); printf(&quot;\\n&quot;); teaDecrypt((uint32_t *)plaintext, key); for (int i = 0; i &lt; 8; i++) printf(&quot;%c&quot;, plaintext[i]); return 0;} refernceTEA-wikipediaFeistel network-wikipedia 对称加密目录","link":"/ctf/%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86/TEA/"},{"title":"XTEA","text":"简介省流：TEA的大杯版 因为TEA加密有密钥调度算法过于简单(直接调用),密钥之间等价(每个密钥都被平均的使用)这两个缺陷，所以有了XTEA加密，XTEA将密钥调度的算法改为非线性的，并且略微修改了轮加密计算方法 特征XTEA最大的特征就是每次加密使用的密钥由当前sum的累加值决定，通常是sum经过计算后&amp;3，其余的特征和TEA加密基本相同 实现12345678910111213void xteaEncrypt(uint32_t *v, uint32_t *k){ uint32_t sum = 0, v0 = v[0], v1 = v[1]; uint32_t delta = 0x9E3779B9; for (int i = 0; i &lt; 32; i++) { v0 += (((v1 &lt;&lt; 4) ^ (v1 &gt;&gt; 5)) + v1) ^ (sum + k[sum &amp; 3]); // 使用非线性方式调用key sum += delta; v1 += (((v0 &lt;&lt; 4) ^ (v0 &gt;&gt; 5)) + v0) ^ (sum + k[(sum &gt;&gt; 11) &amp; 3]); } v[0] = v0; v[1] = v1;} 解密虽然XTEA针对TEA进行了很多改进，但是对于逆向工程来说，我们并不是进行黑盒分析，所以XTEA和TEA并没有很大不同，直接使用Feistel密码的解法把运算过程反过来即可 1234567891011121314void xteaDecrypt(uint32_t *v, uint32_t *k){ uint32_t sum = 0, v0 = v[0], v1 = v[1]; uint32_t delta = 0x9E3779B9; sum = delta * 32; for (int i = 0; i &lt; 32; i++) { v1 -= (((v0 &lt;&lt; 4) ^ (v0 &gt;&gt; 5)) + v0) ^ (sum + k[(sum &gt;&gt; 11) &amp; 3]); sum -= delta; v0 -= (((v1 &lt;&lt; 4) ^ (v1 &gt;&gt; 5)) + v1) ^ (sum + k[sum &amp; 3]); } v[0] = v0; v[1] = v1;} 完整代码123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;bits/stdc++.h&gt;using namespace std;void xteaEncrypt(uint32_t *v, uint32_t *k){ uint32_t sum = 0, v0 = v[0], v1 = v[1]; uint32_t delta = 0x9E3779B9; for (int i = 0; i &lt; 32; i++) { v0 += (((v1 &lt;&lt; 4) ^ (v1 &gt;&gt; 5)) + v1) ^ (sum + k[sum &amp; 3]); sum += delta; v1 += (((v0 &lt;&lt; 4) ^ (v0 &gt;&gt; 5)) + v0) ^ (sum + k[(sum &gt;&gt; 11) &amp; 3]); } v[0] = v0; v[1] = v1;}void xteaDecrypt(uint32_t *v, uint32_t *k){ uint32_t sum = 0, v0 = v[0], v1 = v[1]; uint32_t delta = 0x9E3779B9; sum = delta * 32; for (int i = 0; i &lt; 32; i++) { v1 -= (((v0 &lt;&lt; 4) ^ (v0 &gt;&gt; 5)) + v0) ^ (sum + k[(sum &gt;&gt; 11) &amp; 3]); sum -= delta; v0 -= (((v1 &lt;&lt; 4) ^ (v1 &gt;&gt; 5)) + v1) ^ (sum + k[sum &amp; 3]); } v[0] = v0; v[1] = v1;}int main(){ uint32_t key[4] = {0x01234567, 0x89ABCDEF, 0xFEDCBA98, 0x76543210}; char plaintext[] = &quot;Eleven11&quot;; xteaEncrypt((uint32_t *)plaintext, key); for (int i = 0; i &lt; 8; i++) printf(&quot;%02X &quot;, plaintext[i] &amp; 0xFF); printf(&quot;\\n&quot;); xteaDecrypt((uint32_t *)plaintext, key); for (int i = 0; i &lt; 8; i++) printf(&quot;%c&quot;, plaintext[i]); return 0;} refernceXTEA-wikipediaFeistel network-wikipedia 对称加密目录","link":"/ctf/%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86/XTEA/"},{"title":"electron逆向小记","text":"记录一下通过在product模式下发行的electron应用调试手段和electron逆向的方法 解包electron应用的核心代码通常以明文js形式储存在app.asar文件中（也可能使用wasm），他的exe本身是无意义的，所以我们要先解包npm install --engine-strict @electron/asar然后运行asar e app.asar app就能解包了，当然可能解包完后发现js是加密的（这种大概率是自解密壳，按照其他平台上的对抗手法一样对抗即可）electron有一个特点，如果resource目录下有app.asar，他就会优先把app.asar作为资源运行，但如果我们把app.asar删了，留下解包后的文件夹，他也可以正常运行，这可能和asar只是归档文件格式有关，总之这大大方便了我们修改代码打补丁的过程解包后的node_modules中可能会缺依赖，执行npm install重新下载即可，package.json肯定是好的之后在dist目录下应该能看到webpack打包的前端代码，然后其他目录下是一些后端代码，善用vscode的全局搜索功能定位关键代码即可，可以套用js逆向的常规对抗思路 调试electron这种web应用本质是在本地跑了个chrome渲染网页和用户交互，在开发模式下直接按f12或者左上角工具栏都可以打开调试器，但是逆向遇到的大多都是发行版的app，这种情况本地不能打开f12，如果强行将运行环境(process.env.NODE_ENV)改为”development”，electron会尝试从本地开发服务器获取页面，但是发行版的应用肯定dev server都是剥离的，重新配置也很麻烦，这种时候一般是考虑使用chrome远程调试应用electron的应用分前端渲染部分和后端部分，前端部分就是个网页，可以在运行时添加–remote-debugging-port=xxxx开启调试服务器，这是chromium内核应用通用的调试服务器开启方式，后端部分通过添加–inspect=xxxx开启调试，这个是electron特有的调试服务器参数这些都开启后可以在本地chrome的chrome://inspect/#devices页面查看调试服务器一般默认已经开启了几个监听端口(9222)，如果是新的端口要在network targets中手动添加然后点击inspect就能打开调试窗口了一般这个时候已经足够我们逆向了，如果还行打开electron原生的devTool，可以参考以下方法先获取BrowserWindow的引用const BrowserWindow=require(&quot;electron&quot;)然后通过BrowserWindow.getAllWindows()获取所有窗口的引用之后调用toggleDevTools()方法一般就能弹调试器了总之能我们都能任意执行js了，只要找到对应的方法执行就行了当然应用可能会有一些反调试手段但是web应用本身的接触底层的接口有限，所以反调试手法无非检测一些浏览器环境字段或者程序运行参数，直接在解包的js代码里修改patch即可","link":"/ctf/re-hints/electron-devtool/"},{"title":"加密&amp;编码算法精读目录","text":"对称加密是逆向工程中重要的知识点，这部分笔记对常见的对称加密算法和一些编码算法进行了精读，力求完全剖析加密的具体流程和实现，而不是止步于特征判断 目录 RC4TEAXTEAXXTEADES普通AESBASE64ChaCha20 TODO：白盒AES","link":"/ctf/%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%E7%B2%BE%E8%AF%BB%E7%9B%AE%E5%BD%95/"},{"title":"XXTEA","text":"简介省流：TEA的超大杯版 XXTEA是XTEA的改进版，与它的前身不同，XXTEA大量魔改了原来的加密结构，首先是采用了非对称Feistel网络结构，数据不再被分为两个32位块，同时也不再一次只处理64位的数据，而是直接把所有数据分为多个32位块，然后用CBC模式循环加密，令块数为n，则一轮加密指的是将这n个块的数据各变换一次，总的加密轮次由round=6+52/n给出，注意这个公式仅仅是为了在安全性和性能之间做出平衡，理论上加密的轮次并没有要求。加密函数MX也进行了修改，更换了计算方式和密钥选择方式。 特征标准版本的XXTEA加密循环轮次由数据规模n绝定，当然rounds=6+52/n这个公式完全可以魔改，然后是每轮加密中的CBC结构特征，以及128位密钥 实现12345678910111213141516171819202122#define MX ((z &gt;&gt; 5 ^ y &lt;&lt; 2) + (y &gt;&gt; 3 ^ z &lt;&lt; 4) ^ (sum ^ y) + (k[p &amp; 3 ^ e] ^ z))void xxteaEncrtpy(uint32_t *v, size_t n, uint32_t *k){ uint32_t y, z, sum; uint32_t p, rounds, e; uint32_t delta = 0x9E3779B9; rounds = 6 + 52 / n; sum = 0; z = v[n - 1]; do { sum += delta; e = (sum &gt;&gt; 2) &amp; 3; // 引入非线性计算，使得每次取出的key值缺少规律 for (p = 0; p &lt; n - 1; p++) { y = v[p + 1]; z = v[p] += MX; // 每个块加密是增加的偏移量实际上由上一个块(z)和下一个块(y)的值和sum共同决定 } y = v[0]; // 此处其实是循环加密的端点，当然可以对下标取模把这部分写进循环里 z = v[n - 1] += MX; } while (--rounds); // 实际上是把相同的操作重复round轮} 解密虽然整个结构进行了大程度魔改，但仍是Fesitel网络，所以只要想办法把运算逆转过来就能解密 123456789101112131415161718192021void xxteaDecrypt(uint32_t *v, size_t n, uint32_t *k){ uint32_t y, z, sum; uint32_t p, rounds, e; uint32_t delta = 0x9E3779B9; rounds = 6 + 52 / n; sum = rounds * delta; y = v[0]; // n-1号块的下一个块是0号块 do { e = (sum &gt;&gt; 2) &amp; 3; for (p = n - 1; p &gt; 0; p--) // 反向循环 { z = v[p - 1]; // 因为是反着循环，所以这里是上一个块 y = v[p] -= MX; // 这里是也是取上一个和下一个块的值作为参数 } z = v[n - 1]; // 0号块的上一个块是n-1号块 y = v[0] -= MX; sum -= delta; } while (--rounds);} 完整代码代码中加密数据长度正好为64位，注意当长度不为32位的倍数时记得占位填充 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;bits/stdc++.h&gt;using namespace std;#define MX ((z &gt;&gt; 5 ^ y &lt;&lt; 2) + (y &gt;&gt; 3 ^ z &lt;&lt; 4) ^ (sum ^ y) + (k[p &amp; 3 ^ e] ^ z))void xxteaEncrtpy(uint32_t *v, size_t n, uint32_t *k){ uint32_t y, z, sum; uint32_t p, rounds, e; uint32_t delta = 0x9E3779B9; rounds = 6 + 52 / n; sum = 0; z = v[n - 1]; do { sum += delta; e = (sum &gt;&gt; 2) &amp; 3; // 引入非线性计算，使得每次取出的key值缺少规律 for (p = 0; p &lt; n - 1; p++) { y = v[p + 1]; z = v[p] += MX; // 每个块加密是增加的偏移量实际上由上一个块(z)和下一个块(y)的值和sum共同决定 } y = v[0]; // 此处其实是循环加密的端点，当然可以对下标取模写进循环里 z = v[n - 1] += MX; } while (--rounds); // 实际上是把相同的操作重复round轮}void xxteaDecrypt(uint32_t *v, size_t n, uint32_t *k){ uint32_t y, z, sum; uint32_t p, rounds, e; uint32_t delta = 0x9E3779B9; rounds = 6 + 52 / n; sum = rounds * delta; y = v[0]; // n-1号块的下一个块是0号块 do { e = (sum &gt;&gt; 2) &amp; 3; for (p = n - 1; p &gt; 0; p--) // 反向循环 { z = v[p - 1]; // 因为是反着循环，所以这里是上一个块 y = v[p] -= MX; // 这里是也是取上一个和下一个块的值作为参数 } z = v[n - 1]; // 0号块的上一个块是n-1号块 y = v[0] -= MX; sum -= delta; } while (--rounds);}int main(){ uint32_t k[4] = {0x01234567, 0x89abcdef, 0xfedcba98, 0x76543210}; char v[] = &quot;Eleven11&quot;; xxteaEncrtpy((uint32_t *)v, strlen(v) / 4, k); for (int i = 0; i &lt; 8; i++) printf(&quot;%c&quot;, v[i] &amp; 0xFF); printf(&quot;\\n&quot;); xxteaDecrypt((uint32_t *)v, strlen(v) / 4, k); for (int i = 0; i &lt; 8; i++) printf(&quot;%c&quot;, v[i]); printf(&quot;\\n&quot;); return 0;} referenceXXTEA-wikipedia 对称加密目录","link":"/ctf/%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86/XXTEA/"},{"title":"pyd逆向基础","text":"业务上遇到一个pyinstaller打包的样本需要逆向分析，分析的过程中遇到了很多问题，开篇文章记录一下 pyinstallerpyinstaller可以理解为把pyc,pyd，相关的lib依赖，python运行时全部打包进一个exe，然后运行时释放在内存中，分析的第一步是解包，推荐使用pyinstxtractor-ng，对多版本python兼容性较好 main解包完后应该会出现一个项目文件夹，这个时候一般在根目录找pyc文件，比如说app.pyc这样的命名看着就很像程序入口，使用pylingual将其还原成python代码，一般都能成功还原，如果出错了就手撕还原字节码，pyc的字节码才用的是基于栈运行的虚拟机，并不难手撕，这里不展开赘述，只要去查一下相关对应的字节码对应的指令即可比如我遇到的app.pyc反编译结果就如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051# Decompiled with PyLingual (https://pylingual.io)# Internal filename: v2\\app.py# Bytecode version: 3.8.0rc1+ (3413)# Source timestamp: 1970-01-01 00:00:00 UTC (0)import datetimeimport jsonimport osfrom decimal import Decimalfrom PySide2.QtCore import Qt, QUrlfrom PySide2.QtGui import QPixmap, QIconfrom PySide2.QtWidgets import QWidget, QTableWidgetItem, QApplication, QMessageBox, QPushButton, QVBoxLayout, QDialog, QLabelfrom PySide2.QtMultimedia import QMediaPlayer, QMediaContentfrom openpyxl.workbook import Workbookfrom v2.qtmain import start_qtfrom v2.spider import CrawlerThreadfrom utils import commonfrom ui.xhs_v2 import Ui_Formimport datetimeimport jsonimport loggingimport osimport queueimport reimport threadingimport timeimport hashlibfrom random import randint, choiceimport execjsimport http.cookiesimport requestsfrom PySide2.QtCore import QThread, Signalfrom utils import commonfrom dateutil import parserfrom fake_useragent import UserAgentimport base64import datetimeimport mathimport osimport randomimport timeimport uuidimport requestsimport qrcodefrom lxml import etreefrom PySide2 import QtCore, QtGui, QtWidgetsfrom Crypto.Cipher import AESfrom Crypto.Util.Padding import padimport utils.xhs_xsif __name__ == '__main__': start_qt() 可以看到主函数里啥都没有，python逆向对抗的主要区域是在pyd，稍微注重一点加固的软件都不会把重要代码放在pyc里这个阶段还有一个重要的工作是收集信息，根据目录下的dll确定python版本（非常重要，后续的运行和调试基本要基于相同的版本），如果可以的话也可以尝试确认依赖库的具体版本，不过这个相对没有那么严格然后就是尝试运行程序python app.pyc，因为如果运行打包好的程序所有东西都是混在一起的，没法调试，一般是运行python主文件，然后用调试器attach到python进程上，这样每个pyd文件都会作为独立的dll存在如果是比较复杂的程序这个时候会缺各种依赖，我们最好使用一个虚拟环境python -m venv .venv，然后根据报错去下载对应的依赖，同时可能会出现只有特定版本区间的依赖库才能正常运行的情况，这种情况就要根据报错去查资料然后试着换不同版本号的依赖库如果程序能正常运行了，那么前期的准备工作基本就完毕了，可以进入pyd的分析了 pyd恢复符号pyd里的符号是全抹去的，因为pyd只导出pyInit_module这一个符号用来将c实现的python方法导出给python进程，我们首先要做的是尽可能恢复一些和python数据结构操作相关的符号以及python特有的结构体，这里一般采取的方法是编译一份带符号和调试信息的pyd文件，然后在ida中导出头文件来提供相关类型定义，然后再用bindiff和样本pyd比对恢复一部分符号bindiff在这个repo下载，解压了直接拖进ida的插件目录即可，好像9.1的有个bug，他会去找ida64.exe这个文件执行导出任务，但是ida9.0以及把ida64和ida合并成了一个文件，解决办法就是复制一份ida.exe并重命名成ida64.exe放在ida根目录下 12345678910111213141516# setup.pyfrom distutils.core import setupfrom Cython.Build import cythonizefrom distutils.extension import Extensionmodule = Extension( &quot;common&quot;, sources=[&quot;MyPyd.py&quot;], extra_compile_args=[&quot;/Zi&quot;], # 编译器选项：生成调试信息 extra_link_args=[&quot;/DEBUG&quot;], # 链接器选项：生成 PDB 文件)setup( ext_modules=cythonize(module)) 123456789101112131415161718192021222324252627282930313233# MyPyd.pyclass common: def get_expire_time(): return &quot;&quot;testString = &quot;testSSString&quot;print(testString)a = 1b = 2c = 3print(a+b)print(a-b)print(a*b)print(a/b)print(a//b)print(a % b)print(a &amp; b)print(a | b)print(a &amp; b)print(a ^ b)print(~a)print(not a)print(a and b)print(a or b)print(a**b)d = [1, 2, 3]print(d[0])e = {1, 2, 3}print(e[0])f = (1, 2, 3)print(f[0]) 原则上样本文件越复杂越好，包括越多的操作生成的符号就越多，能恢复的也越多运行python setup.py build_ext --inplace即可编译，这里最好用相同版本的python进行编译然后运行Parse C header file导出头文件即可然后退出ida并把分析结果保存为i64/idb数据库打开要分析的样本，并plugins中选择bindiff，再选择diff database然后选中刚刚的保存的数据库，就会自动开始匹配符号，一般看着选一部分，然后import symbols即可导入符号，把绿色的差不多都导入了就行，反正置信度这种就看个乐 定位方法正常情况下方法名都会直接直接以裸字符串储存在rdata里（用于在报错时添加traceback），通过字符串可以迅速定位到指定方法的具体实现 动调分析PyObject默认都是未初始化的，具体来说就是静态的时候看到的一大堆空的qword网上有说法是有一个Pyinit函数统一处理这些所有对象的初始化，可惜我并没有定位到对应的实现，不过像这种PyASCIIObject跳过去基本能看到是什么，对应的初始值就和PyObject指针放在一起这里再介绍一种动调的方法，attach到python进程后在想看的PyObject附近下断点，然后跳到对应内存，需要跳两次，因为是结构体指针，然后可以看到明显的结构体特征这里前两个值直接转化成qword，所有PyObject这两个都是固定的，分别是引用次数和PyType知道了type后就好办了，我们之前准备的头文件已经搞定了这些PyObject类型的定义，像这里其实这就是一个PyASCIIObject紧跟在PyASCIIObject结构体后的就是这个python对象的具体值 另外在分析的过程中可能会看到有结构体没还原的情况（ida识别为qword，然后相关操作都带偏移），这种情况可以先试试重定义为PyObject*，大部分情况下其实都是PyObject* 另外如果目标程序里有复杂的加密计算流程，可以考虑trace相关的数值操作，这里使用frida或条件断点都是不错的选择不过位操作(左右移,and,or,xor)似乎不使用导入的函数，所以还要去具体的加密部分找函数hook 替换返回值如果要替换数值对象或字符串返回值最好用frida，主动调用PyXXX_fromXXX构造PyObject对象后返回，如果是替换true/false倒是可以直接patch，注意到python中ture和false分别被储存到两个全局单例中，所以如果想让某个函数永远返回true或false，只要将该单例的指针储存到返回寄存器(rax)，然后增加引用数并return即可","link":"/ctf/re-hints/pyd-basic/"},{"title":"从零开始的LLVM-pass （一） 环境搭建和第一个demo","text":"为什么有这篇文章前段时间看了点LLVM的博客，学的非常痛苦，所以打算写一篇文章记录一下基本的框架搭建过程，省的一段时间后又忘了 Demo实现一个 FunctionPass ，遍历所有函数，如果函数不是main函数就修改混淆函数的名字 关于环境开发环境是win，至于为什么不选linux，主要是没有物理机实在不方便，后续如果被win恶心到了可能会迁移到linux win-gnu-llvm下载 非常神奇的找到了兼容win-gnu ABI的llvm工具链，试了下能跑，索性先这样g++用的是MinGW，网上随便下一个新一点的都行 直接下载完就是编译完的二进制文件，把bin加到环境目录就能识别clang和opt了 框架搭建目录结构如图所示build是Cmake的输出路径，最终编译好的pass就存在里面test里是测试文件，用来测试pass的混淆效果transforms里是pass的源码 /transforms/CMakelists.txt12345678910111213141516171819202122232425# /transforms/CMakelists.txtcmake_minimum_required(VERSION 3.13)project(MyPass)set(CMAKE_C_COMPILER &quot;gcc&quot;)set(CMAKE_CXX_COMPILER &quot;g++&quot;)set(LLVM_DIR &quot;C://llvm-19.1.6-1/lib/cmake/llvm&quot;)find_package(LLVM REQUIRED CONFIG)include_directories(${LLVM_INCLUDE_DIRS})link_directories(${LLVM_LIBRARY_DIRS})add_definitions(${LLVM_DEFINITIONS})add_library(MyPass MODULE MyPass.cpp)target_link_libraries(MyPass LLVMCore LLVMSupport LLVMIRReader LLVMPasses LLVMAnalysis LLVMTransformUtils) CMakelist如上设置，要手动导入LLVM的cmake路径，然后中间这些宏都是LLVM的.cmake文件里自带的，直接抄就行之后就和正常cmake项目一样，设置链接库源文件，输出和依赖 test.sh123456789101112# test.shcd ./build cmake -G &quot;Ninja&quot; ../transforms cmake --build .cd ../testg++ test.cpp -o beforeLLVM_testclang++ -S -emit-llvm test.cpp -o test.llopt -load-pass-plugin=../build/libMyPass.dll -passes=encode-func -S test.ll -o test.out.llllc test.out.ll -filetype=obj -o test.og++ test.o -o test ./testcd .. 使用g++编译一份未加pass的二进制文件方便以后对比，使用clang++配合-S -emit-llvm参数输出llvm-IR文件，这是llvm的中间语言文件，之后pass所有的处理都在该文件上进行-load-pass-plugin=${filePath} 是opt新版的api，我们生成的是类似于插件库的dll，之后还要加上 -passes={passName} 指定具体用哪个pass，之后讲如何注册pas时会具体讲这个passName是怎么来的 处理好后用llc把中间文件编译成目标文件，再用g++把中间文件编译成可执行文件就完事了 MyPass.cpp1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &quot;llvm/IR/PassManager.h&quot;#include &quot;llvm/Passes/PassBuilder.h&quot;#include &quot;llvm/Passes/PassPlugin.h&quot;#include &quot;llvm/Support/raw_ostream.h&quot;#include &lt;string&gt;using namespace llvm;namespace{ class EncodeFunctionName : public PassInfoMixin&lt;EncodeFunctionName&gt; { private: static int functionCnt; public: PreservedAnalyses run(Function &amp;F, FunctionAnalysisManager &amp;FAM) { if (F.getName() != &quot;main&quot;) { errs() &lt;&lt; &quot;Old name: &quot; &lt;&lt; F.getName() &lt;&lt; &quot;\\n&quot;; F.setName(&quot;114514func&quot; + std::to_string(++functionCnt)); errs() &lt;&lt; &quot;New name: &quot; &lt;&lt; F.getName() &lt;&lt; &quot;\\n&quot;; } else { errs() &lt;&lt; &quot;function is &quot; &lt;&lt; F.getName() &lt;&lt; &quot;\\n&quot;; } return PreservedAnalyses::all(); } static bool isRequired() { return true; } };}int EncodeFunctionName::functionCnt = 0;extern &quot;C&quot; LLVM_ATTRIBUTE_WEAK ::llvm::PassPluginLibraryInfollvmGetPassPluginInfo(){ return { LLVM_PLUGIN_API_VERSION, &quot;encode-func&quot;, LLVM_VERSION_STRING, [](PassBuilder &amp;PB) { errs() &lt;&lt; &quot;\\n=== Registering EncodeFunctionName Pass ===\\n&quot;; PB.registerPipelineParsingCallback( [](StringRef Name, FunctionPassManager &amp;FPM, ArrayRef&lt;PassBuilder::PipelineElement&gt;) { if (Name == &quot;encode-func&quot;) { errs() &lt;&lt; &quot;Adding EncodeFunctionName pass to manager\\n&quot;; FPM.addPass(EncodeFunctionName()); return true; } return false; }); }};} llvm的所有实现都定义在llvm空间中，因为是个demo所以干脆直接using namespace llvm要实现一个自己的pass，我们要从 PassInfoMixin&lt;&gt; 这个基类模板继承，这是LLVM的新版API，区别于旧版的是我们不用指定pass的类型，而是依靠下面的 run 方法的实现区分pass类型，我们要实现一个functionPAss，所以 run 的参数就是 llvm:Function 和 llvm:FunctionAnalysisManager run 是pass中最关键的方法，一个pass所有的业务都是在run中完成的，这是一个回调，会对所有的函数执行，我们直接用getName获取名字，然后用setName重设名字就行，返回 PreservedAnalyses::all() 表示这个pass不会对其他任何pass产生影响，反正我们也只跑这一个pass，返回all即可 isRequired() 编译器可能会跳过我们的pass，因为实际上pass没做优化，所以要实现 isRequired 返回ture强制要求编译器执行我们的pass extern “C” LLVM_ATTRIBUTE_WEAK ::llvm::PassPluginLibraryInfo llvmGetPassPluginInfo()这是新版LLVM注册pass的惯用约定，这部分基本没什么好改的，返回一个四元组 {LLVM插件API版本号，插件名，插件版本号，注册回调函数} ，其中插件名就是我们用-pass时传递的名字，opt会解析这个名字并并调用相关回调，插件版本号随便写就行 回调会传入一个PassBuilder,我们往里面注册一个解析回调，每次opt解析我们的命令时都会执行这个回调，这个回调的格式也基本是固定的，最重要的是 Name ，这是解析得到的 passName ，我们调用 FPM.FPM.addPass(EncodeFunctionName()) 来完成注册 test.cpp123456789101112131415161718192021222324// test.cpp#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;void testFunctionA(){ std::cout &lt;&lt; &quot;testA&quot;;}void testFunctionB(){ std::cout &lt;&lt; &quot;testB&quot;;}void testFunctionC(){ std::cout &lt;&lt; &quot;testC&quot;;}int main(){ testFunctionA(); testFunctionB(); testFunctionC(); return 0;} 我们声明了三个函数，预期这三个函数的名字都会被改成114514funcxxx 输出根据pass输出的调试信息可以发现opt按照从上到下的顺序对每个函数执行了pass 然后再打开ida看看二进制文件是否真的被修改了 可以看到确实被修改了 下一篇文章可能会写一下怎么修改基本块和怎么混淆运算符","link":"/ctf/llvm/llvm0x1/"},{"title":"反调试笔记","text":"反调试是逆向工程中的常见对抗手段，这篇笔记总结了一些各种平台常见的调试检测手段，随机更新中 IsDebuggerPresent()特征最明显的反调试，因为是windows系统api所以也没法隐藏，直接读NtCurrentPeb上的beingdebugged标志，如果被调试就返回1 *(NtCurrentPeb+0x2) ( beingdebugged Flag )是上面这条的变体，实际上beingdebugged标志就在NtCurrentPeb+0x2的位置上 *(NtCurrentPeb+0x68) ( NtGlobalFlag )当进程被调试器启动时这个标志会被设置为0x70 (实际上是三个堆相关的标志被设置为111) NtCurrentPeb()-&gt;ProcessParameters-&gt;DebugFlags进程启动参数，这个标志为1时说明在被调试 NtCurrentPeb()-&gt;ProcessParameters-&gt;DebugPort调试对象的句柄，如果这个值不为NULL说明有对象在调试该进程 NtCurrentPeb()-&gt;ProcessHeap这个位置有两个标志Flags和ForceFlags用于告诉内核这个堆是否是在调试器中被创建的，正常情况下Flag=2,ForceFlags=032位windows中 Flags位于ProcessHeap+0xC ,ForceFlags位于ProcessHeap+0x1064位windows中 Flags位于ProcessHeap+0x70 ,ForceFlags位于ProcessHeap+0x74 OutputDebugString()这个函数会向调试器中输出一段字符串，如果当前程序没有被调试就会更新当前程序的错误码可以配合SetLastError先将错误码设置为一个预设值，然后调用该函数更新错误码，再用GetLastError获取新的错误码，如果新的错误码和旧的一样说明这个函数没有报错，就说明调试器存在 ZwSetInformationThread(ThreadHideFromDebugger)这个函数可以设置当前线程的一些信息，主要是优先级之类的，他的参数是一个枚举类，其中ThreadHideFromDebugger这个选项会把当前线程从调试器中抹掉，具体实现就是把DebugPort置为NULL(疑似有点草台) 扫描0xCC (int 3 指令)软件断点的工作原理是将断点位置的指令替换为 int 3 指令(编码为0xCC)，当调试器遇到 int 3 时就调用调试异常中断执行在程序执行时扫描全程序是否有0xCC就可以检测到是否存在软件断点该方法无法检测硬件断点，因为硬件断点并不修改程序指令注意到软件断点需要修改指令，所以烧录在rom中的程序无法下软件断点 PS1. 硬件断点硬件断点是用寄存器实现的断点，直接在调试寄存器中保存断点的地址，当PC跑到对应位置时中断执行，断点的数量受限于调试寄存器的数量 GetThreadContext(hThread,lpContext)这个函数可以获取对应线程的上下文信息，如果lpContext中读取的DRx系列寄存器(调试寄存器)的值不为0说明存在硬件断点，可以据此检测硬件断点 哈希校验直接计算整个程序机器码的哈希值，与正常情况下的预设值进行校验，因为软件断点会插入int 3，所以调试状态下哈希值会有不同 rdstcrdstc 可以获取cpu开机起经历的时钟周期，调用两次该函数就可以获取一段操作经历的时间，如果时间过长可以猜测存在调试器，因为调试器会极大影响程序性能 父进程检测一般正常用户态运行的程序只可能是由几个系统服务或者已知的程序启动的(cmd,explorer.exe…..)，可以通过th32ParentProcessID获取父进程的PID，在与系统中所有进程的PID进行比对，如果父进程不在上述的范围内则可以推断进程在被调试 基于VEH，SEH的反调试这个反调试其实还是利用了上述反调试的逻辑，只不过把检测的代码藏在异常处理的逻辑里，然后再手动触发一个异常来进入这段逻辑，一般直接搜索VEH就可以搜到设置veh的地方，进而找到用户自定义的handler,SEH可以去反汇编软件中寻找except包裹的部分。因为异常处理逻辑通常要跳过垃圾代码，所以这种异常通常不会选择传递给调试器(就算传给调试器调试器也会卡在垃圾代码里)，所以也可能会把一些加密的逻辑藏在异常处理中(说白了还是增加翻代码的难度，并没有什么新鲜的) SetUnhandledExceptionFilterSetUnhandledExceptionFilter()函数接受一个winapi的异常过滤器函数作为参数用来设置自定义的异常过滤器，当正常运行时，windows让异常过滤器先接管未处理的异常，此时过滤器内可以做加密相关的操作，也可以做处理异常的操作，但是调试模式下所有的异常就会传递给调试器(现代调试器已经有选择由app处理异常的选项)，此时我们又没有写处理异常的逻辑，调试器就会直接卡住 123456SetUnhandledExceptionFilter(CustomUnhandledExceptionFilter);__try{ int* p = NULL; *p = 1; }//没有 except","link":"/ctf/re-hints/%E5%8F%8D%E8%B0%83%E8%AF%95/"},{"title":"花指令笔记","text":"花指令是逆向工程中常见的对抗手法，这篇笔记整理了一些常见的花指令样本供参考，随机更新中 基于call-return修改rip的花指令call指令是一种复合指令，它会在跳转至目标地址前将下一条指令对应的地址压栈，然后在return是弹栈恢复rip，如果在return前修改栈上的数据，就可以达到修改rip的效果这是一个经典的样本，通过call跳转后把esp(栈顶)对应的值加上一定偏移，经过计算可以知道return后rip会被修改为0x413A6A+0x8=0x413A72，也就是说从0x413A65到0x413A71的这一段都是垃圾数据所以直接nop这一段可以看到nop完后线性扫描自动分析出了下面的代码 基于jz,jnz的花指令利用两个连续的jz,jnz指令可以构造出必定执行的跳转，然后中间塞垃圾数据，但是静态分析工具无法分析这种跳转，而且线性扫描扫到垃圾数据反汇编就直接炸了，修复方式也很简单，直接吧jz/jnz到跳转地址前的所有指令nop掉就行了，因为肯定不会执行到 基于 xor,cmp,jz的花指令同样是构造必定执行的跳转，以下是一种示例先保存ebx寄存器，然后把ebx寄存器置0，这样jz就必然执行，跳过垃圾数据后再恢复ebx的值 如何编写花指令编写花指令可以通过内联汇编的形式，以下是一种示例(g++) 123456789#include &lt;iostream&gt;int main(){ asm volatile(&quot;jz lable1\\n\\t&quot; &quot;jnz lable1\\n\\t&quot; &quot;.byte 0xE8, 0x23,0x24,0x25,0x26,0x27,0x28\\n\\t&quot; &quot;lable1:\\n\\t&quot;); std::cout &lt;&lt; &quot;test&quot;;} 其中 volatile 参数可以防止编译器把花指令优化掉同时在编译时要加上-fno-asynchronous-unwind-tables-fno-exceptions-fno-rtti等编译参数去除调试信息，否则反编译工具可以借助这些信息提供的控制流信息绕过花指令","link":"/ctf/re-hints/%E8%8A%B1%E6%8C%87%E4%BB%A4/"},{"title":"tour of go day1","text":"起因是本来花了好几天折腾好了libbpf的交叉编译环境，结果用libunwind用的是bionic-libc，libbpf用的是glibc，尝试用ndk编译libbpf始终无法成功，只能尝试切换到go/cilium生态，然后把libunwind用cgo的形式添加到项目中tour of go链接 go的软件都以包的形式存在，程序的入口点是main包，包名定义在程序开头 1package main go的依赖导入使用import，有两种写法 12import &quot;math&quot;import &quot;fmt&quot; 1234import( &quot;math&quot; &quot;fmt&quot;) go中符号的导入导出依赖于命名约定，大写字母开头 的符号是导出的，否则不导出 声明变量go的变量类型是定义在变量名之后的(类似ts但是不带:)，通过空格隔开，如果指定了初始值可以自动推导类型 1var a int 123func test(x int,y int) int { return x + y} go的函数可以返回多个返回值（可能是用了类似打包解包的写法） 12345678func swap(x int,y int) (int,int){ return y,x}func main(){ var x,y = 1,2 x,y = swap(x,y)} go的多个变量在一行中初始化只能把变量名全写在左边，初始值全写在右边 12var x=1,y=2 // wrong!var x,y = 1,2 // right go可以使用短变量赋值写法简化变量定义，但是短变量赋值只能在函数内部使用 1a:=10 // var a=10 基本类型go有以下几种基本类型 123456789101112131415boolstringint int8 int16 int32 int64uint uint8 uint16 uint32 uint64 uintptrbyte // uint8 的别名rune // int32 的别名 // 表示一个 Unicode 码位float32 float64complex64 complex128 其中uint,int,uintptr位数和操作系统位数相同,其他类型都是定长类型 go中的零值有0,false,&quot;&quot;,nil，未初始化的变量会被自动赋予对应类型的零值 类型转换go中没有隐式类型转换，通过type()的方式进行类型转换 12var i int = 42var j float32 = float32(i) 常量使用const声明，和变量唯一的区别就是不能使用:=简写声明 循环go语言中只有for一种循环，除了没有小括号和必须加大括号外其他和c完全一样 1234567func main() { sum := 0 for i := 0; i &lt; 10; i++ { sum += i } fmt.Println(sum)} 如果只有循环条件的话两个;也可以不写，此时就和while没什么区别了 1234567func main() { sum := 1 for sum &lt; 1000 { sum += sum } fmt.Println(sum)} ifgo的if也是不用写括号，可以在条件之前执行一句初始化语句 123456func pow(x, n, lim float64) float64 { if v := math.Pow(x, n); v &lt; lim { return v } return lim} 初始化语句的生命周期限制在if分支内和同级的else分支内 switchswitch在书写上也和if类似，go中的switch默认执行完第一个匹配的分支就会终止，除非在分支结尾加上fallthrough 12345678910switch os := runtime.GOOS; os { case &quot;darwin&quot;: fmt.Println(&quot;macOS.&quot;) case &quot;linux&quot;: fmt.Println(&quot;Linux.&quot;) default: // freebsd, openbsd, // plan9, windows... fmt.Printf(&quot;%s.\\n&quot;, os) } go中switch的case不限定为数字和常量，可以是任何值或变量甚至表达式，在运行时从上往下逐个匹配 switch正常是以表达式的结果作为分支的判断标准，这里有一种switch true的语法糖 1234567891011func main() { t := time.Now() switch { case t.Hour() &lt; 12: fmt.Println(&quot;早上好！&quot;) case t.Hour() &lt; 17: fmt.Println(&quot;下午好！&quot;) default: fmt.Println(&quot;晚上好！&quot;) }} 这样可以让一大串if else更加清楚 deferdefer是go的一种特性，带defer修饰的语句其参数会正常求值，但调用会在函数返回才时执行这个延迟采用栈结构，最先遇到的defer语句最后执行 123456789func main() { defer fmt.Println(&quot;and you&quot;) defer fmt.Println(&quot;world&quot;) fmt.Println(&quot;hello&quot;)}//hello//world//and you 指针go中的指针也是类型名前加*，也就是*Type 引用解引用都和c一样，但是没有指针运算 123456789101112func main() { i, j := 42, 2701 p := &amp;i // 指向 i fmt.Println(*p) // 通过指针读取 i 的值 *p = 21 // 通过指针设置 i 的值 fmt.Println(i) // 查看 i 的值 p = &amp;j // 指向 j *p = *p / 37 // 通过指针对 j 进行除法运算 fmt.Println(j) // 查看 j 的值} 结构体结构体采用c风格定义，通过.号访问成员，并支持{}初始化 1234567type Vertex struct { X int Y int}func main() { fmt.Println(Vertex{1, 2})} 与c中访问结构体指针的成员时需要通过-&gt;不同，go中仍然使用.，这里是自动做了解引用操作支持具名变量形式初始化，未显式初始化的成员就初始化为零值 1v2 = Vertex{X: 1} 数组数组通过[]T定义 12345678910func main() { var a [2]string a[0] = &quot;Hello&quot; a[1] = &quot;World&quot; fmt.Println(a[0], a[1]) fmt.Println(a) primes := [6]int{2, 3, 5, 7, 11, 13} fmt.Println(primes)} 结构体传参是深拷贝，直接构造新对象，数组传参也是深拷贝，切片传参因为本身有引用性质所以是浅拷贝 切片go中的数组支持切片 1a[low : high] 这个区间是左闭右开的，也就是[low,high),这个上下界也是可以省略的，和python一样分别默认值是0和数组长度切片本身是一块 引用 多块切片可以共享一个数组所拥有的一片内存 切片同样可以作为右值，[]bool{true, true, false}等价于创建了一个[3]bool{true, true, false}，然后再构造一个指向它的切片切片对应的零值是nil即空指针切片的长度可以动态修改，分别可以根据len()和cap()两个函数获取切片的长度和容量长度就是切片实际上包含的元素数，容量指的是从切片的第一个元素开始，一直到其所指向数组的末尾的元素数切片的右端点可以左右移动，但是 左端点只能往右移动也就是说s=[2:]会让s永久失去对其前两个元素的访问权 可以使用make([]T,len,cap)创建切片，三个参数分别是数组类型，长度，容量，这也是go指定的创建动态数组的方式(但是切片本身可以使用右值创建，而且切片的容量是可以自动拓展的，不理解make的意义是什么)","link":"/development/go/go0x1/"},{"title":"tour of go day2","text":"感觉光看tour of go的话3天就能全看完了 向切片批量添加元素func append(s []T, vs ...T) []Tappend的第一个参数是源切片，然后后面可以跟任意个参数作为追加元素，最后返回拼接完成的切片一般用法如下s = append(s,1,2,3)这个append会动态拓展数组容量 for rangefor range形式的循环可以用来方便的遍历切片或者Map每次迭代的参数固定为两个值，第一个是当前下标，第二个是当前下标对应的值，如果不写第二个参数就只返回下标 12345678var pow = []int{1, 2, 4, 8, 16, 32, 64, 128}func main() { pow=pow[3:] for i, v := range pow { fmt.Printf(&quot;2**%d = %d\\n&quot;, i, v) }} MapMap用于处理键值对间的映射关系，定义方法为var m map[keyType]valueType默认未初始化的Map为nil，需要用make初始化后才可对其进行操作 1234567891011121314type Vertex struct { Lat, Long float64}var m map[string]Vertexfunc main() { m = make(map[string]Vertex) m[&quot;Bell Labs&quot;] = Vertex{ 40.68433, -74.39967, } fmt.Println(m[&quot;Bell Labs&quot;])} 12345678910111213141516type Vertex struct { Lat, Long float64}var m = map[string]Vertex{ &quot;Bell Labs&quot;: Vertex{ 40.68433, -74.39967, }, &quot;Google&quot;: Vertex{ 37.42202, -122.08408, },}func main() { fmt.Println(m)} make可以加一个可选参数指定Map的初始容量与创建结构体时必须在{}前加类型名不同，初始化Map时可以省略结构体类型名 1234var m = map[string]Vertex{ &quot;Bell Labs&quot;: {40.68433, -74.39967}, &quot;Google&quot;: {37.42202, -122.08408},} Map支持直接通过下标访问元素m[key] = elemelem = m[key]使用delete删除元素delete(m, key)查询元素会返回两个值，分别是查询结果和元素是否存在，如果不存在的话则返回对应的零值和falseelem, ok = m[key] 函数值(类似函数指针)函数可以作为值传递，函数类型定义为func(argT...) retT 12345678910111213func compute(fn func(float64, float64) float64) float64 { return fn(3, 4)}func main() { hypot := func(x, y float64) float64 { return math.Sqrt(x*x + y*y) } fmt.Println(hypot(5, 12)) fmt.Println(compute(hypot)) fmt.Println(compute(math.Pow))} 函数闭包go的函数可以作为一个闭包维持函数体外的变量的生命周期，简单地说就是一个函数作为函数指针函数对象储存时，其引用的函数外的变量不会被回收，而是由这个函数维持其生命周期 1234567891011121314151617func adder() func(int) int { sum := 0 // 在adder结束后sum并不会被回收 return func(x int) int { sum += x return sum }}func main() { pos, neg := adder(), adder() // pos，neg各拥有一个独立的sum for i := 0; i &lt; 10; i++ { fmt.Println( pos(i), // 0,1,3,6.... neg(-2*i), // 0,-2,-6,-12... ) }} 为类型定义方法go中没有class的概念，但是可以为类型添加方法，然后就可以用其他语言类似的方式调用某个类型的方法 123456789101112type Vertex struct { X, Y float64}func (v Vertex) Abs() float64 { return math.Sqrt(v.X*v.X + v.Y*v.Y)}func main() { v := Vertex{3, 4} fmt.Println(v.Abs())} 注意到这里在函数名前多了(v Vertex)，go tour 中称其为receiver参数，只要带这个参数的函数都会被认为是对应类型的方法，这里的v在函数中有点类似其他语言中的this或self，但注意到这里使用的是深拷贝，调用这种类型的方法并不会修改对象的值 如果将接收者参数改为(v *Vertex)，这时v是方法所属对象的指针，现在对v做的操作就会修改调用改方法的对象的值了 方法与指针重定向对于函数而言，如果参数定义为指针，向其传非指针的操作会导致静态检查不通过，反之亦然但对于方法而言，一个定义接收者为指针的方法可以由指针或非指针调用，反之亦然，这是因为对于指针接收者方法而言，如果传递的不是指针，go会自动将其转换为指针v.method() -&gt; (&amp;v).method (这符合开发时对指针接收者方法的预期，即应该修改调用者的值)，而对于非指针方法，同样会自动进行解引用操作 当然多数情况下最好使用指针接收者，转递指针的效率要比拷贝整个结构体要高得多 接口接口是一组方法签名，可以作为类型使用，任何实现了接口所要求的所有方法的变量都可以被这个接口类型持有(也就是虚函数那一套) 123456789101112131415161718192021222324252627282930313233343536type Abser interface { Abs() float64}func main() { var a Abser f := MyFloat(-math.Sqrt2) v := Vertex{3, 4} a = f // a MyFloat 实现了 Abser a = &amp;v // a *Vertex 实现了 Abser // 下面一行，v 是一个 Vertex（而不是 *Vertex） // 所以没有实现 Abser。 a = v fmt.Println(a.Abs())}type MyFloat float64func (f MyFloat) Abs() float64 { if f &lt; 0 { return float64(-f) } return float64(f)}type Vertex struct { X, Y float64}func (v *Vertex) Abs() float64 { return math.Sqrt(v.X*v.X + v.Y*v.Y)} 注意到这里是严格区分指针的非指针方法的，也就是说你只给指针实现了方法是不能把非指针量塞进接口变量里的接口方法的实现是隐式的，也就是没有implements关键字，依靠签名匹配方法，也就是说一个方法可能会匹配多个接口接口变量可以和正常的变量一样使用，其持有其对应变量的值和类型信息 123456789101112131415161718192021222324252627282930313233type I interface { M()}type T struct { S string}func (t *T) M() { fmt.Println(t.S)}type F float64func (f F) M() { fmt.Println(f)}func main() { var i I i = &amp;T{&quot;Hello&quot;} describe(i) i.M() i = F(math.Pi) describe(i) i.M()}func describe(i I) { fmt.Printf(&quot;(%v, %T)\\n&quot;, i, i)} nil接口接口的对应的值可能为nil，即使如此接口仍可以调用其对应值的方法（因为有类型信息），此时需要在对应方法里手动处理nil的情况，注意到接口本身并不为nilnil接口是真的什么信息都没有，此时调用方法就会导致空指针错误 零接口接口可以什么方法都不定义，此时它可以接受任何类型，也就是类似void* 类型断言接口可以通过直接赋值来读取值，也可以通过类型断言读取值t := i.(T)该语句断言接口变量i保存了类型为T的值并赋值给t，此时如果保存的变量类型和T不同则会直接panict, ok := i.(T)如果加上ok参数，则在类型不同时会返回T对应的零值和false，并不会抛panic 类型选择类型选择用于处理接口可能存在多种类型的情况 12345678910111213141516func do(i interface{}) { switch v := i.(type) { case int: fmt.Printf(&quot;二倍的 %v 是 %v\\n&quot;, v, v*2) case string: fmt.Printf(&quot;%q 长度为 %v 字节\\n&quot;, v, len(v)) default: fmt.Printf(&quot;我不知道类型 %T!\\n&quot;, v) }}func main() { do(21) do(&quot;hello&quot;) do(true)} 通过将具体的类型名换成关键字type就可以获取接口底层值得类型，然后就可以写case了，注意到这个写法只能在type swtich中存在 Stringer通过实现String()方法使用Println打印自定义的类型描述 123type Stringer interface { String() string} 1234567891011121314type Person struct { Name string Age int}func (p Person) String() string { return fmt.Sprintf(&quot;%v (%v years)&quot;, p.Name, p.Age)}func main() { a := Person{&quot;Arthur Dent&quot;, 42} z := Person{&quot;Zaphod Beeblebrox&quot;, 9001} fmt.Println(a, z) // Arthur Dent (42 years) Zaphod Beeblebrox (9001 years)} Error通过实现Error方法可以定义自己的错误输出 123type error interface { Error() string} 1234567891011121314151617type ErrNegativeSqrt float64func (e ErrNegativeSqrt) Error() string{ return fmt.Sprintf(&quot;cannot Sqrt negative number: %f&quot;,float64(e))}func Sqrt(x float64) (float64, error) { if x&lt;0{ return 0,ErrNegativeSqrt(x) } return 0, nil}func main() { fmt.Println(Sqrt(2)) fmt.Println(Sqrt(-2))} 这里在sqrt的参数为负数时就返回ErrNegativeSqrt注意到fmt.Sprint在接受一个实现了error接口的值时会尝试调用其Error方法，所以这里不能直接调用fmt.Sprint，至少要先做一下类型转换，不然会陷入Error -&gt; Sprint -&gt; Error...的循环 从命令行接受参数使用os包，os.Args是一个包含了所有命令行参数的切片，os.Args[0]为程序路径","link":"/development/go/go0x2/"},{"title":"tour of go day3","text":"go tour 看完了，接下来整理Effective go 类型参数（模板类）在函数名后或者类型名后加中括号可以为其指定类型参数 123456789101112131415161718192021// Index 返回 x 在 s 中的下标，未找到则返回 -1。func Index[T comparable](s []T, x T) int { for i, v := range s { // v 和 x 的类型为 T，它拥有 comparable 可比较的约束， // 因此我们可以使用 ==。 if v == x { return i } } return -1}func main() { // Index 可以在整数切片上使用 si := []int{10, 20, 15, -10} fmt.Println(Index(si, 15)) // Index 也可以在字符串切片上使用 ss := []string{&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;} fmt.Println(Index(ss, &quot;hello&quot;))} 1234type List[T any] struct { next *List[T] val T} 协程使用go语句来启动一个新的协程 1234567891011func say(s string) { for i := 0; i &lt; 5; i++ { time.Sleep(100 * time.Millisecond) fmt.Println(s) }}func main() { go say(&quot;world&quot;) say(&quot;hello&quot;)} 启动协程时，参数的求值在当前协程中，函数的执行在新协程中，不同协程共享同样的内存空间 信道信道用于在协程中进行通信，相比sync库而言信道是一种更轻量化的同步手段，信道分为带缓冲和无缓冲两种信道由make(chan T,size)语句创建，当size为0是就是无缓冲的信道对于无缓冲信道的发送端而言，在写入数据后会先检查是否有其他协程在等待数据，如果有则直接转移数据并继续执行，否则阻塞，对于接收端而言，在接收到数据前都会阻塞，接收到后执行，此处的发送和接收都是单次事件，即接收/发送一个数据（比如一个值）后就会解除阻塞对于带缓冲信道的发送端，如果缓存已满则阻塞，否则不断往缓存中写数据，对于接收端，如果缓存中有数据则从中间取一个数据并继续执行，否则阻塞 range/closeclose语句用于永久关闭一个信道，被关闭的信道，被关闭的信道不能写入新数据，缓冲区中已有的数据读取完后就只能读取到零值，可以向&lt;-语句添加第二个参数检查信道是否已经关闭v, ok := &lt;-ch for range循环可以用于不断从信道中接收值，直到信道关闭 1234567891011121314151617func fibonacci(n int, c chan int) { x, y := 0, 1 for i := 0; i &lt; n; i++ { c &lt;- x x, y = y, x+y } close(c)}func main() { c := make(chan int, 10) go fibonacci(cap(c), c) for i := range c { fmt.Println(i) }} 关于close有两个原则，一是信道并不总是需要关闭，只有当我们想通知接收方停止接收数据时我们才需要关闭信道，二是信道总是应该由发送者关闭，因为向已关闭的信道发送数据会导致panic，这里的信号其实是单向传递的 selectselect可以用于等待多个协程，其会阻塞到某个分支可以继续执行，有点类似协程版的switch，如果有多个分支可以继续执行则会 随机 选择一个分支执行(go tour是这么说的) 123456789101112131415161718192021222324func fibonacci(c, quit chan int) { x, y := 0, 1 for { select { case c &lt;- x: x, y = y, x+y case &lt;-quit: fmt.Println(&quot;quit&quot;) return } }}func main() { c := make(chan int) quit := make(chan int) go func() { for i := 0; i &lt; 10; i++ { fmt.Println(&lt;-c) } quit &lt;- 0 }() fibonacci(c, quit)} select也支持default分支，当没有分支能执行但又不想阻塞时就可以添加default分支执行 Mutexsync.Mutex是go中最基本的互斥锁，当我们只想进行同步而不转移数据时可以利用Mutex的Lock和Unlock方法手动对协程上锁，一个技巧是使用defer调用Unlock来保证协程一定会被解锁 12345678910111213141516171819202122232425262728293031// SafeCounter 是并发安全的type SafeCounter struct { mu sync.Mutex v map[string]int}// Inc 对给定键的计数加一func (c *SafeCounter) Inc(key string) { c.mu.Lock() // 锁定使得一次只有一个 Go 协程可以访问映射 c.v。 c.v[key]++ c.mu.Unlock()}// Value 返回给定键的计数的当前值。func (c *SafeCounter) Value(key string) int { c.mu.Lock() // 锁定使得一次只有一个 Go 协程可以访问映射 c.v。 defer c.mu.Unlock() return c.v[key]}func main() { c := SafeCounter{v: make(map[string]int)} for i := 0; i &lt; 1000; i++ { go c.Inc(&quot;somekey&quot;) } time.Sleep(time.Second) fmt.Println(c.Value(&quot;somekey&quot;))}","link":"/development/go/go0x3/"},{"title":"Effective go","text":"整理Effective go中的一些杂项 注意到:=虽然是短构造语句，但其左边其实可以有已经定义过的变量，只要满足左边有一个变量是未定义的:=就是合法的，对于已经定义过的变量会进行重新赋值 go里面没有++和--，for循环中的for i:=0;i&lt;n;i++其实是一种宏，也就是说如果有两个迭代变量，就只能这么写了for i, j := 0, len(a)-1; i &lt; j; i, j = i+1, j-1 ，同时go也不能用逗号把表达式压在一个for里 switch可以通过逗号分隔的方式合并多个case 1234567func shouldEscape(c byte) bool { switch c { case ' ', '?', '&amp;', '=', '#', '+', '%': return true } return false} 可以通过给循环或分支结构打标签的方式让break结束特定的循环，比如下方的例子break Loop就是直接结束了外层循环而不是switch 12345678910111213141516171819202122Loop: for n := 0; n &lt; len(src); n += size { switch { case src[n] &lt; sizeOne: if validateOnly { break } size = 1 update(src[n]) case src[n] &lt; sizeTwo: if n+1 &gt;= len(src) { err = errShortInput break Loop } if validateOnly { break } size = 2 update(src[n] + src[n+1]&lt;&lt;shift) } } go语言中的new(T)语句返回一个T类型的填充满零值的指针，不同于c/c++中new用于在堆上分配内存，go语言中变量的生命周期由引用维护，也就是用户不需要关心变量所处的位置，从函数中返回局部变量指针也是合法的与之类似的make只能用于初始化slice,map,channal go的Array有以下几个特点 Array间的赋值是完全拷贝 Array作为参数时也是完全拷贝 Array的长度是其类型的一部分，[5]int和[10]int是两种类型 go中的格式化输出方式有fmt.Fprintf fmt.Sprintf fmt.Printf格式符有以下几种 1234567%d 10进制整数%x 16进制整数%v value，可以用于打印任何值%+v 额外打印字段名%#v 额外打印字段名和类型名%T 打印类型名%s String ，输出由该类型的Stringer接口的String()方法实现 不定长参数可以通过在类型前加...定义，然后在变量后加...解包，不定长变量包本身是一个切片func test(a ...int)切片在传参时可以用...解包 1234x := []int{1,2,3}y := []int{4,5,6}x = append(x, y...)fmt.Println(x) 枚举类是一系列常量，通常使用iota创建，下面是go创建枚举常量的示例 12345678910111213type ByteSize float64const ( _ = iota // ignore first value by assigning to blank identifier KB ByteSize = 1 &lt;&lt; (10 * iota) MB GB TB PB EB ZB YB) _被称为空白标识符，也就是for循环或函数返回时被用来忽略多余数据的那个下划线，这在go语言中是一种特殊符号，专门用于接收不需要的数据 &lt;-运算符不一定要指定目标，这在传递信号中非常好用 12345678c := make(chan int) // Allocate a channel.// Start the sort in a goroutine; when it completes, signal on the channel.go func() { list.Sort() c &lt;- 1 // Send a signal; value does not matter.}()doSomethingForAWhile()&lt;-c // Wait for sort to finish; discard sent value.","link":"/development/go/go0x4/"},{"title":"[GWCTF 2019]babyvm","text":"简单vm题，甚至可以直接对着字节码写handle 提示是vm题 打开修复下符号，确实是vm题进去修复下结构体，结构还是很明显的修完后基本知道在干什么了，直接去看text段，指令有五百多个byte，写个脚本解析 123456789101112131415161718192021222324252627282930313233343536373839404142434445i = 0f = open(&quot;output.txt&quot;, &quot;w&quot;, encoding=&quot;utf-8&quot;)cnt = 0while i &lt; len(text) and cnt &lt; 2: if text[i] == 0xF1: print(&quot;mov &quot;, end=&quot;&quot;, file=f) op = text[i+1] i += 2 num = text[i]+text[i+1]*256+text[i+2]*256*256+text[i+3]*256*256 if op == 0xE1: print(&quot;r0 = input[{}]&quot;.format(num), file=f) elif op == 0xE2: print(&quot;r1 = input[{}]&quot;.format(num), file=f) elif op == 0xE3: print(&quot;r2 = input[{}]&quot;.format(num), file=f) elif op == 0xE4: print(&quot;input[{}] = r0&quot;.format(num), file=f) elif op == 0xE5: print(&quot;r3 = input[{}]&quot;.format(num), file=f) elif op == 0xE7: print(&quot;input[{}] = r1&quot;.format(num), file=f) i += 4 elif text[i] == 0xF2: print(&quot;r0 ^= r1&quot;, file=f) i += 1 elif text[i] == 0xF5: print(&quot;readInput&quot;, file=f) i += 1 elif text[i] == 0xF4: print(&quot;rip++&quot;, file=f) i += 1 elif text[i] == 0xF7: print(&quot;r0 *= r3&quot;, file=f) i += 1 elif text[i] == 0xF8: print(&quot;swap r0 r3&quot;, file=f) i += 1 elif text[i] == 0xF6: print(&quot;r0 = r2 + 2*r1 + 3*r0&quot;, file=f) i += 1 elif text[i] == 0xF4: i += 1 cnt += 1 # print(i, hex(text[i]))f.close() 这题有个很恶心的地方，他text段有两段逻辑，并不是rip到0xF4就停止了，前一段是假flag，要用类似栈溢出的方法去第二段逻辑最后手动逆出真正的加密逻辑如下 123456789for i 1 ~ 5 input[i] ^= [i+1]input[6]=(input[8]+2*input[7]+3*input[6])*input[12]input[7]=(input[9]+2*input[8]+3*input[7])*input[12]input[8]=(input[10]+2*input[9]+3*input[8])*input[12]swap input[13] input[19]swap input[14] input[18]swap input[15] input[17] 直接逆即可注意到密文也是假的，真正的密文在一个没有交叉引用的函数里 12345678910111213141516171819202122sec = [0x69, 0x45, 0x2A, 0x37, 0x09, 0x17, 0xC5, 0x0B, 0x5C, 0x72, 0x33, 0x76, 0x33, 0x21, 0x74, 0x31, 0x5F, 0x33, 0x73, 0x72]for i in range(30, 127): if sec[8] == ((sec[10]+2*sec[9]+3*i)*sec[12]) &amp; 0xFF: sec[8] = i breakfor i in range(30, 127): if sec[7] == ((sec[9]+2*sec[8]+3*i)*sec[12]) &amp; 0xFF: sec[7] = i breakfor i in range(30, 127): if sec[6] == ((sec[8]+2*sec[7]+3*i)*sec[12]) &amp; 0xFF: sec[6] = i breaksec[15], sec[17] = sec[17], sec[15]sec[14], sec[18] = sec[18], sec[14]sec[13], sec[19] = sec[19], sec[13]for i in range(5, -1, -1): sec[i] ^= sec[i+1]for i in sec: print(hex(i), end=&quot; &quot;)","link":"/ctf/WP/buu/GWCTF%202019%20babyvm/"},{"title":"frida17.0.0 api变化","text":"前段时间发现新装的frida ts type-hint突然不能提示Java类了，去frida.re上查了发现frida17.0.0改了很多Api，还把一些Api迁移到了独立的模块里，开一篇文章记录一下 获取类型补全frida17新加了一个frida-pm包管理器，归在frida-tools这个python包下，运行frida-pm search就可以查目前可以下载哪些包Java类的就是全部移到frida-java-bridge中了,运行frida-pm install frida-java-bridge安装对应包后在ts中导入即可 1234import Java from &quot;frida-java-bridge&quot;Java.perform(() =&gt; { console.log(&quot;test&quot;);}); frida17同时添加了frida-compile这个工具，用于将ts转换为js，算是官方提供的支持，运行frida-compile your_script.ts -o your_script.js即可，输出产物和tsc输出的还是有很大不同的，把很多依赖也静态加载到产物里了 其他变化这部分内容基本摘自 https://frida.re/news/ 只列举一些比较重要的变化 异步终于有人发现enumerate系列的异步函数没啥软用了，现在enumerateXXX不再有Sync和非Sync的区别，只有同步的版本，下面这个摘自 frida.re 的例子就是新版本使用枚举函数(讲道理这样感觉正常多了) 123for (const module of Process.enumerateModules()) { console.log(module.name);} 内存读写现在内存读写被规范为只能在包装的指针上调用读写方法(ptr)，然后支持了链式调用(也看起来正常多了) 123const playerHealthLocation = ptr('0x1234');const playerHealth = playerHealthLocation.readU32();playerHealthLocation.writeU32(100); 123456const playerData = ptr('0x1234');playerData .add(4).writeU32(13) .add(4).writeU16(37) .add(2).writeU16(42) ; 模块(Module) API原先通过模块获取符号又很多种写法，现在重新规范了相关的apiModule.getSymbolByName(&quot;libc.so&quot;,&quot;open&quot;)正式被删除了现在使用Module.getGlobalExportByName('open')看起来好像也正常多了然后现在从指定模块种获取相关信息需要先调用Process.getModuleByName获取模块对象，然后再调用相关方法 123const libc = Process.getModuleByName('libc.so');const openImpl = libc.getExportByName('open');const readImpl = libc.getExportByName('read'); 事实上这种路径在老版本也适用，只是新版本删除了其他的路径，精简了api","link":"/ctf/Android/fridaApi/frida17Fix/"},{"title":"frida常用api备忘录","text":"一些frida的api备忘录这篇文章有点老了，frida 17.0.0大刀阔斧改了很多老的api，文章中的内容只对 &lt; 17.0.0 保证准确性 javascript APIProcessProcess.id : number返回目标进程的PID 1console.log(&quot;processid = &quot;, Process.id); 12$ python launch.py processid = 3819 Process.arch : String返回目标进程的架构 1console.log(&quot;processArch = &quot;, Process.arch); 12$ python launch.py processArch = x64 get和find系的函数建议使用get系,在查找失败时get抛出错误,而find返回NULLProcess.getModuleByAddress(address : NativePointer) : Module address为实际地址Process.getModuleByName(name : String) : Module 根据地址或名称返回 已加载的 目标库(.so库)的对象(Module对象)，地址需提供原生指针 123var lib: Module = Process.getModuleByName(&quot;liba0x9.so&quot;);var lb: Module = Process.getModuleByAddress(lib.base);console.log(&quot;lbname = &quot;, lb.name); 12$ python launch.pylbname = liba0x9.so Process.enumerateModules() : Module[]返回所有已加载的.so库，返回内容是Module对象组成的js数组 1234567var ls = Process.enumerateModules(); for (let i = 0; i &lt; ls.length; i++) { console.log(ls[i].base); console.log(ls[i].name); console.log(ls[i].path); console.log(&quot;------&quot;); } 123456780x768bb30ca000libgraphicsenv.so/system/lib64/libgraphicsenv.so------0x768bb6608000libgui.so/system/lib64/libgui.so..... ThreadThread.backtrace(context, backtracer) : NativePointer[]在java层不如直接调用android.util.log好用，主要用于追踪native层调用栈，通常加上this.context，backtracer有.FUZZY和.ACCURATE两种模式可选返回当前调用栈，返回类型是NativePointer组成的js数组，使用DebugSymbolfromAddress转化为可读符号 123456789var lib: Module = Module.load(&quot;liba0x9.so&quot;); console.log(lib.enumerateExports()[0].name); Interceptor.attach(lib.getExportByName(lib.enumerateExports()[0].name), { onEnter(args) { console.log(Thread.backtrace(this.context, Backtracer.ACCURATE).map(DebugSymbol.fromAddress).join('\\n')); }, onLeave(retval) { retval.replace(1337 as any); }, }) 1234$ python launch.pyJava_com_ad2001_a0x9_MainActivity_check_1flag0x768914fa0a2c libart.so!art_quick_generic_jni_trampoline+0xdc0x768914f83912 libart.so!MterpHelpers+0x1f5 ModuleModule类本身的属性 member use name : String 库名 base : NativePointer 库基地址 size : number 库大小 path : String 库的绝对路径 ModuleObj.enumerateImports() : ModuleImportDetails[]返回这个库的所有导入符号,类型为ModuleImportDetails组成的js数组 ModuleImportDetailsModuleImportDetails类的属性 member use type : ModuleImportType (function | variable) 导入符号的类型 name : String 导入符号的名称 module : String 导入符号来自哪个文件 address : NativePointer 导入符号在内存中的地址(绝对地址)，用于直接调用或修改导入函数 slot : NativePointer 导入表中指向导入函数的指针,用于重定向导入函数 123var lib: Module = Module.load(&quot;liba0x9.so&quot;);var ls = lib.enumerateImports();console.log(ls[0].name, &quot;from module :&quot;, ls[0].module); 12$ python launch.py __cxa_finalize from module : /apex/com.android.runtime/lib64/bionic/libc.so ModuleObj.enumerateExports() : ModuleExportDetails[]返回这个库的所有导出符号,类型为ModuleExportDetails组成的js数组 member use type : ModuleExportType (function | variable) 导出符号的类型 name : String 导出符号的名称 address : NativePointer 导出符号在内存中的地址(绝对地址)，用于直接调用或修改导出函数 ModuleObj.getExportByName(exportName : String) : NativePointer根据名称返回对应导出符号的指针，是frida hook native层函数的主要方法 Module.load(name : String) : Module根据名称(是的就是名称，至少vsc的frida type hint 里提示的是输入名称)返回对应native库的对象，与Process.getModuleByxxx的不同是该方法无需目标库已被加载，且使用该方法可以手动加载目标库 12var lib: Module = Module.load(&quot;libfrida0xa.so&quot;);console.log(lib.name); 12$ python launch.pylibfrida0xa.so Module.ensureInitialized(name : String) : void在目标库加载完成前阻塞程序进行 Module.getBaseAddress(name : String) : NativePointer返回目标库的基地址,等同于Module.load(name).base Module.getExportByName(moduleName : String | null, exportName : String) : NativePointer根据库名和符号名查找对应的导出符号，库名可缺省，此时在全局对该符号进行搜索 MemoryMemory.scan(address : NativePointer, size : number, pattern : String, callbacks : MemoryScanCallbacks) : void这是一个异步函数，用于在内存中扫描对应的模式，address指定了起始地址，size指定了扫描的字节数pattern是一个模式串，必须为以下任意的格式之一1.完全匹配 “1F 13 00 2F”2.通配符 “?F 13 00 ??” 其中?在匹配时可以是0~F中的任意一个3.掩码 “”13 37 13 37 : 1F FF FF F1”” 后面的为掩码，掩码中为1的位表示需要匹配，为0的位则可以是任意值 MemoryScanCallbacksMemoryScanCallbacks 是一个结构体，定义如下 1234567{ onMatch(address : NativePointer, size : number) : function //匹配成功的回调函数，address为成功匹配的地址，size为匹配到的长度 //该函数可通过 return 'stop' 提前结束 onError(reason : String) : function //处理错误的回调函数 onComplete() ： function //匹配结束的回调函数} 这个函数的同步版本为Memory.scanSync(address, size, pattern),返回由匹配到的address和size组成的对象的数组 Memory.protect(address : NativePointer, size : number, protection : String) : boolean修改对应位置内存的权限，返回true表示操作成功，protection为形同”rwx”的字符串 Memory.patchCode(address : NativePointer, size : number, apply : function) : voidapply里是具体要对内存进行修改的操作，address为起始地址，size为修改区域的字节数 NativeFunction获取native层函数的引用 NativeFunction(address, returnType, argTypes[, abi])创建方法var func = new NativeFunction(address, returnType, argTypes[, abi])address : NativePointer 函数地址returnType : [type] 返回类型argTypes : [types…] 参数类型 1const getFlag = new NativeFunction(getFlagPtr, ['void'], ['int', 'int']); // 用例 可用类型 123456789101112131415161718192021voidpointerintuintlongulongcharucharsize_tssize_tfloatdoubleint8uint8int16uint16int32uint32int64uint64bool NativeCallback创建一个native函数回调并返回其指针，实际上就是由js层创建了一个native函数，可以传给native层与 NativeFunction 的区别是 NativeFunction 是从native层到js层，而 NativeCallback 是创建自己的原生函数创建方法new NativeCallback(func, returnType, argTypes[, abi])func是函数的js实现，其他和 NativeFunction 均相同 Interceptorfrida最重要的模块之一，用于hook native函数， Interceptor.attach( target , callbacks )target 为 NativePointer ,callback为 {onEnter: Function(args) , onLeave: Function (retval) }的经典组合注意此处虽然大多数情况下是hook函数，但是只要访问目标地址就会触发回调，所以也可以用base+offset来跟踪特定位置的内存Interceptor.attach 同样会返回一个对当前拦截器的引用，可以调用self.detach()方法解除当前拦截器Interceptor还有一个重要的点就是他一次回调中的的onEnter和onLeave共享一个上下文，也就是 context ，这个context中可以根据约定的寄存器名任意读写寄存器(context.x0 context.rax … 可能IDE会飘红，但这是frida ts-gum没有为这些寄存器解析语法导致的，不影响)，同时根据共享上下文的特点还可以做一些别的操作，因为js的语法特点一个对象上可以动态挂任意属性，比如实现在一个so库加载后立刻进行hook(当然不会比.init_array早)，实现方法就是hook安卓的 android_dlopen_ext 方法，在onEnter的时候可以在context上挂上传入的库的名字，然后再onLeave里检测到是目标so后立刻执行hook回调就算里面是空的也会影响性能，所以如果你有一个空的onEnter或者onLeave，直接删掉就行 123456789101112// 该拦截器在触发第6次hook后会自动解除var cnt = 0; let cnthook = Interceptor.attach(lib.base.add(0x170B8), { onEnter: function () { console.log(&quot;some memory accessed&quot;); cnt++; console.log(cnt) if (cnt &gt; 5) { cnthook.detach(); } } }) TODO:JavaXXXWriterXXXRelocatorhexdumprpc.exportsTiming events Python APIfrida的python层主要负责拉起进程以及与js通信，涉及的业务逻辑并不多 参考链接Frida 官方文档Frida-Labs","link":"/ctf/Android/fridaApi/fridaApi/"},{"title":"fingerprint-js-Pro采集项分析","text":"fingerprint.js Pro v3,近100多个采集项，只有压缩无混淆，直接开干有几个stage2的条目挺奇怪的，里面的解密函数在chrome138上跑不起来，其余均分析完毕 总览根据文档用这个脚本直接从cdn上把他的脚本文件拉下来，所有的代码都在fYicOuiT1WRGwuZgAESv.js这个文件里，小7000行还算ok，只有压缩无混淆，用prettier格式化后还算能看，大部分工作量在重命名压缩后损失的符号，先总体看下业务逻辑 1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt; &lt;title&gt;FingerprintJS Example&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;FingerprintJS Example&lt;/h1&gt;&lt;script&gt; // Initialize the agent on page load. const fpPromise = import('https://fpjscdn.net/v3/fYicOuiT1WRGwuZgAESv') .then(FingerprintJS =&gt; FingerprintJS.load({ region: &quot;ap&quot; })) // Get the visitorId when you need it. fpPromise .then(fp =&gt; fp.get()) .then(result =&gt; { const visitorId = result.visitorId console.log(visitorId) })&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 这个一个巨大的字典序列一看就是采集项，先看看这玩意怎么跑起来的 导出的函数是load，可以看到load里填充了一下配置项，然后就是跑服务这里前面做了一大堆初始化，就不展示了，initSandbox是初始化了一个iframe,因为有些测试项需要添加DOM元素，所以需要在隔离的iframe里做这里看到就是把module里的stage拆出来然后开始准备跑这里就可以看到,stage里是一堆函数，然后并发的调用了这些函数，注意到这个context是传给stage[e]的第一个参数(用bind绑定)，这点非常重要，因为这样后面分析每个采集函数时遇到的不知道什么类型还找不到引用的参数基本都可以确定是是这里的context，然后就可以去runService里找上下文里填充了什么对象，根据对象名判断到底调了浏览器里的什么东西 也就是说那个stage列里面是一堆worker函数，那一个个函数看过去就好了 总表Stage1 项目ID 函数名 实际功能 s94 ia tls支持检测，似乎tls指纹检测在服务端 Stage2 项目ID 函数名 实际功能 s52 pc voiceInfoHash 获取浏览器语音支持信息 s6 Ki ScreenSize 页面尺寸信息 s58 Rc PlatformInfoFromList 测试一些平台信息 s20 lc Font 测试字体支持 s36 Ji has_AdBlocker 测试有没有广告拦截插件 s51 zi test_font_width 测试字体宽度 s21 qi audio_data 采集浏览器音频数据指纹 s79 Wc s69 Sc IframeUrl 逐层遍历iframe到顶层并获取各层url s23 us webkitRequestFileSystem 测试webkitRequestFileSystem是否可用 s29 is storageQuota 获取当前域名分配的储存空间 s84 ss Sandbox_Iframe_width_height 获取iframe沙箱的宽高 s85 ds test_indexDB 测试indexDB能否正常储存 s89 Pc storage.getDirectory 测试storag.getDirectory()能否调用 s17 du canvas_test 测试Canvas指纹和支持 s87 Vs system_color 测试系统颜色支持 s92 Zs mathML 测试mathML数学符号支持 s93 Ds emoji 测试emoji符号支持 s95 Ea s97 Aa s70 Fa Stage3 项目ID 函数名 实际功能 s22 Hc wasm 测试wasm相关功能是否支持 s30 Zc doNotTrack 检查doNotTrack属性 s33 ec Brave Brave浏览器 s44 oc theme_color 颜色主题 s45 uc Time 获得用户本地时间与UTC时间的差值 s49 dc PerformanceIntervals 获取设备时间戳精度 s50 vc jsHeapSizeLimit 获取js堆大小 s57 Uc devicePixelRatio s59 Yu IE 检查IE浏览器相关属性是否存在 s60 Xu Edge 检查Edge浏览器相关属性是否存在 s61 Ju Chrome s62 zu Apple 是否为apple平台 s63 qu Safari s64 Ku Firefox s65 Qu mobile 是否为移动平台 s66 Cu attributionSourceId 测试&lt;a&gt;&lt;/a&gt;中的这个属性 s68 nc new_api 测试几个特定api s71 Ac origin 检测页面来源链接 s24 Lc get_eval_toString_length 对eval调用toString然后获取结果的长度 s72 Cc webdriver 典中典属性 s1 Qi oscpu 架构属性（现代多数弃用） s2 nu language 语言列表 s3 tu colorDepth 屏幕色深 s4 eu deviceMemory 获取设备内存近似值 s5 ru height_width 获取屏幕宽高 s7 ou hardwareConcurrency 获取设备线程数 s9 iu timezone 获取时区 s10 uu sessionStorage 测试相应api是否为null s11 cu localStorage 测试相应api是否为null s12 ls has_indexedDB 测试相应api是否为null s13 su openDatabase 测试相应api是否为null s14 au get_cpuClass_ s15 lu is_ipad_or_iphone_ s16 fu plugins s19 mu touch_event 测试touchEvent是否可用 s27 vu vendor 获取vendor属性 s28 hu vendor_keys 获取一些和平台相关的key s32 pu cookie 测试cookie是否开启 s37 gu color_gamut 测试色域 s41 wu invert_color 测试反色是否开启 s39 yu force_color 测试是否强制使用某颜色设置 s42 bu monochrome 获取色深 s38 Eu perfer_contrast 获取对比度偏好 s43 Ru motion_set 获取动画设置 s40 Iu dynamic_range_set 获取色彩范围 s46 ku Math_func_test_hash 测试三角函数和对数相关的函数返回值 s80 Au pdfViewerEnabled s81 Lu NaN_imply 获取NaN的内存表示 s82 rs language_ 又调了一次上面的获取语言的函数。。 s83 os language_ 连在一起还调用了一次。。 s86 vs no_storage 似乎是测试是否禁用本地储存 s91 Su transparency_set 获取透明度设置 s96 Pu AudioLatency 获取音频处理的AudioLatency属性 s98 La serviceWorker 检查属性 s99 Ca isSecureContext 检查属性 s200 Za timeStamp 获取一个时间戳 s201 tc new_web_api 测试几个api s202 _u locale 似乎是获取地区 s74 Tu webgl_context_info 获取webgl信息 s75 Ou webgl_infos 其他的webgl信息 s76 hc webgl_render_data 测试webgl渲染指纹 其他参数还有一些参数不在stage里面，看了看似乎也和采集关系不大 项目ID 函数名 实际功能 s55 nl 获取本地存储和cookie中的_vid_t值 s48 gc 获取一段伪随机序列 tls项似乎是自实现的tls传输函数，用来上传数据的 stage2stage1只有一个项目，而且非常的长，不知道是什么，先看stage2 voiceInfoHash这里是从window中获取浏览器语音序列，然后由r这个函数转换成json再转字符串后调murmurhash3转换成哈希值注意到这里如果获取不到语音序列(speechSynthesis没有addEventListener成员，推测是为了防止一些指纹浏览器内置一个空的speechSynthesis)会调用两个属性检查函数，暂时没发现这两组属性有啥联系 ScreenSize这个函数比较简单，就是测一下窗口尺寸和是否全屏 getPlatformInfoFromList这个函数获取一些UA和平台信息主要拿以下几个key Font这个函数对列表里预置的字体进行测试，他有一个CSS标准字体列表和测试字体列表，通过比对测试字体和标准字体渲染出的文字的实际宽高是否不同来对比浏览器是否支持对应字体 has_AdBlocker这个函数测试用户是否安装了某几个广告拦截器测试方法是先收集了一些广告拦截器默认会拦截的DOM元素属性，然后添加含这些属性的元素，再检查这几个元素的parentNode属性（如果被广告拦截器删掉的话parentNode会为null） test_font_width这个函数前面又把生成iframe沙箱的逻辑重写了一遍，直接看下面传给沙箱的函数这里还是比较简单的，就是选择了几个字体，然后测试了他们的宽度 audio_data这个函数生成了一段测试音频，然后对其采样值的前4500个数据的绝对值求和作为浏览器指纹的参考数据 IframeUrl这个函数从这个页面所在的iframe开始尝试逐层向上遍历iframe嵌套结构并获取每一层iframe的url，应该是为了识别当前页是否被嵌套 webkitRequestFileSystem这个函数通过在webkitRequestFileSystem申请1字节内存；来测试api是否可用如果是检测到较新版本chrome则不测试，可能是因为新版本chrome弃用了这个api storageQuota尝试从webkitTemporaryStorage和storage两个成员中获取储存空间大小信息 Sandbox_Iframe_width_height获取iframe的宽高，有点意味不明 test_indexDB随机创建的一个indexDB并尝试储存一个数据（似乎前提是要先检测到为safari或firefox浏览器） storage_getDirectory测试storage.getDirectory方法能否调用 canvas_test测试canvas指纹 system_color在沙箱里生成一堆不同颜色的div测试系统颜色支持 mathML生成一些数学公式并测试符号的渲染情况 emoji测试浏览器emoji图案支持 stage3wasm5段测试demo测试不同的wasm功能，然后通过bitmask保存测试结果 doNotTrack直接获取doNotTrack属性 Brave测试是否为Brave浏览器（似乎是国外的一种隐私浏览器）并测试是否开启随机canvas指纹功能 theme_color测试用户颜色主题 Time计算用户本地时间和utc时间的差值 PerformanceIntervals连续调用window.performance.now()，记录间隔时间中最小和次小的获取设备时钟精度 jsHeapSizeLimit获取堆大小 devicePixelRatio获取devicePixelRatio属性的值 IE检查了几个微软开头的key Edge这个应该是检查Edge,并且和IE区别开了 Chrome检查chrome浏览器 Apple测试apple平台的标签 Safari测试safari浏览器 Firefox测试firefox浏览器 mobile测试是否为移动平台 attributionSourceId测试attributionSourceId属性，但是chrome138上没找到这个属性 new_api测试几个比较新的api(存疑)，暂时没出来这个几个api有什么共性，有几个看着是跟隐私相关的(geolocation webRTC) origin获取当前页面来源及其父级来源，大概可以检测嵌入之类的 eval_toString_length对eval调用toString然后获取结果的长度，据说不同js引擎这个返回值都是不一样的下面是claude 4.0 给出的例子 12345678// Chrome/V8eval.toString() // &quot;function eval() { [native code] }&quot;// Firefox/SpiderMonkey eval.toString() // &quot;function eval() {\\n [native code]\\n}&quot;// Safari/JavaScriptCoreeval.toString() // &quot;function eval() { [native code] }&quot; webdriver简单直接，直接获取webdriver属性 oscpu获取oscpu属性，似乎现代浏览器不少都弃用了这个api language获取浏览器语言列表 colorDepth获取屏幕色深 deviceMemory获取设备内存近似值 height_width获取屏幕宽高(stage2还有个类似的函数，那个是返回屏幕边距的) hardwareConcurrency获取设备线程数 timezone获取设备时区 sessionStorage,localStorage,indexedDB,openDatabase这几个都是测试api是否为Null cpuClass获取cpuClass属性，chrome138上无 is_ipad_or_iphone似乎是根据宽高比判断是ipad还是iphone plugins获取内置插件列表，也是典中典了 touch_event获取最多触点数以及touchEvent是否可用 vendor获取浏览器厂商标签 vendor_keys匹配一些和厂商相关的标签 cookie测试是否开启cookie color_gamut,invert_color_,force_color_,monochrome_test,perfer_contrast_,motion_set_,dynamic_range_set_,transparency_set_这些都是和画面设置相关的参数获取 Math_func_test_hash测试三角函数和对数函数，并将结果hash保存 pdfViewerEnabled如图 NaN_imply获取NaN的具体内存表示（似乎不同的js引擎实现这个值是不同的） no_storage似乎是测试是否禁用本地储存，有一个属性在win上获取不到 AudioLatency获取AudioLatency属性 serviceWorker检查serviceWorker是否存在 isSecureContext检查isSecureContext的值 timeStamp获取一个时间戳 new_web_api没看懂这几个api之间的关联 locale获取语言地区 webgl_context_info获取webgl信息，渲染驱动，厂商之类的 webgl_infos获取一些别的webgl相关的信息用于生成指纹 webgl_render_data运行一小段渲染程序获取当前webgl引擎的渲染指纹 注释版的采样代码fYicOuiT1WRGwuZgAESv.js","link":"/ctf/%E5%88%86%E6%9E%90%E9%A1%B9%E7%9B%AE/fingerprint-js/"},{"title":"[XCTF Final 2025]Rewrite it in Rust","text":"说实话深度不是特别高 附件给了一个js，一个html，一个wasm简单看了下,js就是标准的wasm加载框架代码，python -m http.server先看下这个网页长什么样 看到是一个模拟终端，其他啥都没有，直接去看wasm好了用ghidra反编译在作弊函数列表可以看到一系列以obfstr开头的函数，结合上下文可以发现是对解密字符串资源地址然后再通过异或解密字符串因为ghidra输出的反编译是类c，这里直接把加密抠出来先手动解密出地址，然后再手动解密字符串部分解密出的字符串如注释所示可以看到这里是在对用户的输入进行比对，要求参数是su -p，我们随便在终端里试一下看来是需要密码，查看一下下面的加密流程这里似乎是创建了一个缓冲区，然后是大量的wgpu调用，看起来是把输入填充到缓冲区后采用gpu计算 gpu上运行的着色器对象是由createShaderModuleAPI创建的，这个API只能在js层，我们直接插入代码打印着色器对象的具体代码，这样就不用从wasm里翻了可以获取到如下的着色器代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172struct _in_block { inner: array&lt;u32&gt;,}var&lt;private&gt; g_1_1: vec3&lt;u32&gt;;@group(0) @binding(0) var&lt;storage&gt; _in: _in_block;@group(0) @binding(1) var&lt;storage, read_write&gt; _out: _in_block;fn qR(s: ptr&lt;function, array&lt;u32, 16&gt;&gt;, a: u32, b: u32, c: u32, d: u32) { let _e57 = (*s)[a]; let _e59 = (*s)[b]; (*s)[a] = (_e57 + _e59); let _e63 = (*s)[d]; let _e65 = (*s)[a]; (*s)[d] = (_e63 ^ _e65); let _e69 = (*s)[d]; let _e73 = (*s)[d]; (*s)[d] = ((_e69 &lt;&lt; bitcast&lt;u32&gt;(16u)) | (_e73 &gt;&gt; bitcast&lt;u32&gt;(16u))); let _e79 = (*s)[c]; let _e81 = (*s)[d]; (*s)[c] = (_e79 + _e81); let _e85 = (*s)[b]; let _e87 = (*s)[c]; (*s)[b] = (_e85 ^ _e87); let _e91 = (*s)[b]; let _e95 = (*s)[b]; (*s)[b] = ((_e91 &lt;&lt; bitcast&lt;u32&gt;(12u)) | (_e95 &gt;&gt; bitcast&lt;u32&gt;(20u))); let _e101 = (*s)[a]; let _e103 = (*s)[b]; (*s)[a] = (_e101 + _e103); let _e107 = (*s)[d]; let _e109 = (*s)[a]; (*s)[d] = (_e107 ^ _e109); let _e113 = (*s)[d]; let _e117 = (*s)[d]; (*s)[d] = ((_e113 &lt;&lt; bitcast&lt;u32&gt;(8u)) | (_e117 &gt;&gt; bitcast&lt;u32&gt;(24u))); let _e123 = (*s)[c]; let _e125 = (*s)[d]; (*s)[c] = (_e123 + _e125); let _e129 = (*s)[b]; let _e131 = (*s)[c]; (*s)[b] = (_e129 ^ _e131); let _e135 = (*s)[b]; let _e139 = (*s)[b]; (*s)[b] = ((_e135 &lt;&lt; bitcast&lt;u32&gt;(7u)) | (_e139 &gt;&gt; bitcast&lt;u32&gt;(25u))); return;}fn xY(z: u32) -&gt; array&lt;u32, 16&gt; { var t: array&lt;u32, 16&gt; = array&lt;u32, 16&gt;(); var i: u32 = u32(); var var_for_index: array&lt;u32, 8&gt; = array&lt;u32, 8&gt;(); var w: array&lt;u32, 16&gt; = array&lt;u32, 16&gt;(); var r: u32 = u32(); var j: u32 = u32(); t[i32()] = 1768978533u; t[1i] = 1948281188u; t[2i] = 1701603695u; t[3i] = 2054299764u; i = u32(); loop { let _e67 = i; if !((_e67 &lt; 8u)) { break; } var_for_index = array&lt;u32, 8&gt;(2778944304u, 2710134585u, 1612543563u, 1172917921u, 3846223579u, 2389091675u, 972033108u, 274738666u); let _e70 = i; let _e73 = i; let _e75 = var_for_index[_e73]; t[(4u + _e70)] = _e75; continue; continuing { let _e76 = i; i = (_e76 + 1u); } } t[12i] = z; t[13i] = 888566743u; t[14i] = 3797923964u; t[15i] = 2911175433u; let _e82 = t; w = _e82; r = u32(); loop { let _e83 = r; if !((_e83 &lt; 10u)) { break; } qR((&amp;w), u32(), 1u, 2u, 3u); qR((&amp;w), 4u, 5u, 6u, 7u); qR((&amp;w), 8u, 9u, 10u, 11u); qR((&amp;w), 12u, 13u, 14u, 15u); qR((&amp;w), u32(), 4u, 8u, 12u); qR((&amp;w), 1u, 5u, 9u, 13u); qR((&amp;w), 2u, 6u, 10u, 14u); qR((&amp;w), 3u, 7u, 11u, 15u); qR((&amp;w), u32(), 5u, 10u, 15u); qR((&amp;w), 1u, 6u, 11u, 12u); qR((&amp;w), 2u, 7u, 8u, 13u); qR((&amp;w), 3u, 4u, 9u, 14u); continue; continuing { let _e86 = r; r = (_e86 + 1u); } } j = u32(); loop { let _e88 = j; if !((_e88 &lt; 16u)) { break; } let _e91 = j; let _e94 = w[_e91]; let _e95 = j; let _e97 = t[_e95]; w[_e91] = (_e94 + _e97); continue; continuing { let _e99 = j; j = (_e99 + 1u); } } let _e101 = w; return _e101;}fn m_inner(g: vec3&lt;u32&gt;) { var k: u32 = u32(); var var_for_index_1_: array&lt;u32, 16&gt; = array&lt;u32, 16&gt;(); let _e56 = (g.x * 16u); if (_e56 &gt;= arrayLength((&amp;_in.inner))) { return; } let _e60 = xY(g.x); k = u32(); loop { let _e61 = k; if !((_e61 &lt; 16u)) { break; } var_for_index_1_ = _e60; let _e64 = k; let _e68 = k; let _e72 = _in.inner[(_e56 + _e68)]; let _e73 = k; let _e75 = var_for_index_1_[_e73]; _out.inner[(_e56 + _e64)] = (_e72 ^ _e75); continue; continuing { let _e77 = k; k = (_e77 + 1u); } } return;}fn m_1() { let _e50 = g_1_1; m_inner(_e50); return;}@compute @workgroup_size(64, 1, 1) fn m(@builtin(global_invocation_id) g_1_: vec3&lt;u32&gt;) { g_1_1 = g_1_; m_1();} 根据4*4矩阵的魔数填充和20轮迭代可以推测这是ChaCha20算法，先不看他是不是魔改了，继续往后看可以看到这里输出了刚刚的错误提示，所以查看isSuper这个标志是在哪里设置的看到这里有个明显的循环比对结构，查看一下他的参数是哪里来的有一个是调了AES来的 另一个可以看到是从gpu里读出来的 然后检查一下那个aes，发现是一个解密过程，也就是整体流程是输入用ChaCha20加密后，与AES解密的数据比对所以我们从提出来数据后先AES解密，在ChaCha20解密即可贴一下赛时AI搓的解密 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174from Crypto.Cipher import AESfrom Crypto.Util.Padding import unpadimport struct# AES 参数 - 注意顺序!# 从反编译代码: const_aes::aes::cbc::&lt;&gt;::decrypt::h314e8f9f5e7eb882(&amp;local_18,0x100278,0x100298);# 参数顺序: (output, key_addr, iv_addr)data = [0x0b, 0xdf, 0x65, 0x3c, 0x6e, 0x13, 0xab, 0x6e, 0xb6, 0x3c, 0x0a, 0x7f, 0xf7, 0x04, 0x2d, 0x3a, 0xf0, 0xd4, 0x7f, 0x18, 0xb0, 0xc8, 0x79, 0xcd, 0xf0, 0xdf, 0x95, 0xa1, 0x24, 0x0f, 0xab, 0x42]# 从代码看: 0x100278是key, 0x100298是IV# 数据的前16字节应该是IV,后16字节是keyaes_iv = bytes(data[16:]) aes_key = bytes(data[:16])print(f&quot;AES Key: {aes_key.hex()}&quot;)print(f&quot;AES IV: {aes_iv.hex()}&quot;)# 完整的 AES 加密数据aes_enc_data = bytes([ 0xb3, 0x9f, 0xc8, 0xe2, 0x35, 0xfa, 0xd2, 0x2c, 0x3a, 0xd1, 0x6f, 0x37, 0xe7, 0xd9, 0x9c, 0x6a, 0x0e, 0xb0, 0x42, 0xc6, 0x7c, 0xe9, 0x11, 0x44, 0xaf, 0x3d, 0x28, 0xda, 0xe1, 0xb5, 0x45, 0x80, 0x5b, 0xeb, 0x4d, 0x32, 0xee, 0x24, 0xc4, 0xd8, 0x0d, 0x2e, 0x61, 0xfd, 0x4a, 0xe1, 0x6d, 0x99, 0x6c, 0xac, 0x6a, 0x15, 0xc2, 0x78, 0x0a, 0x38, 0x00, 0x94, 0x38, 0x59, 0x51, 0xed, 0xc7, 0xa4, 0xed, 0x6f, 0x60, 0xe0, 0xb9, 0xf3, 0x4d, 0xb1, 0x25, 0x37, 0x93, 0x1e, 0xf6, 0x8b, 0x0e, 0x6b, 0x62, 0x42, 0x87, 0x5a, 0x41, 0xae, 0xc5, 0x98, 0x80, 0xb0, 0x1a, 0x85, 0x3d, 0x21, 0xb4, 0x5a, 0x5e, 0xf9, 0x09, 0xfa, 0xd3, 0x32, 0x58, 0x56, 0xf8, 0xed, 0xeb, 0x48, 0x83, 0x7d, 0xc9, 0x22, 0x8f, 0x97, 0x4e, 0xf7, 0x17, 0x25, 0x48, 0x82, 0x15, 0xe2, 0xa0, 0x84, 0x4e, 0x48, 0x05, 0xff, 0x59, 0xe3, 0xf5, 0xcb, 0x0b, 0xdc, 0x18, 0x54, 0x4f, 0xe5, 0xe5, 0x19, 0x1c, 0x2d, 0xb2, 0xf7, 0xa7, 0xee, 0xae, 0x00, 0xb1, 0xb9, 0x54, 0x48, 0x68, 0xe5, 0xed, 0x31, 0x12, 0xf4, 0x8b, 0xd5, 0x6c, 0xe7, 0x3e, 0x26, 0x3c, 0xa1, 0x32, 0x87, 0xf3, 0x19, 0x84, 0x10, 0x6a, 0x00, 0xd5, 0x68, 0x38, 0x01, 0x7a, 0x89, 0xc0, 0x12, 0xbc, 0x19, 0xdf, 0x91, 0x86, 0xdd, 0x15, 0x20, 0xfd, 0xeb, 0xa5, 0xc8, 0xbc, 0x93, 0xf1, 0xbb, 0x96, 0x81, 0x5d, 0xb4, 0xeb, 0x82, 0x5a, 0x5a, 0x5b, 0x72, 0x25, 0x61, 0x8a, 0x6e, 0x3e, 0x89, 0x77, 0x22, 0xa8, 0x7e, 0xb9, 0xcd, 0x01, 0x86, 0x71, 0xeb, 0xf1, 0xa1, 0x4b, 0x4b, 0x81, 0x34, 0x35, 0x9b, 0x69, 0x53, 0xa4, 0xb3, 0x6c, 0xc0, 0x44, 0xc8, 0x9b, 0x8b, 0x89, 0x72, 0xd7, 0x54, 0x03, 0x8d, 0x2c, 0x8e, 0x4c, 0x01, 0x5a, 0x6f, 0x24, 0x3c, 0x3d, 0x13, 0x4c, 0x83, 0x2a, 0x50, 0xac, 0x94, 0x7f, 0xb2, 0x85, 0xb0, 0x9e, 0x8f, 0x54, 0x44, 0x01, 0x1d, 0xcc, 0xd7, 0x52, 0x16, 0xad, 0x7c, 0x30, 0x37, 0x61, 0x2b, 0x91, 0x8b, 0xe8, 0x82, 0x5a, 0x25, 0x15, 0x90, 0xb4, 0xde, 0x2c, 0xec, 0x6e, 0x5c, 0xd3, 0xa9, 0x8f, 0x0c, 0x73, 0x04 ][:256])print(f&quot;\\n=== Step 1: AES-CBC 解密 ===&quot;)print(f&quot;密文长度: {len(aes_enc_data)} bytes&quot;)aes_cipher = AES.new(aes_key, AES.MODE_CBC, aes_iv)try: aes_decrypted = unpad(aes_cipher.decrypt(aes_enc_data), AES.block_size) print(&quot;成功 unpad&quot;)except ValueError as e: print(f&quot;Unpad 失败: {e}, 使用原始解密结果&quot;) aes_cipher = AES.new(aes_key, AES.MODE_CBC, aes_iv) aes_decrypted = aes_cipher.decrypt(aes_enc_data)print(f&quot;AES 解密长度: {len(aes_decrypted)} bytes&quot;)print(f&quot;AES 解密结果 (前64字节): {aes_decrypted[:64].hex()}&quot;)# 检查是否是有效的 uint32 数组if len(aes_decrypted) % 4 != 0: print(f&quot;警告: 解密结果长度不是4的倍数!&quot;)print(&quot;\\n=== Step 2: ChaCha20 解密 ===&quot;)# ChaCha20 常量 (从 shader 代码)CHACHA_CONSTANTS = [1768978533, 1948281188, 1701603695, 2054299764]CHACHA_KEY = [ 2778944304, 2710134585, 1612543563, 1172917921, 3846223579, 2389091675, 972033108, 274738666]CHACHA_NONCE = [888566743, 3797923964, 2911175433]def rotl(x, n): &quot;&quot;&quot;32位循环左移&quot;&quot;&quot; return ((x &lt;&lt; n) &amp; 0xFFFFFFFF) | (x &gt;&gt; (32 - n))def quarter_round(state, a, b, c, d): &quot;&quot;&quot;ChaCha20 Quarter Round - 完全按照 shader 实现&quot;&quot;&quot; state[a] = (state[a] + state[b]) &amp; 0xFFFFFFFF state[d] = state[d] ^ state[a] state[d] = rotl(state[d], 16) state[c] = (state[c] + state[d]) &amp; 0xFFFFFFFF state[b] = state[b] ^ state[c] state[b] = rotl(state[b], 12) state[a] = (state[a] + state[b]) &amp; 0xFFFFFFFF state[d] = state[d] ^ state[a] state[d] = rotl(state[d], 8) state[c] = (state[c] + state[d]) &amp; 0xFFFFFFFF state[b] = state[b] ^ state[c] state[b] = rotl(state[b], 7)def chacha20_block(counter): &quot;&quot;&quot;生成一个 ChaCha20 块 - 完全按照 shader xY 函数&quot;&quot;&quot; # 初始状态 (shader 中的 t 数组) state = [0] * 16 state[0:4] = CHACHA_CONSTANTS state[4:12] = CHACHA_KEY state[12] = counter state[13:16] = CHACHA_NONCE working_state = state.copy() # 10 个 double round for _ in range(10): # qR((&amp;w), u32(), 1u, 2u, 3u); quarter_round(working_state, 0, 1, 2, 3) quarter_round(working_state, 4, 5, 6, 7) quarter_round(working_state, 8, 9, 10, 11) quarter_round(working_state, 12, 13, 14, 15) # qR((&amp;w), u32(), 4u, 8u, 12u); quarter_round(working_state, 0, 4, 8, 12) quarter_round(working_state, 1, 5, 9, 13) quarter_round(working_state, 2, 6, 10, 14) quarter_round(working_state, 3, 7, 11, 15) # qR((&amp;w), u32(), 5u, 10u, 15u); quarter_round(working_state, 0, 5, 10, 15) quarter_round(working_state, 1, 6, 11, 12) quarter_round(working_state, 2, 7, 8, 13) quarter_round(working_state, 3, 4, 9, 14) # w[_e91] = (_e94 + _e97); for i in range(16): working_state[i] = (working_state[i] + state[i]) &amp; 0xFFFFFFFF return working_statedef chacha20_decrypt(ciphertext_bytes): &quot;&quot;&quot;解密 - 按照 shader m_inner 函数的逻辑&quot;&quot;&quot; # 转换为 uint32 数组 num_u32 = len(ciphertext_bytes) // 4 ciphertext_u32 = list(struct.unpack(f'&lt;{num_u32}I', ciphertext_bytes[:num_u32*4])) plaintext_u32 = [] # 处理每个块 (每块16个uint32 = 64字节) for block_idx in range((num_u32 + 15) // 16): offset = block_idx * 16 keystream = chacha20_block(block_idx) # _out.inner[(_e56 + _e64)] = (_e72 ^ _e75); for i in range(16): if offset + i &lt; num_u32: plaintext_u32.append(ciphertext_u32[offset + i] ^ keystream[i]) return plaintext_u32# 解密password_u32 = chacha20_decrypt(aes_decrypted)print(f&quot;ChaCha20 解密得到 {len(password_u32)} 个 uint32&quot;)# 转换为字节password_bytes = struct.pack(f'&lt;{len(password_u32)}I', *password_u32)print(f&quot;解密结果长度: {len(password_bytes)} bytes&quot;)print(f&quot;解密结果 (hex): {password_bytes.hex()}&quot;)print(f&quot;解密结果 (前64字节): {password_bytes[:64]}&quot;)# 多种解码尝试print(f&quot;\\n=== 解码尝试 ===&quot;)# 1. UTF-8try: password_str = password_bytes.rstrip(b'\\x00').decode('utf-8') print(f&quot;UTF-8: {password_str}&quot;)except: print(&quot;UTF-8 解码失败&quot;)# 2. ASCII (仅可打印字符)printable = ''for b in password_bytes: if 32 &lt;= b &lt; 127: printable += chr(b) elif b == 0: break else: printable += f'\\\\x{b:02x}'print(f&quot;可打印字符: {printable}&quot;)# 3. 查找已知字符串模式if b'flag' in password_bytes.lower(): print(&quot;发现 'flag' 字样!&quot;)if b'xctf' in password_bytes.lower(): print(&quot;发现 'xctf' 字样!&quot;)# 4. 尝试不同起始位置print(f&quot;\\n不同偏移的可打印字符:&quot;)for offset in [0, 4, 8, 12, 16]: snippet = password_bytes[offset:offset+32] readable = ''.join(chr(b) if 32 &lt;= b &lt; 127 else '.' for b in snippet) print(f&quot;Offset {offset:2d}: {readable}&quot;) 反正能解出来，不是很想改了，不知道为什么他这题ASCII都是存在u64里的","link":"/ctf/WP/XCTF%20Final%202025%20rewrite%20it%20in%20rust/"},{"title":"ChaCha20","text":"简介ChaCha20是由Salsa20修改来的一种加密算法，两者同属于流加密算法，在密码学安全性上是RC4算法的替代，其只有三种操作，分别为32位下的模加，循环左移和异或，通过这三种操作实现了一个伪随机函数，接受一个256位密钥和一个96位nonce每轮输出512位的流密码，ChaCha20与Salsa20的区别是前者的循环函数进行了修改以增加扩散性 nonce在密码学中指的是一次性随机数，用于添加在状态矩阵中确保每次会话生成的密码都是不同的 特征ChaCha20采用一个由4*4个uint32_t组成的状态矩阵来生成流密码，其按照轮输出流密码，每输出完512位的流密码后其会重新打乱整个状态矩阵来生成下一轮的流密码ChaCha20的轮函数非常简单，接受4个32位整数并通过运算来混合它们，这个轮函数因为每次对矩阵里的四分之一的数进行混合被称为四分之一轮，一次完整的混合总共会调用该函数80次 实现主体部分就是先初始化状态矩阵，然后每加密64字节的数据就重新生成新的流密码 123456789101112131415void ChaCha20_enc(uint8_t *input, size_t len, uint8_t *key, uint8_t *nonce, uint32_t count = 0) { int idx = 0; ChaCha20_init(key, nonce, count); for (size_t i = 0; i &lt; len; i++) { if (idx % 64 == 0) { ChaCha20_gen(state, keyStream); state[12]++; idx = 0; } // 应用流密码 input[i] ^= ((uint8_t *)keyStream)[idx]; idx++; }} 首先是对状态矩阵进行填充 1234567891011121314151617181920212223char ChaCha20_Const[128] = &quot;expand 32-byte k&quot;;void ChaCha20_init(uint8_t key[32], uint8_t *nonce, uint32_t count) { // 填充128位常量 state[0] = convert_uint8Arr_to_uint32((uint8_t *)ChaCha20_Const); state[1] = convert_uint8Arr_to_uint32((uint8_t *)ChaCha20_Const + 4); state[2] = convert_uint8Arr_to_uint32((uint8_t *)ChaCha20_Const + 8); state[3] = convert_uint8Arr_to_uint32((uint8_t *)ChaCha20_Const + 12); // 填充256位密钥 state[4] = convert_uint8Arr_to_uint32(key + 0); state[5] = convert_uint8Arr_to_uint32(key + 4); state[6] = convert_uint8Arr_to_uint32(key + 8); state[7] = convert_uint8Arr_to_uint32(key + 12); state[8] = convert_uint8Arr_to_uint32(key + 16); state[9] = convert_uint8Arr_to_uint32(key + 20); state[10] = convert_uint8Arr_to_uint32(key + 24); state[11] = convert_uint8Arr_to_uint32(key + 28); // 填充轮计数器，用于确保一次会话中的每个数据块生成的流密码均不同 state[12] = count; // 填充nonce，用于确保每个会话生成的流密码不同 state[13] = convert_uint8Arr_to_uint32(nonce + 0); state[14] = convert_uint8Arr_to_uint32(nonce + 4); state[15] = convert_uint8Arr_to_uint32(nonce + 8);} 这里的128位常量可以任意修改，标准实现为expand 32-byte k 123456789101112131415161718void ChaCha20_gen(uint32_t *in, uint32_t *out) { for (int i = 0; i &lt; 16; i++) out[i] = in[i]; // 十轮混合函数，前4个是列混合，后四个是对角线混合 for (int i = 0; i &lt; 10; i++) { QR(out[0], out[4], out[8], out[12]); QR(out[1], out[5], out[9], out[13]); QR(out[2], out[6], out[10], out[14]); QR(out[3], out[7], out[11], out[15]); QR(out[0], out[5], out[10], out[15]); QR(out[1], out[6], out[11], out[12]); QR(out[2], out[7], out[8], out[13]); QR(out[3], out[4], out[9], out[14]); } // 将打乱前的矩阵叠加到打乱后的矩阵上，防止差分攻击 for (int i = 0; i &lt; 16; i++) out[i] += in[i];} 生成流密码方式如上，可以发现明显的10轮特征，轮数根据变种不同可能会减少，混合完后将原矩阵加到新矩阵上 1234567891011121314#define ROTL32(x, n) (((x) &lt;&lt; (n)) | ((x) &gt;&gt; (32 - (n))))#define QR(a, b, c, d) \\ a += b; \\ d ^= a; \\ d = ROTL32(d, 16); \\ c += d; \\ b ^= c; \\ b = ROTL32(b, 12); \\ a += b; \\ d ^= a; \\ d = ROTL32(d, 8); \\ c += d; \\ b ^= c; \\ b = ROTL32(b, 7) 四分之一轮函数如上，这四个左移长度常量是具有密码学意义的（也就是说从密码学角度最好别乱动他），这个函数确保了算法的扩散性 解密ChaCha20是流加密，所以解密和RC4一样，获取流密码后根据流密码的使用方式解密即可，标准ChaCha20是异或，所以加密和解密代码相同 完整代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#include &lt;cstddef&gt;#include &lt;cstdint&gt;#include &lt;cstdio&gt;using namespace std;#define ROTL32(x, n) (((x) &lt;&lt; (n)) | ((x) &gt;&gt; (32 - (n))))#define QR(a, b, c, d) \\ a += b; \\ d ^= a; \\ d = ROTL32(d, 16); \\ c += d; \\ b ^= c; \\ b = ROTL32(b, 12); \\ a += b; \\ d ^= a; \\ d = ROTL32(d, 8); \\ c += d; \\ b ^= c; \\ b = ROTL32(b, 7)uint32_t convert_uint8Arr_to_uint32(const uint8_t *arr) { return ((uint32_t)(arr[0] &lt;&lt; 0)) | ((uint32_t)(arr[1] &lt;&lt; 8)) | ((uint32_t)(arr[2] &lt;&lt; 16)) | ((uint32_t)(arr[3] &lt;&lt; 24));}uint32_t state[16];uint32_t keyStream[16];char ChaCha20_Const[128] = &quot;expand 32-byte k&quot;;void ChaCha20_init(uint8_t key[32], uint8_t *nonce, uint32_t count) { // 填充128位常量 state[0] = convert_uint8Arr_to_uint32((uint8_t *)ChaCha20_Const); state[1] = convert_uint8Arr_to_uint32((uint8_t *)ChaCha20_Const + 4); state[2] = convert_uint8Arr_to_uint32((uint8_t *)ChaCha20_Const + 8); state[3] = convert_uint8Arr_to_uint32((uint8_t *)ChaCha20_Const + 12); // 填充256位密钥 state[4] = convert_uint8Arr_to_uint32(key + 0); state[5] = convert_uint8Arr_to_uint32(key + 4); state[6] = convert_uint8Arr_to_uint32(key + 8); state[7] = convert_uint8Arr_to_uint32(key + 12); state[8] = convert_uint8Arr_to_uint32(key + 16); state[9] = convert_uint8Arr_to_uint32(key + 20); state[10] = convert_uint8Arr_to_uint32(key + 24); state[11] = convert_uint8Arr_to_uint32(key + 28); // 填充轮计数器，用于确保一次会话中的每个数据块生成的流密码均不同 state[12] = count; // 填充nonce，用于确保每个会话生成的流密码不同 state[13] = convert_uint8Arr_to_uint32(nonce + 0); state[14] = convert_uint8Arr_to_uint32(nonce + 4); state[15] = convert_uint8Arr_to_uint32(nonce + 8);}void ChaCha20_gen(uint32_t *in, uint32_t *out) { for (int i = 0; i &lt; 16; i++) out[i] = in[i]; // 十轮混合函数，前4个是列混合，后四个是对角线混合 for (int i = 0; i &lt; 10; i++) { QR(out[0], out[4], out[8], out[12]); QR(out[1], out[5], out[9], out[13]); QR(out[2], out[6], out[10], out[14]); QR(out[3], out[7], out[11], out[15]); QR(out[0], out[5], out[10], out[15]); QR(out[1], out[6], out[11], out[12]); QR(out[2], out[7], out[8], out[13]); QR(out[3], out[4], out[9], out[14]); } // 将打乱前的矩阵叠加到打乱后的矩阵上，防止差分攻击 for (int i = 0; i &lt; 16; i++) out[i] += in[i];}void ChaCha20_enc(uint8_t *input, size_t len, uint8_t *key, uint8_t *nonce, uint32_t count = 0) { int idx = 0; ChaCha20_init(key, nonce, count); for (size_t i = 0; i &lt; len; i++) { if (idx % 64 == 0) { ChaCha20_gen(state, keyStream); state[12]++; idx = 0; } // 应用流密码 input[i] ^= ((uint8_t *)keyStream)[idx]; idx++; }}int main() { char key[33] = &quot;Eleven11________________________&quot;; uint8_t nonce[12] = {0x12, 0x34, 0x56, 0x78, 0x12, 0x34, 0x56, 0x78, 0x12, 0x34, 0x56, 0x78}; char plaintext[] = &quot;Hello, ChaCha20!&quot;; size_t len = sizeof(plaintext) - 1; ChaCha20_enc((uint8_t *)plaintext, len, (uint8_t *)key, nonce); for (size_t i = 0; i &lt; len; i++) printf(&quot;%02X &quot;, (uint8_t)plaintext[i]); ChaCha20_enc((uint8_t *)plaintext, len, (uint8_t *)key, nonce); printf(&quot;\\n%s\\n&quot;, plaintext);} referenceChaCha20-wikipediaChaCha20 对称加密目录","link":"/ctf/%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86/ChaCha20/"},{"title":"[NPCCTF 2025]babyVM","text":"史vm题 ida打开main函数看到进入就是vm虚拟机 点进去发现是一个巨大的switch case循环，结构非常明显，有四个32位寄存器，其他和题目关系不大 二十多个case全部写handle去解析opcode的话难度很大，而且还要指令长度之类的问题，可以采用在指令入口点下条件断点的方式，然后动态执行整个vm，在执行指令的同时输出执行的操作，这样就可以获取vm指令的伪代码了 然后跑一遍就能拿到执行的指令了可以看到非常长，这里我同时在指令前输出了执行前寄存器的值，同时这里的下标也是处理过的，如果直接输出寄存器的值下标会非常大，用了一个python脚本对下标做了偏移让伪代码好看点 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354import reimport sysdef process_text(text): # 找出所有以 heap[938 开头的模式 pattern1 = r'heap\\[(938\\d+)\\]' matches1 = re.findall(pattern1, text) # 找出所有以 heap[1844 开头的模式 pattern2 = r'heap\\[(1844\\d+)\\]' matches2 = re.findall(pattern2, text) # 如果存在匹配项，找出最小索引值 if matches1: indices1 = [int(idx) for idx in matches1] base1 = min(indices1) # 替换heap[938...]为heap_1[offset] for idx in sorted(set(indices1), reverse=True): # 去重并从大到小替换 offset = idx - base1 text = text.replace(f'heap[{idx}]', f'heap_1[{offset}]') if matches2: indices2 = [int(idx) for idx in matches2] base2 = min(indices2) # 替换heap[1844...]为heap_2[offset] for idx in sorted(set(indices2), reverse=True): # 去重并从大到小替换 offset = idx - base2 text = text.replace(f'heap[{idx}]', f'heap_2[{offset}]') return textdef main(): # 如果有命令行参数，则读取文件 if len(sys.argv) &gt; 1: input_file = sys.argv[1] with open(input_file, 'r') as f: text = f.read() else: # 否则从标准输入读取 text = sys.stdin.read() processed_text = process_text(text) # 输出到标准输出 print(processed_text)if __name__ == &quot;__main__&quot;: main() 然后看cmp xx 48可以看出来明显有一个循环，结合各种左右移操作，猜测是tea系列的加密，于是截取一段循环抄算法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475// ------------cmp 4 48------------- // r1= 2984982102 r2= 0 r3= 4 r4= 4207947599 // r1= 2984982102 r2= 0 r3= 4 r4= 4207947599 reg3 = heap_2[56]; // heap_2[56] = 2984982102 // r1= 2984982102 r2= 0 r3= 4 r4= 2984982102 reg3 &gt;&gt;= 6; // r1= 2984982102 r2= 0 r3= 4 r4= 46640345 reg0 = heap_2[56]; // heap_2[56] = 2984982102 // r1= 2984982102 r2= 0 r3= 4 r4= 46640345 reg0 &lt;&lt;= 5; // r1= 1030146752 r2= 0 r3= 4 r4= 46640345 reg3 ^= reg0; // reg0 = 1030146752 // r1= 1030146752 r2= 0 r3= 4 r4= 1067542041 reg3 += heap_2[56]; // heap_2[56] = 2984982102 // r1= 1030146752 r2= 0 r3= 4 r4= 4052524143 reg2 = heap_2[64]; // heap_2[64] = 2610559960 // r1= 1030146752 r2= 0 r3= 2610559960 r4= 4052524143 reg2 &amp;= 3; // r1= 1030146752 r2= 0 r3= 0 r4= 4052524143 reg0 = heap_2[68]; // heap_2[68] = 164 // r1= 164 r2= 0 r3= 0 r4= 4052524143 reg2 = heap_1[0]; // heap_1[0] = 1987012675 // r1= 164 r2= 0 r3= 1987012675 r4= 4052524143 reg2 += heap_2[64]; // heap_2[64] = 2610559960 // r1= 164 r2= 0 r3= 302605339 r4= 4052524143 reg3 ^= reg2; // reg2 = 302605339 // r1= 164 r2= 0 r3= 302605339 r4= 3817207924 reg3 += heap_2[60]; // heap_2[60] = 1830509707 // r1= 164 r2= 0 r3= 302605339 r4= 1352750335 heap_2[60] = 1352750335; // r1= 164 r2= 0 r3= 302605339 r4= 1352750335 reg3 = heap_2[64]; // heap_2[64] = 2610559960 // r1= 164 r2= 0 r3= 302605339 r4= 2610559960 reg3 -= heap_2[32]; // heap_2[32] = 421101834 // r1= 164 r2= 0 r3= 302605339 r4= 2189458126 heap_2[64] = 2189458126; // r1= 164 r2= 0 r3= 302605339 r4= 2189458126 reg0 = heap_2[60]; // heap_2[60] = 1352750335 // r1= 1352750335 r2= 0 r3= 302605339 r4= 2189458126 reg0 &gt;&gt;= 7; // r1= 10568361 r2= 0 r3= 302605339 r4= 2189458126 reg2 = heap_2[60]; // heap_2[60] = 1352750335 // r1= 10568361 r2= 0 r3= 1352750335 r4= 2189458126 reg2 &lt;&lt;= 3; // r1= 10568361 r2= 0 r3= 2232068088 r4= 2189458126 reg0 ^= reg2; // reg2 = 2232068088 // r1= 2242635089 r2= 0 r3= 2232068088 r4= 2189458126 reg0 += heap_2[60]; // heap_2[60] = 1352750335 // r1= 3595385424 r2= 0 r3= 2232068088 r4= 2189458126 reg3 = heap_2[64]; // heap_2[64] = 2189458126 // r1= 3595385424 r2= 0 r3= 2232068088 r4= 2189458126 reg3 &gt;&gt;= 11; // r1= 3595385424 r2= 0 r3= 2232068088 r4= 1069071 reg3 &amp;= 3; // r1= 3595385424 r2= 0 r3= 2232068088 r4= 3 reg2 = heap_2[68]; // heap_2[68] = 164 // r1= 3595385424 r2= 0 r3= 164 r4= 3 reg3 = heap_1[12]; // heap_1[12] = 1597387639 // r1= 3595385424 r2= 0 r3= 164 r4= 1597387639 reg3 += heap_2[64]; // heap_2[64] = 2189458126 // r1= 3595385424 r2= 0 r3= 164 r4= 3786845765 reg0 ^= reg3; // reg3 = 3786845765 // r1= 939234325 r2= 0 r3= 164 r4= 3786845765 reg0 += heap_2[56]; // heap_2[56] = 2984982102 // r1= 3924216427 r2= 0 r3= 164 r4= 3786845765 heap_2[56] = 3924216427; // r1= 3924216427 r2= 0 r3= 164 r4= 3786845765 // r1= 3924216427 r2= 0 r3= 164 r4= 3786845765 reg2 = heap_2[44]; // heap_2[44] = 4 // r1= 3924216427 r2= 0 r3= 4 r4= 3786845765 reg2 += 1; // r1= 3924216427 r2= 0 r3= 5 r4= 3786845765 heap_2[44] = 5; // r1= 3924216427 r2= 0 r3= 5 r4= 3786845765 // ------------cmp 5 48------------- 123456789101112131415// key = Chovy_inkey_w36_void enc(unsigned int v0, unsigned int v1, unsigned int *key){ // heap_2[56] = v0 // heap_2[60] = v1 // heap_2[64] = sum unsigned int sum = 0; unsigned int tmp_reg3 = 0, tmp_reg2 = 0, tmp_reg0 = 0; for (int i = 0; i &lt; 48; i++) { v0 += (((v1 &gt;&gt; 6) ^ (v1 &lt;&lt; 5) )+ v1) ^ (key[sum &amp; 3] + sum); sum -= 421101834; v1 += (((v0 &gt;&gt; 7) ^ (v0 &lt;&lt; 3)) + v0) ^ (key[(sum &gt;&gt; 11) &amp; 3] + sum); }} key 的来源是 12345678910111213141516171819202122232425262728293031heap_2[0] = 67;// r1= 512 r2= 0 r3= 32 r4= 512heap_2[1] = 104;// r1= 512 r2= 0 r3= 32 r4= 512heap_2[2] = 111;// r1= 512 r2= 0 r3= 32 r4= 512heap_2[3] = 118;// r1= 512 r2= 0 r3= 32 r4= 512heap_2[4] = 121;// r1= 512 r2= 0 r3= 32 r4= 512heap_2[5] = 95;// r1= 512 r2= 0 r3= 32 r4= 512heap_2[6] = 105;// r1= 512 r2= 0 r3= 32 r4= 512heap_2[7] = 110;// r1= 512 r2= 0 r3= 32 r4= 512heap_2[8] = 107;// r1= 512 r2= 0 r3= 32 r4= 512heap_2[9] = 101;// r1= 512 r2= 0 r3= 32 r4= 512heap_2[10] = 121;// r1= 512 r2= 0 r3= 32 r4= 512heap_2[11] = 95;// r1= 512 r2= 0 r3= 32 r4= 512heap_2[12] = 119;// r1= 512 r2= 0 r3= 32 r4= 512heap_2[13] = 51;// r1= 512 r2= 0 r3= 32 r4= 512heap_2[14] = 54;// r1= 512 r2= 0 r3= 32 r4= 512heap_2[15] = 95; 其中可能在整理heap时脚本出了点问题，储存key的被错误命名成了heap2，但是还是能辨别出key 于是写解密 12345678910111213141516171819202122232425262728void dec(unsigned int *v, unsigned int *key){ unsigned int v0 = v[0]; unsigned int v1 = v[1]; unsigned int delta = 421101834; unsigned int sum = 0; for (int i = 0; i &lt; 48; i++) sum -= delta; for (int i = 0; i &lt; 48; i++) { v1 -= (((v0 &gt;&gt; 7) ^ (v0 &lt;&lt; 3)) + v0) ^ (key[(sum &gt;&gt; 11) &amp; 3] + sum); sum += delta; v0 -= (((v1 &gt;&gt; 6) ^ (v1 &lt;&lt; 5)) + v1) ^ (key[sum &amp; 3] + sum); } for (int i = 0; i &lt; 4; i++) printf(&quot;%c&quot;, ((unsigned char *)&amp;v0)[i]); for (int i = 0; i &lt; 4; i++) printf(&quot;%c&quot;, ((unsigned char *)&amp;v1)[i]);}int main(){ unsigned char key[] = &quot;Chovy_inkey_w36_&quot;; unsigned char cipher[] = &quot;\\xE5\\xDF\\xF0\\xA1\\xF4\\xBD\\x6A\\xDB\\x1B\\xE9\\xDD\\x20\\r\\x9D!YгY)\\xB9\\xEC\\x2F\\xC0\\&quot;~\\xAD\\xE1\\xB0\\x15\\xB6)&quot;; for (int i = 0; i &lt; 32; i += 8) dec((unsigned int *)&amp;cipher[i], (unsigned int *)key); return 0;} flag{D0_yOu_l1k3_VmmmmMMMMMmmm?}","link":"/ctf/WP/NPCCTF2025/NPCCTF%202025%20babyVM/"},{"title":"NPCCTF 2025 randomXor","text":"简单伪随机 打开看了下main，看起来是很简单的伪随机，但是随机数算法是出题人自制的，而且是arm架构题目，不能用frida hook，所以考虑用模拟执行获取rand的结果我们在调用srand的代码块进入，然后随便找一个加密完的位置作为结束的位置因为bn有非常方便的读取段数据的api，所以直接把所有段都读进去 12345678910111213141516171819202122232425262728293031323334353637383940414243444546from unicorn import *from unicorn.arm64_const import *from binaryninja import *def hook_code(uc, address, size, user_data): bv = user_data[&quot;bv&quot;] assert isinstance(bv, BinaryView) if address == 0xbc8: print(&quot;w0 = {} w1 ={}&quot;.format(uc.reg_read( UC_ARM64_REG_W0), uc.reg_read(UC_ARM64_REG_W1))) global rd rd.append(uc.reg_read(UC_ARM64_REG_W0)) if address == 0xbdc: print(&quot;addr = {}&quot;.format(uc.reg_read(UC_ARM64_REG_X0) + uc.reg_read(UC_ARM64_REG_X1)))CODE_BASE = 0x0CODE_SIZE = 0x20000STACK_BASE = 0x10000000STACK_SIZE = 0x10000uc = Uc(UC_ARCH_ARM64, UC_MODE_ARM)uc.mem_map(CODE_BASE, CODE_SIZE, UC_PROT_ALL)uc.mem_map(STACK_BASE, STACK_SIZE, UC_PROT_ALL)uc.hook_add(UC_HOOK_CODE, hook_code, user_data={&quot;bv&quot;: bv})rd = []for segment in bv.segments: if segment.readable: start = segment.start end = segment.end size = end-start print(&quot;[+] Mapping segment: [{}]&quot;.format(hex(segment.start))) content = bv.read(start, size) uc.mem_write(start, content)addr = 0xb98addrEnd = 0xc18stack_top = STACK_BASE + STACK_SIZE - 0x100uc.reg_write(UC_ARM64_REG_SP, stack_top)uc.mem_write(stack_top, b&quot;\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00&quot;)uc.emu_start(addr, addrEnd)print(rd)uc.emu_stop() 0xbc8执行的了xor操作，我们在这个位置设置hook，读取w0就能直接拿到随机数 之后直接解密即可 123456789101112131415161718192021rd = [171, 171, 131, 225, 65, 75, 141, 216, 149, 238, 40, 235, 196, 132, 99, 176, 132, 203, 140, 159, 82, 45, 47, 112, 202, 233, 239, 208, 231, 132, 45, 46, 58, 242, 229, 224, 106, 121, 228, 112, 174, 107, 227, 40, 64, 239, 178, 108, 13, 68, 255, 143, 243, 74, 108, 95, 141, 203, 193, 122, 195, 218, 187, 40, 108, 174, 244, 32, 167, 107, 104, 52, 90, 201, 121, 99, 142, 99, 227, 128, 118, 224, 188, 142, 131, 33, 128, 109, 35, 105, 191, 19, 47, 225, 46, 183, 46, 200, 18, 38, 243, 17, 216, 185, 181, 68, 240, 165, 25, 104, 56, 165, 154, 91, 88, 2, 209, 171, 137, 112, 59, 9, 149, 238, 1, 40, 165, 243]cipher = [0xCD, 0xC7, 0xE2, 0x86, 0x3A, 0x19, 0xB9, 0xB6, 0xF1, 0x81, 0x45, 0xB4, 0xB6, 0xE5, 0x0D, 0xD4, 0xB4, 0xA6, 0xD3, 0xF7, 0x33, 0x5D, 0x5F, 0x09, 0x95, 0xAF, 0x9A, 0xBE, 0x89, 0xEA, 0x54, 0x71, 0x68, 0xC6, 0x8B, 0x84, 0x05, 0x14, 0xBB, 0x41, 0xDD, 0x34, 0x91, 0x1B, 0x21, 0x83, 0xDE, 0x15, 0x52, 0x22, 0x8A, 0xE1, 0xBD, 0x33, 0x4D, 0x7E, 0xD2, 0xA3, 0xA9, 0x12, 0xF1, 0xE9, 0x88, 0x60, 0x24, 0xE6, 0xAB, 0x54, 0xCF, 0x02, 0x1B, 0x6B, 0x6B, 0xBA, 0x26, 0x09, 0xFB, 0x10, 0x97, 0xDF, 0x17, 0xBF, 0xCC, 0xE7, 0xB0, 0x42, 0xE5, 0x32, 0x4C, 0x0F, 0xE0, 0x60, 0x47, 0xD0, 0x5A, 0xE8, 0x48, 0xAE, 0x74, 0x4D, 0x98, 0x7A, 0xB3, 0xD2, 0xDE, 0x1B, 0x96, 0x91, 0x7A, 0x03, 0x67, 0xCF, 0xF0, 0x31, 0x32, 0x49, 0x9A, 0xE0, 0xC2, 0x3B, 0x51, 0x63, 0xFF, 0x84, 0x60, 0x5B, 0xC1, 0x8E]print(len(rd))for i in range(0, 128): print(chr(cipher[i] ^ rd[i]), end='') flag{R4ndom_rand0m_happy_Funnny_R4ndom_1s_r3ally_funNy!!_hhh233HHH_this_1s_just_a_pi3ce_of_sh1t_fffkkkkkk_f4ck_jjjjKKKKKjjjjasd}","link":"/ctf/WP/NPCCTF2025/NPCCTF%202025%20randomXor/"},{"title":"NPCCTF 2025 ezMobile","text":"简单dex壳 进来主类里直接看到一个经典dex壳，这个壳是吧加密过的dex扔进native函数里解密，然后用InMemoryDexClassLoader动态加载我们直接hook这个change,拿到返回值后直接写进入文件获得dex 12345678910def onMessage(message, data): if message['type'] == 'send': print(&quot;[!!] Message from target: &quot;, message['payload']) for i in range(len(message['payload'])): if message['payload'][i] &lt; 0: message['payload'][i] += 256 with open(&quot;class.dex&quot;, &quot;wb&quot;) as f: f.write(bytes(message['payload'])) else: print(&quot;Not a send type Message&quot;, message['stack']) 123456let MainActivity = Java.use(&quot;ctf.myapplication.MainActivity&quot;);MainActivity[&quot;change&quot;].implementation = function (bArr) { let result = this[&quot;change&quot;](bArr); send(result) return result;}; 拿到dex后打开看加密就是一个xxtea加一个base64，base64检查过后发现就是默认表，xxtea魔改了MX和delta，所以手动写xxtea脚本，key是放在native里的，可以直接hook encrypt的参数获取 1FlagChecker.encrypt is called: data=qweery, key=882059e204adefc5 xxtea脚本如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#include &lt;bits/stdc++.h&gt;using namespace std;#define MX (((z &gt;&gt; 5) ^ (y &lt;&lt; 2)) + ((y &gt;&gt; 3) ^ (z &lt;&lt; 4))) ^ ((sum ^ y) + (k[(p &amp; 3) ^ e] ^ z))void xxteaEncrtpy(uint32_t *v, size_t n, uint32_t *k){ uint32_t y, z, sum; uint32_t p, rounds, e; uint32_t delta = -1640531527; rounds = 6 + 52 / n; sum = 0; z = v[n - 1]; do { sum += delta; e = (sum &gt;&gt; 2) &amp; 3; // 引入非线性计算，使得每次取出的key值缺少规律 for (p = 0; p &lt; n - 1; p++) { y = v[p + 1]; z = v[p] += MX; // 每个块加密是增加的偏移量实际上由上一个块(z)和下一个块(y)的值和sum共同决定 } y = v[0]; // 此处其实是循环加密的端点，当然可以对下标取模写进循环里 z = v[n - 1] += MX; } while (--rounds); // 实际上是把相同的操作重复round轮}void xxteaDecrypt(uint32_t *v, size_t n, uint32_t *k){ uint32_t y, z, sum; uint32_t p, rounds, e; uint32_t delta = -1640531527; rounds = 6 + 52 / n; sum = rounds * delta; y = v[0]; // n-1号块的下一个块是0号块 do { e = (sum &gt;&gt; 2) &amp; 3; for (p = n - 1; p &gt; 0; p--) // 反向循环 { z = v[p - 1]; // 因为是反着循环，所以这里是上一个块 y = v[p] -= MX; // 这里是也是取上一个和下一个块的值作为参数 } z = v[n - 1]; // 0号块的上一个块是n-1号块 y = v[0] -= MX; sum -= delta; } while (--rounds);}int main(){ // 882059e204adefc5 char k[] = &quot;882059e204adefc5&quot;; // uint32_t k[4] = {0x01234567, 0x89abcdef, 0xfedcba98, 0x76543210}; unsigned char v[] = {0x61, 0x80, 0x8a, 0x2d, 0x69, 0x52, 0x27, 0xdc, 0x78, 0x95, 0x85, 0x66, 0xee, 0x2a, 0xa5, 0x1e, 0xdf, 0xc4, 0x5e, 0xf8, 0x1a, 0x84, 0x4a, 0x0a, 0x11, 0xed, 0x9d, 0x97, 0x40, 0x67, 0x46, 0x61, 0xa1, 0x35, 0x0f, 0x4a, 0x84, 0xf5, 0xd8, 0x79, 0xfd, 0xc4, 0xa9, 0xb8}; xxteaDecrypt((uint32_t *)v, 11, (uint32_t *)k); for (int i = 0; i &lt; 44; i++) printf(&quot;%c&quot;, v[i]); printf(&quot;\\n&quot;); return 0;} flag{AnDr01d_r3v3rs3_jUcYuWzBSSOwKxbMD}","link":"/ctf/WP/NPCCTF2025/NPCCTF%202025%20ezMobile/"},{"title":"NPCCTF 2025 base","text":"坑点非常多的题，基本涵盖了大部分windows逆向常见的对抗手法进来先是一堆花，有jz,jnz和call-ret两种，还算常规，修复完后显示main看汇编时发现有try_except块，然后发现他手动触发了一个div0错误，怀疑错误处理里藏了加密，故nop掉错误处理的jmp部分，反编译except里的代码这样就显现出了完整的main然后这道题发现不能动调，进入main后调试器就失去与程序的链接，所以去查初始化部分仔细看这个api后发现这个api并不是遇到0就截止，而是完整遍历整个区域所有的数据，遇到无效地址跳过，出题人把0x411840这个反调试函数地址藏在了下面点进去那个函数里面也有很多花，并且多了 xor ebx 后cmp ebx 再走jnz的第三种花去完后如下所示下面两个字符串是做过简单加密的，动调打在这里看解密结果(因为此时反调还没初始化完所以可以调)两个字符串解开，ntdll和ZwSetInformationThread，这样就很明显了，手动调用线程信息设置函数，看了下下面参数0x11，就是将当前线程对调试器隐藏，nop掉这个call就行，注意因为vc添加了很多栈平衡校验，所以nop时要把前面的push传参都nop干净，不然运行会报错 主函数其实思路很清晰，先魔改rc4去初始化一个映射表，然后enc进去先用映射表对输入做置换，然后又是魔改的rc4，下面三个rc4根据会根据分支的不同在加密完再和某个数进行一次异或最后暴露出的except块里的代码就是一个循环异或，直接解就行，注意到rc4虽然加了一次异或但仍是可逆的，所以可以在进入rc4前下断点，把循环异或解出的数据用patch的方式写入rc4的参数里，这样rc4跑完后就自动解开了dest同样可以动调拿到，之后只要写脚本把映射重新改回去就行了 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include &lt;bits/stdc++.h&gt;using namespace std;unsigned char dest[] = { 0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76, 0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0, 0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15, 0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75, 0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84, 0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF, 0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8, 0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2, 0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73, 0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB, 0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79, 0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08, 0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A, 0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E, 0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF, 0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16};unsigned char enc[] = { 0x78, 0xD4, 0xD5, 0x92, 0x98, 0x62, 0x14, 0x14, 0xA5, 0x0F, 0x29, 0xAE, 0x9B, 0x58, 0x14, 0x21, 0x0D, 0x7D, 0xA4, 0x66, 0x48, 0x83, 0x79, 0x30, 0xF3, 0x21, 0xD1, 0xCD, 0xE2, 0x02, 0x8D, 0xAC, 0xBC, 0x4A, 0x81, 0xC1, 0x9C, 0xF5, 0xC2, 0xC8, 0x3F, 0x0A};unsigned char ida_chars[] = { 0x33, 0x50, 0xEF, 0x85, 0x21, 0x23, 0xEF, 0x33, 0x18, 0xC7, 0x04, 0xC7, 0xEF, 0xD8, 0x23, 0x04, 0xC7, 0xEF, 0xD8, 0x18, 0xEF, 0xAA, 0x12, 0xD8, 0xEF, 0x05, 0x05, 0x18, 0xD8, 0x12, 0x04, 0xC3, 0x96, 0x9A, 0x9A, 0xFB, 0xAA, 0x12, 0x33, 0x33, 0x04, 0xFF};int main(){ for (int i = 0; i &lt; 7; i++) { enc[6 * i] ^= enc[6 * i + 5]; for (int j = 5; j &gt;= 1; j--) { enc[6 * i + j] ^= enc[6 * i + j - 1]; } } for (int i = 0; i &lt; 42; i++) { if (i % 16 == 0) printf(&quot;\\n&quot;); printf(&quot;%02X &quot;, enc[i]); } for (int i = 0; i &lt; 42; i++) { for (int j = 0; j &lt; 256; j++) { if (dest[j] == ida_chars[i]) { printf(&quot;%c&quot;, j); break; } } } return 0;} flag{2af4101a-201a-4ab9-a664-903577cb9ff0}","link":"/ctf/WP/NPCCTF2025/NPCCTF%202025%20base/"},{"title":"frida 实用代码片段","text":"记录一些可复用的frida脚本 dump so123456789101112131415161718192021222324252627282930313233/*如何使用设置一个倒计时后dump指定的so文件，timeout单位是ms，默认为3000ms对应的python段on_message回调def handleDumpSo(message, data): with open(&quot;dump_&quot;+message['payload'][1], &quot;ab&quot;) as f: f.write(data)*/function dump(soName: string, timeout: number = 3000) { setTimeout(() =&gt; { let libSo = Process.getModuleByName(soName); let base = libSo.base; let size = libSo.size; let sectionRanges = libSo.enumerateRanges(&quot;&quot;); for (let i = 0; i &lt; sectionRanges.length; i++) { console.log(sectionRanges[i].base.sub(base), sectionRanges[i].size, sectionRanges[i].base.add(sectionRanges[i].size).sub(base), sectionRanges[i].protection); Memory.protect(sectionRanges[i].base, sectionRanges[i].size, 'rwx'); let buffer = sectionRanges[i].base.readByteArray(sectionRanges[i].size); console.log(`write ${sectionRanges[i].size} bytes sections`); send([&quot;dumpso&quot;, soName], buffer); if (i + 1 &lt; sectionRanges.length &amp;&amp; sectionRanges[i].base.add(sectionRanges[i].size).compare(sectionRanges[i + 1].base) !== 0) { let gap = Memory.alloc(sectionRanges[i + 1].base.sub(sectionRanges[i].base.add(sectionRanges[i].size)).toUInt32()); let buffer = gap.readByteArray(sectionRanges[i + 1].base.sub(sectionRanges[i].base.add(sectionRanges[i].size)).toUInt32()); console.log(`write ${sectionRanges[i + 1].base.sub(sectionRanges[i].base.add(sectionRanges[i].size)).toUInt32()} bytes gap`); send([&quot;dumpso&quot;, soName], buffer); } } console.log(&quot;base: &quot;, base); console.log(&quot;size: &quot;, size); console.log(&quot;base + size: &quot;, base.add(size)); }, timeout);}dump(&quot;libil2cpp.so&quot;); 把内存中完整的so dump下来，包括仅运行时分配空间的段 HookGetStaticMethodID1234567891011121314151617181920212223242526272829303132333435/*如何使用这个gadget通过hook libart.so中的getStaticMethodID函数来获取so层获取的dex函数信息一般直接运行即可，注意本gadget依赖libart.so的加载配套python解析message的函数def handleGetStaticMethodID(message): print(&quot;----------------------------------------&quot;) print(&quot;JAVA method name: {}&quot;.format(message['payload'][1])) print(&quot;JAVA method signature: {}&quot;.format(message['payload'][2])) print(&quot;Which file get It: {}&quot;.format(message['payload'][3]))*/function hookJNIgetStaticMethodID() { console.log(&quot;hook JNIgetStaticMethodID&quot;); let symbols = Module.load(&quot;libart.so&quot;).enumerateSymbols(); for (let i = 0; i &lt; symbols.length; i++) { let symbol = symbols[i]; if (symbol.name.indexOf(&quot;art&quot;) &gt;= 0 &amp;&amp; symbol.name.indexOf(&quot;JNI&quot;) &gt;= 0 &amp;&amp; symbol.name.indexOf(&quot;GetStaticMethodID&quot;) &gt;= 0 &amp;&amp; symbol.name.indexOf(&quot;CheckJNI&quot;) &lt; 0) { console.log(symbol.name); Interceptor.attach(symbol.address, { onEnter: function (args) { var Name = args[2].readUtf8String(); var sig = args[3].readUtf8String(); let whoCallIt = DebugSymbol.fromAddress(this.returnAddress).toString(); send([&quot;getStaticMethodID&quot;, Name, sig, whoCallIt]); } }) } }}setTimeout(hookJNIgetStaticMethodID, 3000); HookRegisterNative12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455/*如何使用这个gadget通过hook libart.so中的RegisterNatives函数来获取JNI注册的native方法信息一般直接运行即可，注意本gadget依赖libart.so的加载配套python解析message的函数def handleResigerNatives(message): print(&quot;----------------------------------------&quot;) print(&quot;Native Method in class: {}&quot;.format(message['payload'][1])) print(&quot;Native Method name: {}&quot;.format(message['payload'][2])) print(&quot;Native Method signature: {}&quot;.format(message['payload'][3])) print(&quot;Native Method address: {}&quot;.format(message['payload'][4])) print(&quot;Which file register It: {}&quot;.format(message['payload'][5]))*/Java.perform(() =&gt; { hookJNIregisterNatives();})function hookJNIregisterNatives() { console.log(&quot;hook JNIregisterNatives&quot;); let symbols = Process.getModuleByName(&quot;libart.so&quot;).enumerateSymbols(); for (let i = 0; i &lt; symbols.length; i++) { let symbol = symbols[i]; //_ZN3art3JNI15RegisterNativesEP7_JNIEnvP7_jclassPK15JNINativeMethodi if (symbol.name.indexOf(&quot;art&quot;) &gt;= 0 &amp;&amp; symbol.name.indexOf(&quot;JNI&quot;) &gt;= 0 &amp;&amp; symbol.name.indexOf(&quot;RegisterNatives&quot;) &gt;= 0) { Interceptor.attach(symbol.address, { onEnter: function (args) { var jclass = args[1]; let className = Java.vm.getEnv().getClassName(jclass); var methods = args[2]; var nMethods = args[3].toInt32(); // console.log(nMethods); // console.log(&quot;className:&quot;, className); for (let i = 0; i &lt; nMethods; i++) { // console.log(&quot;i:&quot;, i); let nativeMethodPtr = methods.add(i * Process.pointerSize * 3); let namePtr = nativeMethodPtr.add(0).readPointer(); let signaturePtr = nativeMethodPtr.add(Process.pointerSize).readPointer(); let methodPtr = nativeMethodPtr.add(Process.pointerSize * 2).readPointer(); let methodName = namePtr.readUtf8String(); let methodSignature = signaturePtr.readUtf8String(); let whoCallIt = DebugSymbol.fromAddress(this.returnAddress).toString(); // console.log(Module.load(DebugSymbol.fromAddress(this.returnAddress).moduleName as string).base) let methodPtrStr = methodPtr.sub(Module.load(DebugSymbol.fromAddress(this.returnAddress).moduleName as string).base).toString(16); // console.log(&quot;RegisterNatives:&quot;, className, methodName, methodSignature, methodPtrStr, whoCallIt); send([&quot;registerNatives&quot;, className, methodName, methodSignature, methodPtrStr, whoCallIt]); } } }); } } // console.log(&quot;RegisterNatives addr:&quot;, addrRegisterNatives);}// setImmediate(hookWhenArtLoaded); traceStack全量hook脚本，用于追踪执行流脚本中遇到的函数表可以由这个脚本生成 123456789101112131415161718192021222324252627282930313233'''用bn导出函数表和函数地址,方便批量添加frida跟踪调用链'''from binaryninja import *def solve(bv: BinaryView): names = [] addresses = [] with open(&quot;functionDump.txt&quot;, &quot;w&quot;) as f: for func in bv.functions: names.append(func.name) addresses.append(func.start) print(&quot;var functionNames = [&quot;, file=f) for i in range(len(names)): if i == len(names) - 1: print(&quot; \\&quot;{}\\&quot;&quot;.format(names[i]), file=f) else: print(&quot; \\&quot;{}\\&quot;,&quot;.format(names[i]), file=f) print(&quot;];&quot;, file=f) print(&quot;var functionAddresses = [&quot;, file=f) for i in range(len(addresses)): if i == len(addresses) - 1: print(&quot; 0x{:x}&quot;.format(addresses[i]), file=f) else: print(&quot; 0x{:x},&quot;.format(addresses[i]), file=f) print(&quot;];&quot;, file=f) print(&quot;export finish&quot;) print(&quot;total function count: {}&quot;.format(len(names)))solve(bv) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283/*根据给出的函数表跟踪调用链，函数表由bnExportFunctionInfo.py导出顺带给出br的跳转目标地址方便分析bn未识别的函数*/var soName = &quot;libsec2023.so&quot;function sendWrapper(msg) { send([&quot;traceStack&quot;, msg]);}function startTrace(soName) { var tid = Process.getCurrentThreadId(); var lib = Process.getModuleByName(soName); var cnt = 1; sendWrapper(&quot;========================trace started========================&quot;); Stalker.follow(tid, { events: { call: false, ret: false, exec: false, block: false, compile: false }, transform: (iterator) =&gt; { var insn; while ((insn = iterator.next()) != null) { const addr = ptr(insn.address); // 只 instrument 属于目标 so 的指令 if (addr.compare(lib.base) &lt; 0 || addr.compare(lib.base.add(lib.size)) &gt;= 0) { iterator.keep(); continue; } // if (insn.mnemonic == &quot;br&quot;) { // const regName = insn.operands[0].value as string; // iterator.putCallout((ctx) =&gt; { // sendWrapper(`[${addr.sub(lib.base)}]` + &quot;[BR] target =&quot; + ptr(ctx[regName]).sub(lib.base)); // }); // } if (functionAddresses.indexOf(addr.sub(lib.base).toUInt32()) != -1) { sendWrapper(&quot;at &quot; + cnt + &quot; &quot; + functionNames[functionAddresses.indexOf(addr.sub(lib.base).toUInt32())]); cnt++; } iterator.keep(); } } }) // console.log(&quot;========================trace ended========================&quot;);}Java.perform(() =&gt; { var dlopen_addr = Module.getExportByName(&quot;libdl.so&quot;, &quot;dlopen&quot;); var dlopen_ext_addr = Module.getExportByName(&quot;libdl.so&quot;, &quot;android_dlopen_ext&quot;); Interceptor.attach(dlopen_addr, { onEnter: function (args) { var path = args[0].readUtf8String(); if (path?.indexOf(soName) != -1) { this.getSo = 1; } }, onLeave: function (retval) { if (this.getSo) { sendWrapper(&quot;dlopen: &quot; + soName); startTrace(soName); } } }) Interceptor.attach(dlopen_ext_addr, { onEnter: function (args) { var path = args[0].readUtf8String(); if (path?.indexOf(soName) != -1) { this.getSo = 1; } }, onLeave: function (retval) { if (this.getSo) { sendWrapper(&quot;dlopen_ext: &quot; + soName); startTrace(soName); } } })}) python段解析数据的部分，因为trace的数据量实际上相当大，并且有大量重复，所以采用分批合并输出的方式 12345678910111213141516171819202122def handleTraceStack(message): traceLimit = 1000000000 global TraceStacklogs global startPrintLog if len(TraceStacklogs) == 0: TraceStacklogs.append([message['payload'][1], 1]) else: if message['payload'][1] == TraceStacklogs[-1][0]: TraceStacklogs[-1][1] += 1 else: TraceStacklogs.append([message['payload'][1], 1]) def print_log(): global TraceStacklogs for item, cnt in TraceStacklogs: print(f&quot;{item} x{cnt}&quot;) TraceStacklogs.clear() threading.Timer(3.0, print_log).start() if not startPrintLog: startPrintLog = True print_log() 打印java层调用栈123456789function printStack(tag) { var Log = Java.use(&quot;android.util.Log&quot;); var Exception = Java.use(&quot;java.lang.Exception&quot;); var exception = Exception.$new(); var stack = Log.getStackTraceString(exception); console.log(&quot;[&quot;.concat(tag, &quot;] Stack trace:&quot;)); console.log(stack); exception.$dispose();}","link":"/ctf/auto-re-dev/frida-gadget/"},{"title":"使用bianryninja workflow解混淆0x1 - 双分支间接跳转","text":"用的mtguard.so，算比较麻烦的样本，不能完美解 bianryninja 的运行流程bianryninja默认带了两个workflow，通常我们用的是默认的metaAnalyze workflow，workflow可以理解成反编译器将二进制文件从机器码逐步提升成伪代码的流程，bianryninja的workflow由多个activity组成，每个activity代表了一项分析任务,activity之间组成cfg式的结构依次运行，将机器码依次提升到汇编,llil,mlil,hlil，这其实就是llvm pass的思路很多时候二进制样本中会有各种混淆，在arm64样本中比较常见的就是间接跳转混淆，此时默认的workflow因为算不出来跳转的地址，反编译控制流就会断开，此时有很多修复的方案，比如修改汇编将原本的br指令替换成条件跳转，或者修改il将jump替换成if这样的分支语句，这里既然使用到了workflow，自然就是使用修改il的方式了，修改il有很多好处，首先il本身包含了许多元数据，可以很方便的查找其前驱和让我们分析数据流，其次il本身可以任意修改，包括增加或减少语句的数量，而汇编因为是嵌入在二进制程序里的，如果出现空间问题就很难办，最后就是il在处理条件上相比汇编更加简洁，主要是cesl和cest的判断符太多了，而il会自动把条件处理为cond变量这里我们选择在mlil层和hlil层之间插入我们的 样本分析来看一下mtguard.so中的这个混淆样本可以看到美团的这个样本也是很难搞，一处跳转就用了好多处分支赋值指令，而且判断符还不一样我们从mlil入手看一下混淆的结构，因为在mlil之前变量定义还未生成，不方便做数据流分析，而且mlil一个重要的功能是将未分析出值的变量指定为常量，这样如果bn无法分析表地址，我们还可以手动指定表地址我们的最终目的是求解x9_1变量的值，这个值理论有两个，让我们看一下bn已经分析到哪一步了可以看到其实我们需要的值都有了，只是bn没办法把这些值两两对应起来分析 此处补充一个前提，我们假定即使存在多个csel类指令，他们都对应同一个cmp，即cond全部是等价的，做出这种假定的前提是考虑这种混淆生成的方式，假设有n个cmp，那可能的状态数就是$2^n$，而正常的代码中的跳转语句大部分就是直接跳转，分支和switch三种结构，跳转状态为$2^n$的几乎没有，那我们观察这个结构，怎么看都像是分支，也就是说这个其实是b.ne或类似的指令通过llvm变换来的，所以说cmp大概率只有一个 我们的目标就是将这个跳转的的真假两个分支的的值分别计算出来，也就是把里面有两个值的变量和TrueBranch，FalseBranch对应起来，因为之前已经论证过cond应该都是一样的，所以我们在两个if中任意找一个cond就行（不排除做一个混淆然后把这两个cond做成相反的情况，但这个样本里没有，如果有的话其实最后拿cond时全拿下来然后判断一下就行，因为你从源代码的角度他大概率就是一句简单的if语句） workflow这里先贴一个完整代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272import jsonfrom dataclasses import dataclass,fieldfrom binaryninja import( Workflow, AnalysisContext, Activity, MediumLevelILFunction, MediumLevelILConstPtr, MediumLevelILConstData, MediumLevelILConst, MediumLevelILAdd, MediumLevelILSub, MediumLevelILXor, MediumLevelILJump, RegisterValueType, MediumLevelILJumpTo, MediumLevelILFunction, BinaryView,)mlil_const=MediumLevelILConstPtr | MediumLevelILConstData | MediumLevelILConstfrom binaryninja import( MediumLevelILVarSsa, MediumLevelILVarPhi, MediumLevelILVar, MediumLevelILSetVarSsa, MediumLevelILLoadSsa, SSAVariable, ExpressionIndex, MediumLevelILLabel, Function,)class two_direct_indirect_jump_handler: @dataclass class resolved_data: cond:ExpressionIndex trueAddr:int falseAddr:int def __init__(self,ctx:AnalysisContext): self.ctx=ctx self.resolved:dict[int,two_direct_indirect_jump_handler.resolved_data]={} pass @staticmethod def search_var_value_ssa(var:SSAVariable,mlil_ssa:MediumLevelILFunction,cond): def_site=var.def_site # print(hex(def_site.address),var,def_site.get_possible_reg_values_after(var.var.storage)) lv,rv=None,None if isinstance(def_site,MediumLevelILVarPhi): lv=two_direct_indirect_jump_handler.search_var_value_ssa(def_site.src[0],mlil_ssa,cond) rv=two_direct_indirect_jump_handler.search_var_value_ssa(def_site.src[1],mlil_ssa,cond) if lv==None or rv==None: raise RuntimeError(&quot;phi calc fail\\n {} {} \\n {} {}&quot;.format(def_site.src[0].def_site,def_site.src[1].def_site,hex(def_site.address),def_site)) return lv | rv if isinstance(def_site,MediumLevelILSetVarSsa): if isinstance(def_site.src,MediumLevelILLoadSsa): tokens=list(def_site.src.traverse(lambda x: x)) table=def_site.get_possible_reg_values_after(def_site.dest.var.storage) if table.type!=RegisterValueType.LookupTableValue: raise RuntimeError(&quot;not lookup table {} {}&quot;.format(hex(def_site.address),def_site)) # print(table.mapping) res={} for token in tokens: if isinstance(token,MediumLevelILVarSsa): mp=two_direct_indirect_jump_handler.search_var_value_ssa(token.var,mlil_ssa,cond) if mp==None: continue try: res|= {&quot;t&quot;:table.mapping[mp[&quot;t&quot;]],&quot;f&quot;:table.mapping[mp[&quot;f&quot;]]} except KeyError: try: res|= {&quot;t&quot;:table.mapping[mp[&quot;t&quot;]//8],&quot;f&quot;:table.mapping[mp[&quot;f&quot;]//8]} except KeyError: print(mp,token.var,table.mapping) print(hex(def_site.address),def_site) print(&quot;key error&quot;,mp,table.mapping) raise RuntimeError(&quot;maybe not two direct indirect jump {}&quot;.format(hex(def_site.address))) if len(res)!=2: raise RuntimeError(&quot;calc load fail len!=2 {} {}&quot;.format(hex(def_site.address),def_site)) return res if isinstance(def_site.src,mlil_const): dependence=def_site.branch_dependence if len(dependence)==0: print(&quot;no dependence&quot;,def_site.address,def_site) return def_site.src.value.value key=max(dependence.keys()) if cond[&quot;value&quot;]==None: cond[&quot;value&quot;]=mlil_ssa[key].condition.non_ssa_form.expr_index if &quot;True&quot; in dependence[key].name: return {&quot;t&quot;:def_site.src.value.value} elif &quot;False&quot; in dependence[key].name: return {&quot;f&quot;:def_site.src.value.value} else: print(&quot;const but unknown branch name&quot;,def_site.address,def_site,dependence[key].name) return def_site.src.value.value pass def calc_cbk(lv,rv,op:function): if isinstance(lv,int) and isinstance(rv,int): return op(lv,rv) if isinstance(lv,dict) and isinstance(rv,dict): t=op(lv[&quot;t&quot;],rv[&quot;t&quot;]) f=op(lv[&quot;f&quot;],rv[&quot;f&quot;]) return {&quot;t&quot;:t,&quot;f&quot;:f} if isinstance(lv,int) and isinstance(rv,dict): t=op(lv,rv[&quot;t&quot;]) f=op(lv,rv[&quot;f&quot;]) return {&quot;t&quot;:t,&quot;f&quot;:f} if isinstance(lv,dict) and isinstance(rv,int): t=op(lv[&quot;t&quot;],rv) f=op(lv[&quot;f&quot;],rv) return {&quot;t&quot;:t,&quot;f&quot;:f} if isinstance(def_site.src,MediumLevelILXor): lv=def_site.src.left rv=def_site.src.right if isinstance(lv,mlil_const): lv=lv.value.value else: lv=two_direct_indirect_jump_handler.search_var_value_ssa(def_site.src.left.var,mlil_ssa,cond) if isinstance(rv,mlil_const): rv=rv.value.value else: rv=two_direct_indirect_jump_handler.search_var_value_ssa(def_site.src.right.var,mlil_ssa,cond) return calc_cbk(lv,rv,lambda x,y: x^y) if isinstance(def_site.src,MediumLevelILAdd): lv=def_site.src.left rv=def_site.src.right if isinstance(lv,mlil_const): lv=lv.value.value else: lv=two_direct_indirect_jump_handler.search_var_value_ssa(def_site.src.left.var,mlil_ssa,cond) if isinstance(rv,mlil_const): rv=rv.value.value else: rv=two_direct_indirect_jump_handler.search_var_value_ssa(def_site.src.right.var,mlil_ssa,cond) return calc_cbk(lv,rv,lambda x,y: x+y) if isinstance(def_site.src,MediumLevelILSub): lv=def_site.src.left rv=def_site.src.right if isinstance(lv,mlil_const): lv=lv.value.value else: lv=two_direct_indirect_jump_handler.search_var_value_ssa(def_site.src.left.var,mlil_ssa,cond) if isinstance(rv,mlil_const): rv=rv.value.value else: rv=two_direct_indirect_jump_handler.search_var_value_ssa(def_site.src.right.var,mlil_ssa,cond) return calc_cbk(lv,rv,lambda x,y: x-y) def check_manual_update(self,func:Function,addr:int,res:dict): auto_branch=func.get_indirect_branches_at(addr) print(auto_branch,res) if len(auto_branch)!=2: return False if auto_branch[0].dest_addr!=res[&quot;t&quot;] and auto_branch[0].dest_addr!=res[&quot;f&quot;]: return True if auto_branch[1].dest_addr!=res[&quot;t&quot;] and auto_branch[1].dest_addr!=res[&quot;f&quot;]: return True def check_addr_vaild(self,addr:int,bv:BinaryView): for seg in bv.segments: if seg.executable and seg.start&lt;=addr&lt;=seg.end and addr%4==0: return True return False def connect_basic_block(self,func:Function): mlil=func.mlil for _ in func.unresolved_indirect_branches: unsolved_addr=_[1] try: jump:MediumLevelILJump|MediumLevelILJumpTo=mlil[mlil.get_instruction_start(unsolved_addr)].ssa_form if not isinstance(jump,MediumLevelILJump) and not isinstance(jump,MediumLevelILJumpTo): raise RuntimeError(&quot;not jump {}&quot;.format(hex(jump.address))) var=jump.dest.ssa_form.var cond={&quot;value&quot;:None} res=two_direct_indirect_jump_handler.search_var_value_ssa(var,mlil.ssa_form,cond) if res==None or cond[&quot;value&quot;]==None: raise RuntimeError(&quot;calc fail {}&quot;.format(hex(jump.address))) # print(hex(unsolved_addr),self.check_bug_tag(mlil.source_function,unsolved_addr)) if (isinstance(jump,(MediumLevelILJump)) or self.check_manual_update(func,unsolved_addr,res)): print(hex(unsolved_addr),jump,func.mlil.get_expr(cond[&quot;value&quot;]),res) func.set_user_indirect_branches(unsolved_addr, [(func.arch,res[&quot;t&quot;]),(func.arch,res[&quot;f&quot;])],func.arch) self.resolved[unsolved_addr]=two_direct_indirect_jump_handler.resolved_data(cond=cond[&quot;value&quot;],trueAddr=res[&quot;t&quot;],falseAddr=res[&quot;f&quot;]) # print(hex(unsolved_addr),hex(res[&quot;t&quot;]),hex(res[&quot;f&quot;])) except Exception as e: print(hex(unsolved_addr),e) continue def convert_jump_to_if(self,ctx:AnalysisContext): new_func=MediumLevelILFunction(ctx.function.arch,low_level_il=ctx.llil) old_mlil=ctx.function.mlil new_func.prepare_to_copy_function(old_mlil) for old_block in old_mlil: new_func.prepare_to_copy_block(old_block) for instr_idx in range(old_block.start,old_block.end): instr=old_mlil[instr_idx] if isinstance(instr,MediumLevelILJumpTo) and isinstance(instr.dest,MediumLevelILVar) and not instr.get_possible_reg_values(instr.dest.var.storage).type==RegisterValueType.ConstantValue: # print(old_mlil.source_function.get_tags_at(instr.address,auto=True)) for tag in old_mlil.source_function.get_tags_at(instr.address,auto=True): old_mlil.source_function.remove_auto_address_tags_of_type(instr.address,tag.type.name) cond={&quot;value&quot;:None} try: res=two_direct_indirect_jump_handler.search_var_value_ssa(instr.dest.ssa_form.var,old_mlil.ssa_form,cond) if res==None or cond[&quot;value&quot;]==None or not self.check_addr_vaild(res[&quot;t&quot;],ctx.function.view) or not self.check_addr_vaild(res[&quot;f&quot;],ctx.function.view): old_mlil.source_function.add_tag(&quot;Bugs&quot;,&quot;need manual analyze jump&quot;,instr.address,auto=True) print(&quot;add bug tag at {}&quot;.format(hex(instr.address))) except Exception as e: old_mlil.source_function.add_tag(&quot;Bugs&quot;,&quot;need manual analyze jump&quot;,instr.address,auto=True) print(&quot;add bug tag at {}&quot;.format(hex(instr.address))) print(e) if isinstance(instr,MediumLevelILJumpTo) and instr.address in self.resolved: try: label_t=MediumLevelILLabel() label_f=MediumLevelILLabel() indirect_branches=ctx.function.get_indirect_branches_at(instr.address) if len(indirect_branches)!=2: raise RuntimeError(&quot;indirect branches len!=2 {} {}&quot;.format(hex(instr.address),indirect_branches)) for branch in indirect_branches: if branch.dest_addr==self.resolved[instr.address].trueAddr: label_t.operand=instr.targets[branch.dest_addr] if branch.dest_addr==self.resolved[instr.address].falseAddr: label_f.operand=instr.targets[branch.dest_addr] if_expr=new_func.if_expr(old_mlil.get_expr(self.resolved[instr.address].cond).copy_to(new_func), label_t,label_f,old_mlil[instr_idx].source_location) new_func.append(if_expr,old_mlil[instr_idx].source_location) except Exception as e: print(e) new_func.append(old_mlil[instr_idx].copy_to(new_func),old_mlil[instr_idx].source_location) else: new_func.append(old_mlil[instr_idx].copy_to(new_func),old_mlil[instr_idx].source_location) new_func.finalize() new_func.generate_ssa_form() ctx.mlil=new_func def re_run_calc_check(self,var:SSAVariable): cond={&quot;value&quot;:None} try: res=self.search_var_value_ssa(var,self.ctx.function.mlil.ssa_form,cond) except Exception as e: print(e) return False if res==None or cond[&quot;value&quot;]==None: return False return True def run(self): self.connect_basic_block(self.ctx.function) self.convert_jump_to_if(self.ctx) def install_two_direct_indirect_jump_handler(ctx:AnalysisContext): handler=two_direct_indirect_jump_handler(ctx) handler.run()wf=Workflow(&quot;&quot;).clone(&quot;satori.function.deobf&quot;)wf.register_activity(Activity(configuration=json.dumps({ &quot;name&quot;:&quot;satori.function.handle_two_direct_indirect_jump.activity&quot;, &quot;title&quot;:&quot;handle_two_direct_indirect_jump&quot;, &quot;description&quot;:&quot;handle_two_direct_indirect_jump&quot;, &quot;eligibility&quot;:{ &quot;auto&quot;:{ &quot;default&quot;:True } }}),action=lambda context: install_two_direct_indirect_jump_handler(context)))wf.insert(&quot;core.function.generateHighLevelIL&quot;,[&quot;satori.function.handle_two_direct_indirect_jump.activity&quot;])wf.register() search_var_value_ssa123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103def search_var_value_ssa(var:SSAVariable,mlil_ssa:MediumLevelILFunction,cond): def_site=var.def_site # print(hex(def_site.address),var,def_site.get_possible_reg_values_after(var.var.storage)) lv,rv=None,None if isinstance(def_site,MediumLevelILVarPhi): lv=two_direct_indirect_jump_handler.search_var_value_ssa(def_site.src[0],mlil_ssa,cond) rv=two_direct_indirect_jump_handler.search_var_value_ssa(def_site.src[1],mlil_ssa,cond) if lv==None or rv==None: raise RuntimeError(&quot;phi calc fail\\n {} {} \\n {} {}&quot;.format(def_site.src[0].def_site,def_site.src[1]def_site,hex(def_site.address),def_site)) return lv | rv if isinstance(def_site,MediumLevelILSetVarSsa): if isinstance(def_site.src,MediumLevelILLoadSsa): tokens=list(def_site.src.traverse(lambda x: x)) table=def_site.get_possible_reg_values_after(def_site.dest.var.storage) if table.type!=RegisterValueType.LookupTableValue: raise RuntimeError(&quot;not lookup table {} {}&quot;.format(hex(def_site.address),def_site)) # print(table.mapping) res={} for token in tokens: if isinstance(token,MediumLevelILVarSsa): mp=two_direct_indirect_jump_handler.search_var_value_ssa(token.var,mlil_ssa,cond) if mp==None: continue try: res|= {&quot;t&quot;:table.mapping[mp[&quot;t&quot;]],&quot;f&quot;:table.mapping[mp[&quot;f&quot;]]} except KeyError: try: res|= {&quot;t&quot;:table.mapping[mp[&quot;t&quot;]//8],&quot;f&quot;:table.mapping[mp[&quot;f&quot;]//8]} except KeyError: print(mp,token.var,table.mapping) print(hex(def_site.address),def_site) print(&quot;key error&quot;,mp,table.mapping) raise RuntimeError(&quot;maybe not two direct indirect jump {}&quot;.format(hex(def_siteaddress))) if len(res)!=2: raise RuntimeError(&quot;calc load fail len!=2 {} {}&quot;.format(hex(def_site.address),def_site)) return res if isinstance(def_site.src,mlil_const): dependence=def_site.branch_dependence if len(dependence)==0: print(&quot;no dependence&quot;,def_site.address,def_site) return def_site.src.value.value key=max(dependence.keys()) if cond[&quot;value&quot;]==None: cond[&quot;value&quot;]=mlil_ssa[key].condition.non_ssa_form.expr_index if &quot;True&quot; in dependence[key].name: return {&quot;t&quot;:def_site.src.value.value} elif &quot;False&quot; in dependence[key].name: return {&quot;f&quot;:def_site.src.value.value} else: print(&quot;const but unknown branch name&quot;,def_site.address,def_site,dependence[key].name) return def_site.src.value.value pass def calc_cbk(lv,rv,op:function): if isinstance(lv,int) and isinstance(rv,int): return op(lv,rv) if isinstance(lv,dict) and isinstance(rv,dict): t=op(lv[&quot;t&quot;],rv[&quot;t&quot;]) f=op(lv[&quot;f&quot;],rv[&quot;f&quot;]) return {&quot;t&quot;:t,&quot;f&quot;:f} if isinstance(lv,int) and isinstance(rv,dict): t=op(lv,rv[&quot;t&quot;]) f=op(lv,rv[&quot;f&quot;]) return {&quot;t&quot;:t,&quot;f&quot;:f} if isinstance(lv,dict) and isinstance(rv,int): t=op(lv[&quot;t&quot;],rv) f=op(lv[&quot;f&quot;],rv) return {&quot;t&quot;:t,&quot;f&quot;:f} if isinstance(def_site.src,MediumLevelILXor): lv=def_site.src.left rv=def_site.src.right if isinstance(lv,mlil_const): lv=lv.value.value else: lv=two_direct_indirect_jump_handler.search_var_value_ssa(def_site.src.left.var,mlil_ssa,cond) if isinstance(rv,mlil_const): rv=rv.value.value else: rv=two_direct_indirect_jump_handler.search_var_value_ssa(def_site.src.right.var,mlil_ssa,cond) return calc_cbk(lv,rv,lambda x,y: x^y) if isinstance(def_site.src,MediumLevelILAdd): lv=def_site.src.left rv=def_site.src.right if isinstance(lv,mlil_const): lv=lv.value.value else: lv=two_direct_indirect_jump_handler.search_var_value_ssa(def_site.src.left.var,mlil_ssa,cond) if isinstance(rv,mlil_const): rv=rv.value.value else: rv=two_direct_indirect_jump_handler.search_var_value_ssa(def_site.src.right.var,mlil_ssa,cond) return calc_cbk(lv,rv,lambda x,y: x+y) if isinstance(def_site.src,MediumLevelILSub): lv=def_site.src.left rv=def_site.src.right if isinstance(lv,mlil_const): lv=lv.value.value else: lv=two_direct_indirect_jump_handler.search_var_value_ssa(def_site.src.left.var,mlil_ssa,cond) if isinstance(rv,mlil_const): rv=rv.value.value else: rv=two_direct_indirect_jump_handler.search_var_value_ssa(def_site.src.right.var,mlil_ssa,cond) return calc_cbk(lv,rv,lambda x,y: x-y) 这是整个activity的核心函数，通过搜索来查找各变量的值，顺带收集cond，这里采用SSA形式的mlil是因为常规mlil的变量定义位置def_site可能很多，因为变量会被复用 SSA是反编译领域的一种代码格式，指的是一个变量只在其被定义的时候赋值一次，这种格式的代码非常适合做数据流分析 BianryNinja的变量搞得比较臃肿，有*LevelILVar,*LevelILVarSsa,Variable,SSAVariable，其中前两个是从指令的参数中直接取出来的，后两个可以由前两个的.var成员获取，前两个直接可以通过ssa_form和non_ssa_form成员互相转化（因为前两个其实本质是expr） 在BianryNinja IL 中，用户看到的一条条的指令称为instruction,而组成指令的操作数，操作符称为expression，expression使用类似AST的结构组成instruction，instruction和expression在每个函数中分别独立拥有自己的index，bn正是通过维护这些index来将分析的结果不停的传给下一个activity 这里使用SSAVariable类型进行搜索，因为就这种类型有def_site这里考虑一种更加泛化的思路，对于我们在正在搜索的一个变量，他首先有这几种情况 phi指令也是ssa分析中的一种概念，指的是同一变量的不同版本（因为只在其定义时被赋值，所以会有很多版本）在分支的合并处进行值合并 phi指令，也就是两种逻辑分支的值进行合并 set指令，也就是被一个表达式赋值，而这又可以分出三种情况 MediumLevelILLoadSsa，从查找表中取值 数值运算，比如sub,add等 定值赋值，这个可能出现在常量中，也可能出现在if分支开始的地方 对于phi指令，其实就是csel的两个分支做合并了，这里使用key为t,f的字典储存结果，显然这里只需要把两个变量搜出来的结果合并即可也就是把t和f的case或一下，按理说不出bug的情况肯定是t和f各一个 查找表取值的情况直接用traverse先把查找语句中所有的expr都取出来，然后依次遍历，常量就不管，通常这里只有一个变量，因为有两个变量的话get_possible_reg_values_after取不出来映射表，我们这里的目的是吧index -&gt; value的映射即LookupTable转换为t/f -&gt; value的映射，遇到变量后直接以这个变量开始搜数值运算的话稍微分类讨论下，根据左右值为字典或常量分出4种case，然后求解即可，这里其实就是把两个搜出来的结果做合并赋值的话直接返回常量，没什么好说的 这个函数最终要么返回常量，要么返回t/f的字典，要么直接抛错误，我们这里只要返回字典的情况 connect_basic_block1234567891011121314151617181920212223def connect_basic_block(self,func:Function): mlil=func.mlil for _ in func.unresolved_indirect_branches: unsolved_addr=_[1] try: jump:MediumLevelILJump|MediumLevelILJumpTo=mlil[mlil.get_instruction_start(unsolved_addr)].ssa_form if not isinstance(jump,MediumLevelILJump) and not isinstance(jump,MediumLevelILJumpTo): raise RuntimeError(&quot;not jump {}&quot;.format(hex(jump.address))) var=jump.dest.ssa_form.var cond={&quot;value&quot;:None} res=two_direct_indirect_jump_handler.search_var_value_ssa(var,mlil.ssa_form,cond) if res==None or cond[&quot;value&quot;]==None: raise RuntimeError(&quot;calc fail {}&quot;.format(hex(jump.address))) # print(hex(unsolved_addr),self.check_bug_tag(mlil.source_function,unsolved_addr)) if (isinstance(jump,(MediumLevelILJump)) or self.check_manual_update(func,unsolved_addr,res)): print(hex(unsolved_addr),jump,func.mlil.get_expr(cond[&quot;value&quot;]),res) func.set_user_indirect_branches(unsolved_addr, [(func.arch,res[&quot;t&quot;]),(func.arch,res[&quot;f&quot;])],funcarch) self.resolved[unsolved_addr]=two_direct_indirect_jump_handler.resolved_data(cond=cond[&quot;value&quot;]trueAddr=res[&quot;t&quot;],falseAddr=res[&quot;f&quot;]) # print(hex(unsolved_addr),hex(res[&quot;t&quot;]),hex(res[&quot;f&quot;])) except Exception as e: print(hex(unsolved_addr),e) continue 这个函数主要的工作是遍历所有标记了unresolved_indirect_branch的地址，然后尝试计算跳转情况并且使用set_user_indirect_branches将当前基本块与算出来的地址所在的基本块连起来，注意到set_user_indirect_branches会触发BinaryNinja的重分析事件，也就是说workflow会在此时立刻被打断且从头开始，因此这里需要小心处理避免产生死循环这里check_manual_update的情况是有可能先前因为表地址错误之类的原因导致算出来的地址是错的，因此要通过手动set user variable value来修正错误，此时算出来的结果肯定和get_indirect_branches_at获取到的的不一样，因此要重新设置此处的indirect_branches，至于已经连接过的，就把结果添加到resolved在之后使用 convert_jump_to_if12345678910111213141516171819202122232425262728293031323334353637383940414243444546def convert_jump_to_if(self,ctx:AnalysisContext): new_func=MediumLevelILFunction(ctx.function.arch,low_level_il=ctx.llil) old_mlil=ctx.function.mlil new_func.prepare_to_copy_function(old_mlil) for old_block in old_mlil: new_func.prepare_to_copy_block(old_block) for instr_idx in range(old_block.start,old_block.end): instr=old_mlil[instr_idx] if isinstance(instr,MediumLevelILJumpTo) and isinstance(instr.dest,MediumLevelILVar) and not instrget_possible_reg_values(instr.dest.var.storage).type==RegisterValueType.ConstantValue: # print(old_mlil.source_function.get_tags_at(instr.address,auto=True)) for tag in old_mlil.source_function.get_tags_at(instr.address,auto=True): old_mlil.source_function.remove_auto_address_tags_of_type(instr.address,tag.type.name) cond={&quot;value&quot;:None} try: res=two_direct_indirect_jump_handler.search_var_value_ssa(instr.dest.ssa_form.var,old_mlilssa_form,cond) if res==None or cond[&quot;value&quot;]==None or not self.check_addr_vaild(res[&quot;t&quot;],ctx.function.view)or not self.check_addr_vaild(res[&quot;f&quot;],ctx.function.view): old_mlil.source_function.add_tag(&quot;Bugs&quot;,&quot;need manual analyze jump&quot;,instr.addressauto=True) print(&quot;add bug tag at {}&quot;.format(hex(instr.address))) except Exception as e: old_mlil.source_function.add_tag(&quot;Bugs&quot;,&quot;need manual analyze jump&quot;,instr.address,auto=True) print(&quot;add bug tag at {}&quot;.format(hex(instr.address))) print(e) if isinstance(instr,MediumLevelILJumpTo) and instr.address in self.resolved: try: label_t=MediumLevelILLabel() label_f=MediumLevelILLabel() indirect_branches=ctx.function.get_indirect_branches_at(instr.address) if len(indirect_branches)!=2: raise RuntimeError(&quot;indirect branches len!=2 {} {}&quot;.format(hex(instr.address)indirect_branches)) for branch in indirect_branches: if branch.dest_addr==self.resolved[instr.address].trueAddr: label_t.operand=instr.targets[branch.dest_addr] if branch.dest_addr==self.resolved[instr.address].falseAddr: label_f.operand=instr.targets[branch.dest_addr] if_expr=new_func.if_expr(old_mlil.get_expr(self.resolved[instr.address].cond).copy_t(new_func), label_t,label_f,old_mlil[instr_idx].source_location) new_func.append(if_expr,old_mlil[instr_idx].source_location) except Exception as e: print(e) new_func.append(old_mlil[instr_idx].copy_to(new_func),old_mlil[instr_idx].source_location) else: new_func.append(old_mlil[instr_idx].copy_to(new_func),old_mlil[instr_idx].source_location) new_func.finalize() new_func.generate_ssa_form() ctx.mlil=new_func 这个函数负责两个工作，一是根据之前的计算结果构造if指令，这样本来非常丑的switch就会变成if，二是检查计算结果是否合法，如果不合法的话要打上tag之后再修复构造if指令主要麻烦的点在于设置label，这里的话必须把原函数整个拷贝一遍，根据文档中的说法要对函数和基本块依次调用prepare_to_copy_function和prepare_to_copy_block，这两个方法会向新函数中复制一些元数据，然后遍历指令，匹配MediumLevelILJumpTo(设置了indirect branch后jump会自动变成jumpTo)并且检查地址是否在resolved里（似乎有点重复），这里dest_addr和target中的key和我们当初设置的addr是完全一样的，而其对应的mlil的address属性的值和我们设置的addr不一定是一样的，这可能是因为mlil指令的宽度问题，但是bn在这里的处理不是很好，目前看来从indirect_branches和targets将地址转换为instrution index是比较好的设置label目前就只能通过直接构造，然后给oprand属性赋值的办法，在调用finalize会自动处理label，除此之外找不到更好的设置mlil label的方式，get_label_for_source_instruction完全不好用然后就是把之前顺带搜到的cond复制到新的mlil里，然后构造if_expr 对于添加tag的部分，主要是mtguard.so的这种跳转表地址不是唯一的，也就是对于一个load，他的表变量不是常量，可能有preA和preB两个前驱，这里显然是需要手动指定表地址的，而bn在分析的过程中，可能preB还没修复完毕就分析了这里，那很可能就会算出错的结果，而当preB也修复完后，此处的计算会正确的抛出错误，但是我们没法撤销这里设置的跳转，因为这里的控制流可能会往前指，撤销设置触发重分析后可能又会导致计算不抛错误，那就死循环了所以我们的处理方式是最后再跑一次计算，如果发现算出来结果不一样，或者抛错误了，就设置一个Bugs标签 最后所有指令都复制完了，调用finalize和generate_ssa_form，然后把新构造好的mlil对象赋值给旧的做替换 效果这里设置一下函数的分析方式，使用我们自己的workflow分析satori.function.deobf修完大概长这样，看着还可以，他计算cond应该是用了mba表达式，乱七八糟的计算比较多，没有删掉显得比较多","link":"/ctf/auto-re-dev/bnWorkflow0x1/"},{"title":"stalker别来沾边，我怕qbdi误会","text":"汇编粒度trace唯一指定框架 什么是QBDIQDBI全名QuarkslaB-Dynamic bianry Instrumentation，是一种基于DBI框架的细粒度trace框架，其运行原理和Frida Stalker类似，采用对目标程序的指令按基本块切分后JIT编译成插入了回调的代码，然后再在目标程序同一进程空间中执行 why QBDItrace的方案有很多，但QBDI是这里面性能最好的，ebpf需要在用户态和内核态之间来回切换开销不可接受，而且还不支持windows，unidbg需要各种补环境，代码越写越臃肿，frida-stalker是这里面最接近qbdi方案的，但是stalker本身bug很多，而且性能不如qbdi，而QBDI不仅性能好，而且跨平台跨架构，支持C API和Python API，还有迁移到frida的js/ts API frida/QBDIfrida/QBDI是qbdi的js API,在设计初就和frida联动，而且上手非常容易 VMVM是qbdi中管理回调和代码执行的对象，这里介绍几个基本的方法 VM.addInstrumentedModuleFromAddr(addr)这个函数将一个地址所在的整个内存段纳入VM的插桩范围，注意到qbdi的VM默认不对任何地址插桩，也就是说就算调用VM.call，也需要执行的地址处于插桩范围内才会触发回调，这个addr参数可以传number也可以传frida的NativePointer VM.newInstCallback(cbk)这个函数返回一个指令回调对象，也就是VM每执行一句指令就会触发一次的回调,cbk参数是一个签名为function(vm,gpr,fpr,data)的js函数，这里vm就是执行指令的vm对象，gpr是触发回调时的常规寄存器信息，fpr是浮点寄存器信息,data是创建回调时用户提供的额外数据,这个函数必须返回一个VMAction枚举量(continue,skip ....)，否则会导致vm的执行出现不可预测的行为 VM.addCodeCB(pos, cbk, data, priority)这个函数用于把一个回调绑定到VM对象，pos指的是要在指令执行前还是执行后触发该回调(有PreInst和PostInst)两个选项，cbk是回调对象，data则是传递给回调的数据，priority指的是这个回调的优先级，处于同一位置，数字越大的回调会越先触发 VM.addMemAccessCB(type, cbk, data, priority)这个函数专门用来为任意位置的内存访问行为添加回调，type可以选择读，写或者读写都监测，cbk是指令回调对象，data和priority的意思和CodeCB一样 VM.switchStackAndCall(address, args, stackSize)在VM中执行并跟踪一个函数，与VM.call不同这个函数创建一个新栈然后把qbdi引擎放到新栈上执行，而目标函数则在原栈上执行，避免目标函数的行为污染qbdi引擎，address直接传NativePointer即可，args传number或者NativePointer都行，stacksize则是分配的栈大小，可以手动设置也可以用默认的 VM.getInstAnalysis(type)获取当前指令的信息，这个函数在回调中使用,type是下面五个枚举量的掩码 ANALYSIS_DISASSEMBLY ANALYSIS_INSTRUCTION ANALYSIS_OPERANDS ANALYSIS_SYMBOL ANALYSIS_JIT 其中ANALYSIS_SYMBOL运行时基本没正常过，ANALYSIS_JIT一般用不到，ANALYSIS_DISASSEMBLY可以生成指令的汇编，ANALYSIS_INSTRUCTION记录指令的地址之类的信息,ANALYSIS_OPERANDS记录了指令所有参数的信息 VM.getInstMemoryAccess()获取上一次指令的内存访问信息，记录了访问类型，读写地址，读写值，读写大小 VM.setGPRState(state) VM.getGPRState()获取和设置VM对象的常规寄存器信息，通常用在执行前和frida同步数据上 GPRState.synchronizeContext(FridaCtx, direction)用于从FridaCtx(回调里的this.context)中读取上下文信息并写入到GPRState中，direction参数因为从GPR向Frida写入的功能未实现所以并没有什么意义，只能填FRIDA_TO_QBDI GPRState.getRegister(rid)根据寄存器名或寄存器id返回目标上下文中的对应寄存器值 InstAnalysis这个对象是VM.getInstAnalysis返回的对指令的分析，有一下几个属性是比较重要的 inst.address 指令的地址 inst.disassembly 反汇编 inst.operands 一个数组，记录了指令的所有参数信息 inst.operands[i].regAccess 这个参数的寄存器访问类型，0就是没访问，1是读,2是写,3是读写 inst.operands[i].regName 如果访问了寄存器则这一项是寄存器名 inst.operands[i].regCtxIdx 寄存器id，注意到如果访问eax不会返回rax而是返回eax，但两者对应的寄存器id是一样的，而gprState.getRegister如果以寄存器名为参数只认识rax而不认识eax，使用寄存器id查询则没有这个问题 MemoryAccess由vm.getInstMemoryAccess返回的记录指令内存访问信息的对象，有以下几个属性比较重要 memAcc[i].instAddress 同样记录了哪个位置的指令访问了内存 memAcc[i].type 记录了访问类型，即读，写，和读写 memAcc[i].accessAddress 访问的内存地址 memAcc[i].size 访问大小 memAcc[i].value 读或写的值 简单Trace模板代码有了上面这些API，就能搓一个简单的Trace模板了，这里直接贴代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154import {AnalysisType, CallbackPriority, InstPosition, MemoryAccessType, OperandFlag, rword, SyncDirection, VM, VMAction} from './frida-qbdi'export function startTrace( vm: VM, module: Module, funcOffset: number, writeLogInHost: boolean, logs: any, args?: any[],) { type CallbackDataT = { module: Module, funcOffset: number, logFile: any, }; type RegInfo = { name: string, idx: number, }; var log = ''; vm.addInstrumentedModuleFromAddr(module.base.add(funcOffset)); var RegRead: RegInfo[] = []; var RegWrite: RegInfo[] = []; var pre_RegValue: Map&lt;string, undefined|NativePointer&gt; = new Map(); // var post_RegValue: Map&lt;string, undefined|NativePointer&gt; = new Map(); var pre_inst_callback = vm.newInstCallback(function( vm: VM, gprState, fprState, data: CallbackDataT) { var inst = vm.getInstAnalysis( AnalysisType.ANALYSIS_DISASSEMBLY | AnalysisType.ANALYSIS_INSTRUCTION | AnalysisType.ANALYSIS_OPERANDS); log = data.module.name + '!+0x' + ptr(inst.address).sub(data.module.base).toString(16) + ' ' + inst.disassembly; RegRead = []; RegWrite = []; for (let i = 0; i &lt; inst.operands.length; i++) { if ((inst.operands[i].regAccess == 3 || inst.operands[i].regAccess == 2) &amp;&amp; inst.operands[i].regCtxIdx != -1) RegWrite.push({ name: inst.operands[i].regName as string, idx: inst.operands[i].regCtxIdx as number }); else if ( inst.operands[i].regAccess == 1 &amp;&amp; inst.operands[i].regCtxIdx != -1) RegRead.push({ name: inst.operands[i].regName as string, idx: inst.operands[i].regCtxIdx as number }); if (inst.operands[i].regAccess != 0 &amp;&amp; inst.operands[i].regCtxIdx != -1) { pre_RegValue.set( inst.operands[i].regName as string, gprState.getRegister(inst.operands[i].regCtxIdx as number)); } } return VMAction.CONTINUE; }); var post_inst_callback = vm.newInstCallback(function( vm: VM, gprState, fprState, data: CallbackDataT) { let regReadLog = 'r['; for (let i = 0; i &lt; RegRead.length; i++) { regReadLog += RegRead[i].name + ':0x' + pre_RegValue.get(RegRead[i].name)?.toString(16) + ', '; } regReadLog += '] '; let regWriteLog = 'w['; for (let i = 0; i &lt; RegWrite.length; i++) { regWriteLog += `${RegWrite[i].name}:${pre_RegValue.get(RegWrite[i].name)}=&gt;${ gprState.getRegister(RegWrite[i].idx)}, `; } regWriteLog += ']'; log += ' ' + regReadLog + regWriteLog + '\\n'; if (writeLogInHost) send({type: 'qbdi', log: log}); else (data.logFile as any).write(log); return VMAction.CONTINUE; }); var mem_acc_callback = vm.newInstCallback(function( vm: VM, gprState, fprState, data: CallbackDataT) { var memAcc = vm.getInstMemoryAccess(); var memlog = ''; for (let i = 0; i &lt; memAcc.length; i++) { let addr = data.module.name + '!+0x' + ptr(memAcc[i].instAddress).sub(data.module.base).toString(16); addr = ''; if (memAcc[i].type == MemoryAccessType.MEMORY_READ) memlog += `mem_r[0x${memAcc[i].accessAddress.toString(16)}]:0x${ memAcc[i].value.toString(16)} (size:${memAcc[i].size}) ${addr}\\n` if (memAcc[i].type == MemoryAccessType.MEMORY_WRITE) memlog += `mem_w[0x${memAcc[i].accessAddress.toString(16)}]:0x${ memAcc[i].value.toString(16)} (size:${memAcc[i].size}) ${addr}\\n` if (memAcc[i].type == MemoryAccessType.MEMORY_READ_WRITE) memlog += `mem_rw[0x${memAcc[i].accessAddress.toString(16)}]:0x${ memAcc[i].value.toString(16)} (size:${memAcc[i].size}) ${addr}\\n` } if (writeLogInHost) send({type: 'qbdi', log: memlog}); else data.logFile.write(memlog); return VMAction.CONTINUE; }); vm.addCodeCB( InstPosition.PREINST, pre_inst_callback, {module: module, funcOffset: funcOffset, logFile: logs}); vm.addCodeCB( InstPosition.POSTINST, post_inst_callback, {module: module, funcOffset: funcOffset, logFile: logs}); vm.addMemAccessCB( MemoryAccessType.MEMORY_READ_WRITE, mem_acc_callback, {module: module, funcOffset: funcOffset, logFile: logs}); vm.switchStackAndCall(module.base.add(funcOffset), args);}function syncCtx_AndTrace( vm: VM, module: Module, funcOffset: number, args: any[], FridaCtx: any, logs: any, writeLogInHost: boolean = true) { var GPRctx = vm.getGPRState(); GPRctx.synchronizeContext(FridaCtx, SyncDirection.FRIDA_TO_QBDI); vm.setGPRState(GPRctx); startTrace(vm, module, funcOffset, writeLogInHost, logs, args); send({type: 'qbdi', signal: '[-] Function Return.'});}var logs = new (File as any)('trace.log', 'w');function traceWrapper() { var vm = new VM(); var lib = Process.getModuleByName('test_qbdi'); var funcOffset = 0x1838; var originFunc = new NativeFunction(lib.base.add(funcOffset), 'void', ['pointer', 'int']); var fridaCbk = new NativeCallback(function(str: NativePointer, len: number): void { Interceptor.revert(lib.base.add(funcOffset)); Interceptor.flush(); // 这条的args与NativeCallback的args一致 syncCtx_AndTrace( vm, lib, funcOffset, [str, len], this.context, logs, false); traceWrapper(); }, 'void', ['pointer', 'int']); Interceptor.replace(lib.base.add(funcOffset), fridaCbk);}traceWrapper(); 这里我们先注册指令前和指令后回调分别记录指令执行前后的寄存器信息，然后再注册一个内存读写回调记录内存读写信息，然后做一点简单的格式化，把采集到的信息以相对整齐的格式记录下来，主要是指令地址，寄存器变化和内存变化，这里还可以用frida获取到的二进制文件基址来算出指令的偏移并记录，这样Trace回调的部分就完成了然后设计Trace触发的部分，这里我们希望其尽可能还原真实运行的状态，所以我们用frida替换原函数，然后在hook触发时先恢复原函数入口点，这一点很重要，不然qbdi会跑进frida的指令里，然后我们直接同步上下文并把原函数hook到的参数传进去，同步寄存器后直接运行，采用switchStackAndCall是因为这个api会让指令在原栈上运行且不用我们自己管理栈 目标测试程序1234567891011121314151617181920212223#include &lt;stdio.h&gt;int add(int x, int y) { return x + y; }int sub(int x, int y) { return x - y; }int runCnt = 0;void _xor(char *data_, int len) { for (int i = 0; i &lt; len; i++) { data_[i] ^= 0x55; } runCnt++;}int main() { int a, b, c; a = 3, b = 4, c = 5; printf(&quot;%d %d %d\\n&quot;, a, b, c); char data[] = &quot;Hello, World!&quot;; _xor(data, sizeof(data) - 1); printf(&quot;%d %d\\n&quot;, add(a, b), sub(b, c)); _xor(data, sizeof(data) - 1); printf(&quot;%s\\n&quot;, data); printf(&quot;%d\\n&quot;, runCnt); return 0;} 这里trace _xor这个函数 trace日志最后甚至可以在日志中加点ANSI字符上色，忽略ai做的幽默配色可以看出来效果还是不错的，配合vscode相同字符串高亮还可以帮忙分析循环节缺点就是qbdi在x86上还是有不少bug，这个代码的内存读写监视部分在x86上就随机出现内存访问错误，导致内存监视不全，对arm64测试下来倒是没发现问题","link":"/ctf/auto-re-dev/qbdi/"},{"title":"Unicorn 修复CEST&#x2F;CSEL有关间接跳转的一些例子","text":"本文中使用大量BianryNinja Python Api 和 Unicorn APi本文使用腾讯游戏安全大赛2023安卓初赛中的libsec2023.so作为样本已知bug：追溯时遇到循环会卡死还未实现指令前移 什么是间接跳转间接跳转指的是在程序原本正常的控制流中，将部分跳转指令的参数由常量改为寄存器值，并通过查表/实时计算地址的形式将原本的静态的地址隐藏起来，从而达到阻止反编译器分析的效果，目前主流的反编译器如ida，BinaryNinja对间接跳转的分析效果均不佳一则间接跳转的例子如下可以看到先对w0和0进行比较更新condition flag的值，然后初始化w8,w9两个寄存器值作为跳转的两种不同方向，在根据情况赋值x8的同时加载跳转表(0x72000+0xc20),然后把x8作为跳转表中的偏移获取对应的地址，注意此时的地址仍不是正确的，再最后执行一次add后才获得了正确的地址 如果我不会写自动化去除脚本该怎么办如果你主要使用ida，那么恭喜你这个样本你可以扔回收站了，ida作为一款纯静态分析工具完全无法实时计算地址对于BianryNinja，有两种方法可以凑合让反编译器恢复控制流，一是把data段的权限设置为只读，因为基于保守分析的原则如果data段可写的话反编译器完全不会去计算跳转地址（因为无法确认静态状态下的跳转表数据是否可信），当data段只读后对于一些计算相对简单的跳转翻译器会尝试去计算其目标，但是效果仍不佳，对于cset/csel这类带分支的间接跳转尤其 123456CSET/CSEL是arm汇编中的两种条件赋值指令CSEL的格式为 CESL dest source1 source2 condcond为条件标识，就是ge le eq之类的当条件满足时dest会由source1赋值，否则由source2赋值CSET的格式为 CSET dest cond如果条件满足则dest被置1，否则置0 这是一处修改data段权限的例子可以看到这处还算可以，整个跳转结构被解析成了一个switch 但并非每次都好用可以看到这里就没有处理出来，注意到计算地址时用到了w8，而网上追溯w8的值由x0所指的地址读取而来，根据arm64调用约定x0是一个函数的第一个参数，所以这是一处跨函数的间接跳转，一些必要参数由函数外传入，反编译器获取不了足够的上下文自然无法计算地址 还有一种方法是自己算出跳转地址后在BinaryNinja的medium IL 或 high IL 视图下给jump里的参数指定user value即告诉反编译器这个参数的值确保为用户指定的值，这样也可以一定程度获得勉强能看的结果，不过这种办法要获取地址，还是有点麻烦的 解决这个问题需要什么我们最终的目的是获取跳转的地址并把br修改成b #xxxxx 的常量跳转，还是上面的例子我们注意到这个结构有一些特点 结尾的最后两行add和br指令完全与程序的正常业务无关，patch掉他们完全没影响 理论上可以设置一个很远栈变量或者寄存器值（比如上文提到的从函数外传进来的x0），然后在计算地址时用到这个值，即不能确定模拟执行的起点 中间可以添加类似frida检测的逻辑将我们导向错误的控制流，而因为我们很难静态分析去对抗检测，所以使用trace获取跳转表再patch未必好用 可以得出几个结论 显然这个跳转只有满足cond和不满足两种情况，以eq为例，我们可以把最后两行无用的指令替换成 b.eq xxx 和 b.ne xxx这样一对互补的指令，这样既能覆盖所有跳转情况，也不会因为过早跳转导致错过必要的指令导致程序逻辑错误 模拟执行的可以分为两步，第一步是执行到csel之前，这时我们暂停执行并保存所有寄存器值，用于获取csel前的上文信息,然后我们从csel开始执行两次模拟执行，每次执行完后恢复寄存器信息，第一次将dest设为source1，第二次将dest块再执行，极端情况就寻找交叉引用，跳转到调用间接跳转所在的设为source2，用于获取cmp两种情况时不同的地址 虽然我们不能确定模拟执行的起点，一次缺少上下文的模拟必然会有两种结果 模拟过程中访问错误地址，直接让模拟执行抛出异常 计算出来的地址歪的离谱，很可能在text段之外 所以我们可以考虑多次尝试模拟执行，如果模拟执行过程中捕获到错误，或者最后发现地址值很离谱，就往前追溯一个基本块再执行，这样一直往前追溯直到计算出的地址通过校验为止 所以最后我们的流程就是先获取csel/cset前的寄存器信息，然后分别执行两次获取不同分支的结果，如果遇到错误就将模拟的范围提前并重新执行，最后获取正确地址后patch到最后两条指令的位置 具体实现模拟执行的准备工作因为so本身也不大，为了方便我们直接遍历所有段，把整个so都载入模拟执行bv是BinaryNinja在脚本执行时全局维护的一个单例，是和bn交互的接口，我们的各种信息都是通过bv提供的方法获取的 1234567891011uc = Uc(UC_ARCH_ARM64, UC_MODE_ARM)uc.mem_map(CODE_BASE, CODE_SIZE, UC_PROT_ALL) # 分配text段内存uc.mem_map(STACK_BASE, STACK_SIZE, UC_PROT_ALL) # 分配栈内存for segment in bv.segments: # 用bn API遍历所有段 if segment.readable: start = segment.start end = segment.end size = end-start print(&quot;[+] Mapping segment: [{}]&quot;.format(hex(segment.data_length))) content = bv.read(start, size) # 读取段数据 uc.mem_write(start, content) # 写入uc模拟器 寻找特征指令之后我们遍历所有指令，从中寻找带有间接跳转特征的br指令，具体流程为记录遇到的最后一个csel或cset，在遇到br后检测记录的csel和cset是否和br在同一个函数内，并且查看这句br指令否有bn自动打上的Unresolved Indirect Control Flow 标记，如果有则可以认为这是一处需要修复的间接跳转 12345678910111213141516171819202122232425262728293031323334353637383940414243lastCsel = None lastCset = None nextWork = None # 记录最后遇到的是csel还是cset for instruction in bv.instructions: # 遍历所有指令 curAddr = instruction[1] # print(curAddr) if instruction[0][0].text == &quot;csel&quot;: lastCsel = instruction nextWork = &quot;csel&quot; if instruction[0][0].text == &quot;cset&quot;: lastCset = instruction nextWork = &quot;cset&quot; if instruction[0][0].text == &quot;br&quot;: tags = bv.get_functions_containing(curAddr)[0].tags # 获取当前函数的所有tag curTag = None for tag in tags: if tag[1] == curAddr: #寻找br指令上的tag curTag = tag[2] break if curTag is None or not (curTag.type.name == &quot;Unresolved Indirect Control Flow&quot;): # 查看是否为间接控制流 continue # print(hex(curAddr)) curBB = bv.get_basic_blocks_at(curAddr)[0] # 获取当前指令所在的基本块 curFunc = bv.get_functions_containing(curAddr)[0] # 获取当前指令所在的函数 # print(curBB) if nextWork is None: continue try: if nextWork == &quot;csel&quot;: if lastCsel[1] &lt; curFunc.start or lastCsel[1] &gt; curBB.end: # 判断csel指令是否在当前函数内 continue workCsel(uc, bv, lastCsel, instruction, (curBB.start, curBB.end), (0xf4c0, 0x591d0), white=[curBB.start]) nextWork = None elif nextWork == &quot;cset&quot;: if lastCset[1] &lt; curFunc.start or lastCset[1] &gt; curBB.end: # 判断cset指令是否在当前函数内 continue workCset(uc, bv, lastCset, instruction, (curBB.start, curBB.end), (0xf4c0, 0x591d0), white=[curBB.start]) nextWork = None except Exception as e: # 捕获预期外的异常 print(&quot;[{}] Error: {}&quot;.format( hex(uc.reg_read(UC_ARM64_REG_PC)), e)) workCsel函数workCset函数和workCsel函数基本没什么区别，这里以workCsel函数为例 1def workCsel(uc: Uc, bv: BinaryView, lastCsel: list, Brinstruction: list, emuRange: Tuple, textSecRange: Tuple, white: list = [], depth: int = 0) 我们需要上一条csel指令的信息，br指令的信息，模拟执行的区间，text段的区间位置和一个白名单（后面会讲这个白名单有什么用），为了方便调试还记录当前搜索的深度depth 12345Hook = uc.hook_add(UC_HOOK_CODE, avoidBlHook, {&quot;bv&quot;: bv, &quot;white&quot;: white}) print(lastCsel) print(&quot;[+] work at {} -- {}&quot;.format(hex(emuRange[0]), hex(emuRange[1]))) print(&quot;[+] cur search depth: {}&quot;.format(depth)) 我们要先添加一个code hook，codehook是unicorn的一种机制，hook添加的回调函数会在每条指令执行前执行，我们可以用这个机制跳过一些我们不想进入的函数，hook的第三个参数是一些传递给回调的变量 avoidBLHook的实现模拟的过程肯定会遇到一些跳转指令，bl就是arm中的call指令，跳转后ret会恢复pc的值，我们可以假设bl跳过去的函数不对我们的计算产生影响，而且如果跳进系统调用里uc就无法模拟了（因为是导入函数），所以遇到bl我们就把pc+4（arm64指令的长度）跳过这条指令然后是我们在往前追溯的过程中，可能会遇到当前基本块是由某个条件跳转到达的，因为我们无法保证顺着模拟的时候一定满足跳转条件，具体情况如下图所以我们要把遇到的基本块的开头加入白名单，在bl时跳过不在白名单中的地址，在b.cond时强制跳转到在白名单中的地址 12345678910111213141516171819202122232425262728def avoidBlHook(uc: Uc, address, size, user_data): bv = user_data.get(&quot;bv&quot;) white = user_data.get(&quot;white&quot;) # 把传过来的白名单和bv取出来 assert isinstance(bv, BinaryView) # 不这样写编辑器不识别bv的类型 code = bv.get_disassembly(address) # 获取当前地址的指令 if &quot;bl&quot; in code: for tar in white: if hex(tar) in code: if debugMode: print(&quot;enter {}&quot;.format(hex(tar))) break else: # 遍历白名单，如果遍历完都没有break，说明当前指令要被跳过 if debugMode: print(&quot;[not {}] [skip {}] {}&quot;.format( list(map(hex, white)), hex(address), code)) uc.reg_write(UC_ARM64_REG_PC, address+4) # 把pc设置为pc+4 if &quot;b.&quot; in code: for tar in white: if hex(tar) in code: if debugMode: print(&quot;force jmp {}&quot;.format(hex(tar))) # 这里如果遇到了白名单中的地址，直接把pc覆写成这个地址，即强制跳转 uc.reg_write(UC_ARM64_REG_PC, tar) break else: if debugMode: print(&quot;skip unknown jmp target&quot;) uc.reg_write(UC_ARM64_REG_PC, address+4) # 否则就跳过（不然也可能会被导到不知道哪里去） 收集信息我们在收集信息的时候重置栈状态（为了确保每次开始执行时栈都是干净的没有上次的脏数据） 12345678910111213141516171819202122232425262728def save_regisers(uc: Uc): regs = {} for reg in ARM64_REG_MAP: if ARM64_REG_MAP[reg] is not None: regs[reg] = uc.reg_read(ARM64_REG_MAP[reg]) # 读取所有寄存器信息并储存 return regsdef emuToGetRegInitState(uc: Uc, start: int, end: int) -&gt; dict: stack_top = STACK_BASE + STACK_SIZE - 0x100 uc.reg_write(UC_ARM64_REG_SP, stack_top) # 设置栈指针 # 根据arm调用约定，初始的栈顶必须写8个0x00 uc.mem_write(stack_top, b&quot;\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00&quot;) uc.emu_start(start, end) # 开启模拟 return save_regisers(uc)regs = emuToGetRegInitState(uc, emuRange[0], lastCsel[1]) # 获取进入CSEL之前的寄存器状态 # 然后因为CSEL的赋值选择第一个还是第二个参数是和cond对应的，br跳转必然前面跟一个add类的计算指令来计算地址 # 也就是说，这里提供了两条指令的空间来让我们构造一对互补的b.cond ，于是就规避了可能误修改业务相关指令的麻烦 destReg = lastCsel[0][2].text trueReg = lastCsel[0][5].text falseReg = lastCsel[0][8].text cond = lastCsel[0][11].text brTarget = Brinstruction[0][2].text curAddr = Brinstruction[1] # 这里搜集一些指令的参数信息，具体为什么这么写因为bn的指令token就是这么约定的 执行模拟以获取跳转地址我们恢复寄存器状态，开始第一次执行 123456789101112131415161718def emuToGetJumpReg(uc: Uc, start: int, end: int, brTarget: str) -&gt; int: uc.emu_start(start, end) return uc.reg_read(ARM64_REG_MAP[brTarget])def recover_regisers(uc: Uc, regs: dict): for reg in ARM64_REG_MAP: if ARM64_REG_MAP[reg] is not None: uc.reg_write(ARM64_REG_MAP[reg], regs[reg]) # print(&quot;{} = {}&quot;.format(reg, hex(regs[reg])))recover_regisers(uc, regs)if trueReg == &quot;xzr&quot; or trueReg == &quot;wzr&quot;: # 这个主要是处理uc不能读取arm的0寄存器的问题，我们要手动赋0 uc.reg_write(ARM64_REG_MAP[destReg], 0)else: uc.reg_write(ARM64_REG_MAP[destReg], regs[trueReg]) # print(regs[trueReg])trueDest = emuToGetJumpReg(uc, lastCsel[1]+4, curAddr, brTarget) 然后再次恢复寄存器状态，开始第二次执行 123456789101112131415recover_regisers(uc, regs)if falseReg == &quot;xzr&quot; or falseReg == &quot;wzr&quot;: uc.reg_write(ARM64_REG_MAP[destReg], 0)else: uc.reg_write(ARM64_REG_MAP[destReg], regs[falseReg])# print(regs[falseReg])falseDest = emuToGetJumpReg( uc, lastCsel[1]+4, curAddr, brTarget)if debugMode: print(&quot;[+] if ture then to:{} \\n else to:{}&quot;.format( hex(trueDest), hex(falseDest)))# print(&quot;[asm to replace]{}\\n[asm to replace]{}&quot;.format(bv.get_disassembly(# curAddr-4), bv.get_disassembly(curAddr)))uc.hook_del(Hook) # 在工作都做完后记得要解除hook，不然重复hook就挂了 处理错误地址当然模拟不可能那么快就做完，首先是校验地址是否正确 123456789101112131415161718if not (textSecRange[0] &lt;= trueDest &lt;= textSecRange[1]) or not (textSecRange[0] &lt;= falseDest &lt;= textSecRange[1]): # 检查地址是否在text段范围内 print(&quot;[x] wrong dest occured,try to fix&quot;) # 如果没有前驱基本块，说明此时处于函数的第一个基本块，要去找该函数的交叉引用 if len(bv.get_basic_blocks_at(emuRange[0])[0].incoming_edges) == 0: ref = list(bv.get_code_refs(emuRange[0])) print(&quot;{} ref {}&quot;.format(hex(emuRange[0]), ref)) preBB = bv.get_basic_blocks_at(ref[0].address)[ 0] # 获取交叉引用所处的基本块 white.append(preBB.start) # 把基本块开头加入跳转白名单 else: preBB = bv.get_basic_blocks_at( emuRange[0])[0].incoming_edges[0].source # 如果有前驱基本块，就获取它 white.append(preBB.start) # 把基本块开头加入跳转白名单 print(&quot;[x] try find missing arg at {}&quot;.format(preBB)) workCsel(uc, bv, lastCsel, Brinstruction, (preBB.start, emuRange[1]), textSecRange, white=white, depth=depth+1) # 递归向前追溯 else: # 如果正常就组装指令并patch buildOpAndPatch(bv, cond, trueDest, falseDest, curAddr) 捕捉非法地址读写除了错误地址外也可能模拟出现非法地址读写，我们捕获UcError并做和上文同样的处理 1234567891011121314151617181920except UcError as e: # 捕获到错误地址读写或其他错误行为 uc.hook_del(Hook) if e.errno == UC_ERR_READ_UNMAPPED or e.errno == UC_ERR_WRITE_UNMAPPED: print(&quot;[x] unmapped R/W occured,try to fix [{} {}]&quot;.format(hex( uc.reg_read(UC_ARM64_REG_PC)), bv.get_disassembly(uc.reg_read(UC_ARM64_REG_PC)))) else: print(&quot;[!!!] unhanddle error: {} [{} {}]&quot;.format(e, hex( uc.reg_read(UC_ARM64_REG_PC)), bv.get_disassembly(uc.reg_read(UC_ARM64_REG_PC)))) if len(bv.get_basic_blocks_at(emuRange[0])[0].incoming_edges) == 0: ref = list(bv.get_code_refs(emuRange[0])) print(&quot;{} ref {}&quot;.format(hex(emuRange[0]), ref)) preBB = bv.get_basic_blocks_at(ref[0].address)[0] white.append(preBB.start) else: preBB = bv.get_basic_blocks_at( emuRange[0])[0].incoming_edges[0].source white.append(preBB.start) print(&quot;[x] try find missing arg at {}&quot;.format(preBB)) workCsel(uc, bv, lastCsel, Brinstruction, (preBB.start, emuRange[1]), textSecRange, white=white, depth=depth+1) 完整的workCsel函数1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889def workCsel(uc: Uc, bv: BinaryView, lastCsel: list, Brinstruction: list, emuRange: Tuple, textSecRange: Tuple, white: list = [], depth: int = 0): try: Hook = uc.hook_add(UC_HOOK_CODE, avoidBlHook, {&quot;bv&quot;: bv, &quot;white&quot;: white}) print(lastCsel) print(&quot;[+] work at {} -- {}&quot;.format(hex(emuRange[0]), hex(emuRange[1]))) print(&quot;[+] cur search depth: {}&quot;.format(depth)) regs = emuToGetRegInitState(uc, emuRange[0], lastCsel[1]) # 获取进入CSEL之前的寄存器状态 # 然后因为CSEL的赋值选择第一个还是第二个参数是和cond对应的，br跳转必然前面跟一个add类的计算指令来计算地址 # 也就是说，这里提供了两条指令的空间来让我们构造一对互补的b.cond ，于是就规避了可能误修改业务相关指令的麻烦 destReg = lastCsel[0][2].text trueReg = lastCsel[0][5].text falseReg = lastCsel[0][8].text cond = lastCsel[0][11].text brTarget = Brinstruction[0][2].text curAddr = Brinstruction[1] # 这里搜集一些指令的参数信息，具体为什么这么写因为bn的指令token就是这么约定的 # print(regs) if debugMode: print(destReg, trueReg, falseReg, cond, brTarget) # hk = uc.hook_add(UC_HOOK_CODE, codeHook, {&quot;bv&quot;: bv}) recover_regisers(uc, regs) if trueReg == &quot;xzr&quot; or trueReg == &quot;wzr&quot;: # 这个主要是处理uc不能读取arm的0寄存器的问题，我们要手动赋0 uc.reg_write(ARM64_REG_MAP[destReg], 0) else: uc.reg_write(ARM64_REG_MAP[destReg], regs[trueReg]) # print(regs[trueReg]) trueDest = emuToGetJumpReg( uc, lastCsel[1]+4, curAddr, brTarget) recover_regisers(uc, regs) if falseReg == &quot;xzr&quot; or falseReg == &quot;wzr&quot;: uc.reg_write(ARM64_REG_MAP[destReg], 0) else: uc.reg_write(ARM64_REG_MAP[destReg], regs[falseReg]) # print(regs[falseReg]) falseDest = emuToGetJumpReg( uc, lastCsel[1]+4, curAddr, brTarget) if debugMode: print(&quot;[+] if ture then to:{} \\n else to:{}&quot;.format( hex(trueDest), hex(falseDest))) # print(&quot;[asm to replace]{}\\n[asm to replace]{}&quot;.format(bv.get_disassembly( # curAddr-4), bv.get_disassembly(curAddr))) uc.hook_del(Hook) if not (textSecRange[0] &lt;= trueDest &lt;= textSecRange[1]) or not (textSecRange[0] &lt;= falseDest &lt;= textSecRange[1]): # 检查地址是否在text段范围内 print(&quot;[x] wrong dest occured,try to fix&quot;) # 如果没有前驱基本块，说明此时处于函数的第一个基本块，要去找该函数的交叉引用 if len(bv.get_basic_blocks_at(emuRange[0])[0].incoming_edges) == 0: ref = list(bv.get_code_refs(emuRange[0])) print(&quot;{} ref {}&quot;.format(hex(emuRange[0]), ref)) preBB = bv.get_basic_blocks_at(ref[0].address)[ 0] # 获取交叉引用所处的基本块 white.append(preBB.start) # 把基本块开头加入跳转白名单 else: preBB = bv.get_basic_blocks_at( emuRange[0])[0].incoming_edges[0].source # 如果有前驱基本块，就获取它 white.append(preBB.start) # 把基本块开头加入跳转白名单 print(&quot;[x] try find missing arg at {}&quot;.format(preBB)) workCsel(uc, bv, lastCsel, Brinstruction, (preBB.start, emuRange[1]), textSecRange, white=white, depth=depth+1) else: # 如果正常就组装指令并patch buildOpAndPatch(bv, cond, trueDest, falseDest, curAddr) except UcError as e: # 捕获到错误地址读写或其他错误行为 uc.hook_del(Hook) if e.errno == UC_ERR_READ_UNMAPPED or e.errno == UC_ERR_WRITE_UNMAPPED: print(&quot;[x] unmapped R/W occured,try to fix [{} {}]&quot;.format(hex( uc.reg_read(UC_ARM64_REG_PC)), bv.get_disassembly(uc.reg_read(UC_ARM64_REG_PC)))) else: print(&quot;[!!!] unhanddle error: {} [{} {}]&quot;.format(e, hex( uc.reg_read(UC_ARM64_REG_PC)), bv.get_disassembly(uc.reg_read(UC_ARM64_REG_PC)))) if len(bv.get_basic_blocks_at(emuRange[0])[0].incoming_edges) == 0: ref = list(bv.get_code_refs(emuRange[0])) print(&quot;{} ref {}&quot;.format(hex(emuRange[0]), ref)) preBB = bv.get_basic_blocks_at(ref[0].address)[0] white.append(preBB.start) else: preBB = bv.get_basic_blocks_at( emuRange[0])[0].incoming_edges[0].source white.append(preBB.start) print(&quot;[x] try find missing arg at {}&quot;.format(preBB)) workCsel(uc, bv, lastCsel, Brinstruction, (preBB.start, emuRange[1]), textSecRange, white=white, depth=depth+1) 组装指令12345678910def buildOpAndPatch(bv: binaryview, cond: str, trueDest: int, falseDest: int, curAddr: int): trueJmp = &quot;b.{} #{}&quot;.format(cond, hex(trueDest-(curAddr-4))) falseJmp = &quot;b.{} #{}&quot;.format(ARM64_CONDS[cond], hex(falseDest-curAddr)) print(&quot;[asm gen]{} -&gt; {}&quot;.format(bv.get_disassembly(curAddr-4), trueJmp)) print(&quot;[asm gen]{} -&gt; {}&quot;.format(bv.get_disassembly(curAddr), falseJmp)) # 使用bn提供的指令转换api获得机械码 bv.write(curAddr-4, Architecture['aarch64'].assemble(trueJmp)) bv.write(curAddr, Architecture['aarch64'].assemble(falseJmp)) print(&quot;===================================================&quot;) 完整代码cest的处理和csel类似，只是把从源寄存器赋值改为了赋值为0/1，这里就不多赘述，直接给出完整的脚本代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357from binaryninja import *from unicorn import *from unicorn.arm64_const import *CODE_BASE = 0x0CODE_SIZE = 0x1200000+0x1000STACK_BASE = 0x30000000STACK_SIZE = 0x8000ARM64_REG_MAP = { 'x0': UC_ARM64_REG_X0, 'x1': UC_ARM64_REG_X1, 'x2': UC_ARM64_REG_X2, 'x3': UC_ARM64_REG_X3, 'x4': UC_ARM64_REG_X4, 'x5': UC_ARM64_REG_X5, 'x6': UC_ARM64_REG_X6, 'x7': UC_ARM64_REG_X7, 'x8': UC_ARM64_REG_X8, 'x9': UC_ARM64_REG_X9, 'x10': UC_ARM64_REG_X10, 'x11': UC_ARM64_REG_X11, 'x12': UC_ARM64_REG_X12, 'x13': UC_ARM64_REG_X13, 'x14': UC_ARM64_REG_X14, 'x15': UC_ARM64_REG_X15, 'x16': UC_ARM64_REG_X16, 'x17': UC_ARM64_REG_X17, 'x18': UC_ARM64_REG_X18, 'x19': UC_ARM64_REG_X19, 'x20': UC_ARM64_REG_X20, 'x21': UC_ARM64_REG_X21, 'x22': UC_ARM64_REG_X22, 'x23': UC_ARM64_REG_X23, 'x24': UC_ARM64_REG_X24, 'x25': UC_ARM64_REG_X25, 'x26': UC_ARM64_REG_X26, 'x27': UC_ARM64_REG_X27, 'x28': UC_ARM64_REG_X28, 'x29': UC_ARM64_REG_X29, 'x30': UC_ARM64_REG_X30, 'sp': UC_ARM64_REG_SP, 'w0': UC_ARM64_REG_X0, 'w1': UC_ARM64_REG_X1, 'w2': UC_ARM64_REG_X2, 'w3': UC_ARM64_REG_X3, 'w4': UC_ARM64_REG_X4, 'w5': UC_ARM64_REG_X5, 'w6': UC_ARM64_REG_X6, 'w7': UC_ARM64_REG_X7, 'w8': UC_ARM64_REG_X8, 'w9': UC_ARM64_REG_X9, 'w10': UC_ARM64_REG_X10, 'w11': UC_ARM64_REG_X11, 'w12': UC_ARM64_REG_X12, 'w13': UC_ARM64_REG_X13, 'w14': UC_ARM64_REG_X14, 'w15': UC_ARM64_REG_X15, 'w16': UC_ARM64_REG_X16, 'w17': UC_ARM64_REG_X17, 'w18': UC_ARM64_REG_X18, 'w19': UC_ARM64_REG_X19, 'w20': UC_ARM64_REG_X20, 'w21': UC_ARM64_REG_X21, 'w22': UC_ARM64_REG_X22, 'w23': UC_ARM64_REG_X23, 'w24': UC_ARM64_REG_X24, 'w25': UC_ARM64_REG_X25, 'w26': UC_ARM64_REG_X26, 'w27': UC_ARM64_REG_X27, 'w28': UC_ARM64_REG_X28, 'wzr': None, 'xzr': None,}# 每个条件码逻辑上对应的互补的条件ARM64_CONDS = { 'eq': 'ne', 'ne': 'eq', 'hs': 'lo', 'lo': 'hs', 'mi': 'pl', 'pl': 'mi', 'vs': 'vc', 'vc': 'vs', 'hi': 'ls', 'ls': 'hi', 'ge': 'lt', 'lt': 'ge', 'gt': 'le', 'le': 'gt', 'cs': 'cc', 'cc': 'cs',}def save_regisers(uc: Uc): regs = {} for reg in ARM64_REG_MAP: if ARM64_REG_MAP[reg] is not None: regs[reg] = uc.reg_read(ARM64_REG_MAP[reg]) # 读取所有寄存器信息并储存 return regsdef codeHook(uc: Uc, address, size, user_data): bv = user_data.get(&quot;bv&quot;) code = bv.get_disassembly(address) assert isinstance(bv, BinaryView) if address &gt;= 0x021e5c and address &lt;= 0x21e74: print(&quot;[{}]{}&quot;.format( hex(address), code)) if address &gt;= 0x000355f0 and address &lt;= 0x00035668: print(&quot;[{}]{}&quot;.format( hex(address), code))def recover_regisers(uc: Uc, regs: dict): for reg in ARM64_REG_MAP: if ARM64_REG_MAP[reg] is not None: uc.reg_write(ARM64_REG_MAP[reg], regs[reg]) # print(&quot;{} = {}&quot;.format(reg, hex(regs[reg])))def emuToGetRegInitState(uc: Uc, start: int, end: int) -&gt; dict: stack_top = STACK_BASE + STACK_SIZE - 0x100 uc.reg_write(UC_ARM64_REG_SP, stack_top) # 设置栈指针 # 根据arm调用约定，初始的栈顶必须写8个0x00 uc.mem_write(stack_top, b&quot;\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00&quot;) uc.emu_start(start, end) # 开启模拟 return save_regisers(uc)def emuToGetJumpReg(uc: Uc, start: int, end: int, brTarget: str) -&gt; int: uc.emu_start(start, end) return uc.reg_read(ARM64_REG_MAP[brTarget])debugMode = 1def avoidBlHook(uc: Uc, address, size, user_data): bv = user_data.get(&quot;bv&quot;) white = user_data.get(&quot;white&quot;) # 把传过来的白名单和bv取出来 assert isinstance(bv, BinaryView) # 不这样写编辑器不识别bv的类型 code = bv.get_disassembly(address) # 获取当前地址的指令 if &quot;bl&quot; in code: for tar in white: if hex(tar) in code: if debugMode: print(&quot;enter {}&quot;.format(hex(tar))) break else: # 遍历白名单，如果遍历完都没有break，说明当前指令要被跳过 if debugMode: print(&quot;[not {}] [skip {}] {}&quot;.format( list(map(hex, white)), hex(address), code)) uc.reg_write(UC_ARM64_REG_PC, address+4) # 把pc设置为pc+4 if &quot;b.&quot; in code: for tar in white: if hex(tar) in code: if debugMode: print(&quot;force jmp {}&quot;.format(hex(tar))) # 这里如果遇到了白名单中的地址，直接把pc覆写成这个地址，即强制跳转 uc.reg_write(UC_ARM64_REG_PC, tar) break else: if debugMode: print(&quot;skip unknown jmp target&quot;) uc.reg_write(UC_ARM64_REG_PC, address+4) # 否则就跳过（不然也可能会被导到不知道哪里去） # input()def buildOpAndPatch(bv: binaryview, cond: str, trueDest: int, falseDest: int, curAddr: int): trueJmp = &quot;b.{} #{}&quot;.format(cond, hex(trueDest-(curAddr-4))) falseJmp = &quot;b.{} #{}&quot;.format(ARM64_CONDS[cond], hex(falseDest-curAddr)) print(&quot;[asm gen]{} -&gt; {}&quot;.format(bv.get_disassembly(curAddr-4), trueJmp)) print(&quot;[asm gen]{} -&gt; {}&quot;.format(bv.get_disassembly(curAddr), falseJmp)) bv.write(curAddr-4, Architecture['aarch64'].assemble(trueJmp)) bv.write(curAddr, Architecture['aarch64'].assemble(falseJmp)) print(&quot;===================================================&quot;)def workCsel(uc: Uc, bv: BinaryView, lastCsel: list, Brinstruction: list, emuRange: Tuple, textSecRange: Tuple, white: list = [], depth: int = 0): try: Hook = uc.hook_add(UC_HOOK_CODE, avoidBlHook, {&quot;bv&quot;: bv, &quot;white&quot;: white}) print(lastCsel) print(&quot;[+] work at {} -- {}&quot;.format(hex(emuRange[0]), hex(emuRange[1]))) print(&quot;[+] cur search depth: {}&quot;.format(depth)) regs = emuToGetRegInitState(uc, emuRange[0], lastCsel[1]) # 获取进入CSEL之前的寄存器状态 # 然后因为CSEL的赋值选择第一个还是第二个参数是和cond对应的，br跳转必然前面跟一个add类的计算指令来计算地址 # 也就是说，这里提供了两条指令的空间来让我们构造一对互补的b.cond ，于是就规避了可能误修改业务相关指令的麻烦 destReg = lastCsel[0][2].text trueReg = lastCsel[0][5].text falseReg = lastCsel[0][8].text cond = lastCsel[0][11].text brTarget = Brinstruction[0][2].text curAddr = Brinstruction[1] # 这里搜集一些指令的参数信息，具体为什么这么写因为bn的指令token就是这么约定的 # print(regs) if debugMode: print(destReg, trueReg, falseReg, cond, brTarget) # hk = uc.hook_add(UC_HOOK_CODE, codeHook, {&quot;bv&quot;: bv}) recover_regisers(uc, regs) if trueReg == &quot;xzr&quot; or trueReg == &quot;wzr&quot;: # 这个主要是处理uc不能读取arm的0寄存器的问题，我们要手动赋0 uc.reg_write(ARM64_REG_MAP[destReg], 0) else: uc.reg_write(ARM64_REG_MAP[destReg], regs[trueReg]) # print(regs[trueReg]) trueDest = emuToGetJumpReg( uc, lastCsel[1]+4, curAddr, brTarget) recover_regisers(uc, regs) if falseReg == &quot;xzr&quot; or falseReg == &quot;wzr&quot;: uc.reg_write(ARM64_REG_MAP[destReg], 0) else: uc.reg_write(ARM64_REG_MAP[destReg], regs[falseReg]) # print(regs[falseReg]) falseDest = emuToGetJumpReg( uc, lastCsel[1]+4, curAddr, brTarget) if debugMode: print(&quot;[+] if ture then to:{} \\n else to:{}&quot;.format( hex(trueDest), hex(falseDest))) # print(&quot;[asm to replace]{}\\n[asm to replace]{}&quot;.format(bv.get_disassembly( # curAddr-4), bv.get_disassembly(curAddr))) uc.hook_del(Hook) if not (textSecRange[0] &lt;= trueDest &lt;= textSecRange[1]) or not (textSecRange[0] &lt;= falseDest &lt;= textSecRange[1]): # 检查地址是否在text段范围内 print(&quot;[x] wrong dest occured,try to fix&quot;) # 如果没有前驱基本块，说明此时处于函数的第一个基本块，要去找该函数的交叉引用 if len(bv.get_basic_blocks_at(emuRange[0])[0].incoming_edges) == 0: ref = list(bv.get_code_refs(emuRange[0])) print(&quot;{} ref {}&quot;.format(hex(emuRange[0]), ref)) preBB = bv.get_basic_blocks_at(ref[0].address)[ 0] # 获取交叉引用所处的基本块 white.append(preBB.start) # 把基本块开头加入跳转白名单 else: preBB = bv.get_basic_blocks_at( emuRange[0])[0].incoming_edges[0].source # 如果有前驱基本块，就获取它 white.append(preBB.start) # 把基本块开头加入跳转白名单 print(&quot;[x] try find missing arg at {}&quot;.format(preBB)) workCsel(uc, bv, lastCsel, Brinstruction, (preBB.start, emuRange[1]), textSecRange, white=white, depth=depth+1) else: # 如果正常就组装指令并patch buildOpAndPatch(bv, cond, trueDest, falseDest, curAddr) except UcError as e: # 捕获到错误地址读写或其他错误行为 uc.hook_del(Hook) if e.errno == UC_ERR_READ_UNMAPPED or e.errno == UC_ERR_WRITE_UNMAPPED: print(&quot;[x] unmapped R/W occured,try to fix [{} {}]&quot;.format(hex( uc.reg_read(UC_ARM64_REG_PC)), bv.get_disassembly(uc.reg_read(UC_ARM64_REG_PC)))) else: print(&quot;[!!!] unhanddle error: {} [{} {}]&quot;.format(e, hex( uc.reg_read(UC_ARM64_REG_PC)), bv.get_disassembly(uc.reg_read(UC_ARM64_REG_PC)))) if len(bv.get_basic_blocks_at(emuRange[0])[0].incoming_edges) == 0: ref = list(bv.get_code_refs(emuRange[0])) print(&quot;{} ref {}&quot;.format(hex(emuRange[0]), ref)) preBB = bv.get_basic_blocks_at(ref[0].address)[0] white.append(preBB.start) else: preBB = bv.get_basic_blocks_at( emuRange[0])[0].incoming_edges[0].source white.append(preBB.start) print(&quot;[x] try find missing arg at {}&quot;.format(preBB)) workCsel(uc, bv, lastCsel, Brinstruction, (preBB.start, emuRange[1]), textSecRange, white=white, depth=depth+1)def workCset(uc: Uc, bv: BinaryView, lastCset: list, Brinstruction: list, emuRange: Tuple, textSecRange: Tuple, white: list = [], depth: int = 0): try: Hook = uc.hook_add(UC_HOOK_CODE, avoidBlHook, {&quot;bv&quot;: bv, &quot;white&quot;: white, &quot;end&quot;: emuRange[1]}) print(lastCset) print(&quot;[+] work at {} -- {}&quot;.format(hex(emuRange[0]), hex(emuRange[1]))) print(&quot;[+] cur search depth: {}&quot;.format(depth)) regs = emuToGetRegInitState(uc, emuRange[0], lastCset[1]) destReg = lastCset[0][2].text cond = lastCset[0][5].text brTarget = Brinstruction[0][2].text curAddr = Brinstruction[1] if debugMode: print(destReg, cond, brTarget) recover_regisers(uc, regs) uc.reg_write(ARM64_REG_MAP[destReg], 1) trueDest = emuToGetJumpReg( uc, lastCset[1]+4, curAddr, brTarget) recover_regisers(uc, regs) uc.reg_write(ARM64_REG_MAP[destReg], 0) falseDest = emuToGetJumpReg( uc, lastCset[1]+4, curAddr, brTarget) if debugMode: print(&quot;[+] if ture then to:{} \\n else to:{}&quot;.format( hex(trueDest), hex(falseDest))) # print(&quot;[asm to replace]{}\\n[asm to replace]{}&quot;.format(bv.get_disassembly( # curAddr-4), bv.get_disassembly(curAddr))) uc.hook_del(Hook) if not (textSecRange[0] &lt;= trueDest &lt;= textSecRange[1]) or not (textSecRange[0] &lt;= falseDest &lt;= textSecRange[1]): print(&quot;[x] wrong dest occured,try to fix&quot;) print(&quot;incoming edges: {}&quot;.format( bv.get_basic_blocks_at(emuRange[0])[0].incoming_edges)) if len(bv.get_basic_blocks_at(emuRange[0])[0].incoming_edges) == 0: ref = list(bv.get_code_refs(emuRange[0])) print(&quot;{} ref {}&quot;.format(hex(emuRange[0]), ref)) preBB = bv.get_basic_blocks_at(ref[0].address)[0] white.append(preBB.start) else: preBB = bv.get_basic_blocks_at( emuRange[0])[0].incoming_edges[0].source white.append(preBB.start) print(&quot;[x] try find missing arg at {}&quot;.format(preBB)) workCset(uc, bv, lastCset, Brinstruction, (preBB.start, emuRange[1]), textSecRange, white=white, depth=depth+1) else: buildOpAndPatch(bv, cond, trueDest, falseDest, curAddr) except UcError as e: uc.hook_del(Hook) if e.errno == UC_ERR_READ_UNMAPPED or e.errno == UC_ERR_WRITE_UNMAPPED: print(&quot;[x] unmapped R/W occured,try to fix [{} {}]&quot;.format(hex( uc.reg_read(UC_ARM64_REG_PC)), bv.get_disassembly(uc.reg_read(UC_ARM64_REG_PC)))) else: print(&quot;[!!!] unhanddle error: {} [{} {}]&quot;.format(e, hex( uc.reg_read(UC_ARM64_REG_PC)), bv.get_disassembly(uc.reg_read(UC_ARM64_REG_PC)))) if len(bv.get_basic_blocks_at(emuRange[0])[0].incoming_edges) == 0: ref = list(bv.get_code_refs(emuRange[0])) print(&quot;{} ref {}&quot;.format(hex(emuRange[0]), ref)) preBB = bv.get_basic_blocks_at(ref[0].address)[0] white.append(preBB.start) else: preBB = bv.get_basic_blocks_at( emuRange[0])[0].incoming_edges[0].source white.append(preBB.start) print(&quot;[x] try find missing arg at {}&quot;.format(preBB)) workCset(uc, bv, lastCset, Brinstruction, (preBB.start, emuRange[1]), textSecRange, white=white, depth=depth+1)def solve(bv: BinaryView): uc = Uc(UC_ARCH_ARM64, UC_MODE_ARM) uc.mem_map(CODE_BASE, CODE_SIZE, UC_PROT_ALL) # 分配text段内存 uc.mem_map(STACK_BASE, STACK_SIZE, UC_PROT_ALL) # 分配栈内存 for segment in bv.segments: # 用bn API遍历所有段 if segment.readable: start = segment.start end = segment.end size = end-start print(&quot;[+] Mapping segment: [{}]&quot;.format(hex(segment.data_length))) content = bv.read(start, size) # 读取段数据 uc.mem_write(start, content) # 写入uc模拟器 lastCsel = None lastCset = None nextWork = None # 记录最后遇到的是csel还是cset for instruction in bv.instructions: # 遍历所有指令 curAddr = instruction[1] # print(curAddr) if instruction[0][0].text == &quot;csel&quot;: lastCsel = instruction nextWork = &quot;csel&quot; if instruction[0][0].text == &quot;cset&quot;: lastCset = instruction nextWork = &quot;cset&quot; if instruction[0][0].text == &quot;br&quot;: tags = bv.get_functions_containing(curAddr)[0].tags # 获取当前函数的所有tag curTag = None for tag in tags: if tag[1] == curAddr: # 寻找br指令上的tag curTag = tag[2] break # 查看是否为间接控制流 if curTag is None or not (curTag.type.name == &quot;Unresolved Indirect Control Flow&quot;): continue # print(hex(curAddr)) curBB = bv.get_basic_blocks_at(curAddr)[0] # 获取当前指令所在的基本块 curFunc = bv.get_functions_containing(curAddr)[0] # 获取当前指令所在的函数 # print(curBB) if nextWork is None: continue try: if nextWork == &quot;csel&quot;: if lastCsel[1] &lt; curFunc.start or lastCsel[1] &gt; curBB.end: # 判断csel指令是否在当前函数内 continue workCsel(uc, bv, lastCsel, instruction, (curBB.start, curBB.end), (0xf4c0, 0x591d0), white=[curBB.start]) nextWork = None elif nextWork == &quot;cset&quot;: if lastCset[1] &lt; curFunc.start or lastCset[1] &gt; curBB.end: # 判断cset指令是否在当前函数内 continue workCset(uc, bv, lastCset, instruction, (curBB.start, curBB.end), (0xf4c0, 0x591d0), white=[curBB.start]) nextWork = None except Exception as e: # 捕获预期外的异常 print(&quot;[{}] Error: {}&quot;.format( hex(uc.reg_read(UC_ARM64_REG_PC)), e))solve(bv) 直接选择bn的run script files执行，看到修复效果还是很好的因为bn是动态分析的，所以要多次运行脚本才能修复每次新识别的指令 鸣谢感谢 @l4n 师傅的文章对本篇文章的启发 一种基于unicorn的寄存器间接跳转混淆去除方式同样感谢 @Itlly 师傅 和 @Jerem1ah 师傅在脚本开发过程中提供的建议","link":"/ctf/auto-re-dev/unicornSolveCselCset/"},{"title":"安卓八股","text":"安卓四大组件Activity负责创建页面和相关组件，用户和app的交互门户Activity有四种启动模式Standard,SingleTop,SingleTask,SingleInstance，分别对应AMS对Activity栈的不同管理方式， 启动Activity通过Intent对象，Intent中设置包名类名等数据然后调用startActivity方法，用来实现Activity跳转或者生成新ActivityActivity启动后依次调用onCreate,onStart,onResume回调 Serivce后台逻辑线程，通常用于处理耗时任务，在Activity销毁后仍可以继续运行 BroadcastReceiver监听系统广播信号，通过注册IIntentReciver到AMS后开启监听，AMS收到信号匹配回调列表，然后触发onReceive回调 如果配置在AndroidManifest中，当接收到信号时会先拉起进程（如果进程此时还未启动） ContentProvider在AndroidManifest中设置的一套接口，用于向别的App提供数据假设应用A需要向应用B请求数据应用A先通过向AMS请求应用B的Binder句柄，AMS从B获取句柄后再传给AA在获取句柄后，和B直接进行通信，数据传输并不直接使用Binder，而是B会初始化一块共享内存，将结果写入在共享内存中，然后这个内存的FD会被传给A，A直接从这个内存读结果 Binder通信Binder是安卓系统中与系统服务通信的方式，Binder通过一种称为Parcel的二进制数据包传递数据，比如KeyStore服务中的证书句柄就是序列化为Pracel后传递的 App启动流程 Launcher服务通过binder向AMS发送startActivity请求 AMS向Zygote创建新进程的请求，这里通过Socket通信（可能是历史遗留原因） Zygote通过fork复制自身产生一个新进程 调用ActivityThread.main()，主线程启动 由AMS发送Binder信号初始化Application，然后再初始化MainActivity 调用onCreate,onStart,onResume回调 TEE机制安卓中的可信计算环境由KeyStore服务提供，负责管理所有和系统根证书相关的服务，其中私钥经过设计绝无可能从TEE环境外读取，用户通过Binder句柄来调用证书进行通信加密等操作 selinux的权限管理机制selinux的核心机制是安全上下文，其通过对系统中的用户（访问者）和资源（被访问者）打上标签的方式管理权限标签有四个部分，分别是User,Role,Type,Sensitivity对于进程来说，Type叫做域，对于文件Type是类型，selinux通过管理原类型的用户对目标类型的资源的访问策略来管理权限 设备指纹相关系统服务获取Android ID,IMEI,Apk包列表，蓝牙信息，wifi信息这些都通过系统服务获取的，也就是在java层获取的，根据安卓版本不同申请方法不同，由AndroidManifest静态申请权限，或者运行时动态向systemService申请权限 ContentProvider某些特殊机型的OS可能会通过ContentProvider提供一些设备指纹 prop主要通过getprop获取或android.os包里面的方法，一些内核层的字段信息 内核相关主要在/proc和/sys路径下的一些文件，里面可能会有一些序列号之类的,比如/proc/sys/kernel/random/boot_id","link":"/ctf/Android/android-basic/"}],"tags":[{"name":"codeforces","slug":"codeforces","link":"/tags/codeforces/"},{"name":"Makefile","slug":"Makefile","link":"/tags/Makefile/"},{"name":"Reverse","slug":"Reverse","link":"/tags/Reverse/"},{"name":"frida","slug":"frida","link":"/tags/frida/"},{"name":"XCTF","slug":"XCTF","link":"/tags/XCTF/"},{"name":"Python","slug":"Python","link":"/tags/Python/"},{"name":"selenium","slug":"selenium","link":"/tags/selenium/"},{"name":"ebpf","slug":"ebpf","link":"/tags/ebpf/"},{"name":"加密&amp;编码","slug":"加密-编码","link":"/tags/%E5%8A%A0%E5%AF%86-%E7%BC%96%E7%A0%81/"},{"name":"js","slug":"js","link":"/tags/js/"},{"name":"web-re","slug":"web-re","link":"/tags/web-re/"},{"name":"python","slug":"python","link":"/tags/python/"},{"name":"Android","slug":"Android","link":"/tags/Android/"},{"name":"go","slug":"go","link":"/tags/go/"},{"name":"web指纹","slug":"web指纹","link":"/tags/web%E6%8C%87%E7%BA%B9/"},{"name":"qbdi","slug":"qbdi","link":"/tags/qbdi/"},{"name":"BinaryNinja","slug":"BinaryNinja","link":"/tags/BinaryNinja/"}],"categories":[{"name":"Development","slug":"Development","link":"/categories/Development/"},{"name":"杂项","slug":"杂项","link":"/categories/%E6%9D%82%E9%A1%B9/"},{"name":"Reverse","slug":"Reverse","link":"/categories/Reverse/"},{"name":"ctf-test","slug":"Reverse/ctf-test","link":"/categories/Reverse/ctf-test/"},{"name":"tools-dev","slug":"Reverse/tools-dev","link":"/categories/Reverse/tools-dev/"},{"name":"ebpf","slug":"ebpf","link":"/categories/ebpf/"},{"name":"对称加密&amp;编码","slug":"Reverse/对称加密-编码","link":"/categories/Reverse/%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86-%E7%BC%96%E7%A0%81/"},{"name":"basic","slug":"Reverse/basic","link":"/categories/Reverse/basic/"},{"name":"LLVM","slug":"Reverse/LLVM","link":"/categories/Reverse/LLVM/"},{"name":"分析项目","slug":"分析项目","link":"/categories/%E5%88%86%E6%9E%90%E9%A1%B9%E7%9B%AE/"},{"name":"Android","slug":"Reverse/Android","link":"/categories/Reverse/Android/"}],"pages":[{"title":"","text":"/** * Fingerprint Pro v3.12.0 - Copyright (c) FingerprintJS, Inc, 2025 (https://fingerprint.com) */ function setTimeOutRun(n, e) { return new Promise((r) => tryRunFunc(r, n, e)); } function tryRunFunc(arg1, time, ...args) { const r = Date.now() + time; let o = 0; const i = () => { o = setTimeout(() => { Date.now() < r ? i() : arg1(...args); }, r - Date.now()); }; return (i(), () => clearTimeout(o)); } function runCallbackWhenPageFocused(callback, time_latency, ...args) { const Document = document, i = \"visibilitychange\", u = () => (Document.hidden ? s() : c()), { start: c, stop: s } = (function (n, e, r, ...Document) { let i, u = false, c = n, s = 0; const a = () => { u || i || ((s = Date.now()), (i = tryRunFunc(() => { ((u = true), r(...Document)); }, c))); }; return ( e && a(), { start: a, stop: () => { !u && i && (i(), (i = void 0), (c -= Date.now() - s)); }, } ); })(time_latency, !Document.hidden, () => { (Document.removeEventListener(i, u), callback(...args)); }); return ( Document.addEventListener(i, u), () => { (Document.removeEventListener(i, u), s()); } ); } function runCallbackWhenPageFocusedPromise(time, args) { return new Promise((r) => runCallbackWhenPageFocused(r, time, args)); } async function o(n, t) { try { return await n(); } catch (e) { return (console.error(e), t); } } function i(n, t) { return new Promise((e, r) => { let o = false; null == t || t.then( () => (o = true), () => (o = true), ); (\"function\" == typeof n ? i(Promise.resolve(), t).then(n) : n).then( (n) => { o || e(n); }, (n) => { o || r(n); }, ); }); } function addEmptyErrHandle(n) { return (n.then(void 0, () => { }), n); } async function prepareRace(aPromise, func) { let res, r, o; try { res = func().then( (n) => (r = [true, n]), (n) => (r = [false, n]), ); } catch (u) { r = [false, u]; } const i = aPromise.then( (n) => (o = [true, n]), (n) => (o = [false, n]), ); return ( await Promise.race([res, i]), () => { if (r) { if (r[0]) return r[1]; throw r[1]; } if (o) { if (o[0]) return o[1]; throw o[1]; } throw new Error(\"96375\"); } ); } function s() { let n, t; const e = new Promise((e, r) => { ((n = e), (t = r)); }); return ((e.resolve = n), (e.reject = t), e); } function a(n) { return new Promise((t, e) => { n(t, e).then( () => e(new Error(\"Action didn't call `resolve` or `reject`\")), e, ); }); } function isErr(n) { return ( n instanceof Error || (null !== n && \"object\" == typeof n && \"name\" in n) ); } function f(n, t) { let e = 0; return () => Math.random() * Math.min(t, n * Math.pow(2, e++)); } function convertToIUint8Array(n) { return n instanceof ArrayBuffer ? new Uint8Array(n) : new Uint8Array(n.buffer, n.byteOffset, n.byteLength); } function addEventListenerWrapper(Dom, type, listener, options) { return (Dom.addEventListener(type, listener, options), () => Dom.removeEventListener(type, listener, options)); } const h = \"0123456789abcdef\", p = 65535; function indexOfArrayInString(n, arr) { if (0 == arr.length || arr.length > n.length) return -1; for (let e = 0; e < n.length; e++) { let r = 0; for (let o = 0; o < arr.length; o++) { if (n[e + o] !== arr[o]) { r = 0; break; } r++; } if (r == arr.length) return e; } return -1; } function convertToUint8Array(n) { const uint8arr = new Uint8Array(n.length); for (let e = 0; e < n.length; e++) { const r = n.charCodeAt(e); if (r > 127) return new TextEncoder().encode(n); uint8arr[e] = r; } return uint8arr; } function convertToString(n) { if (\"function\" == typeof TextDecoder) { const t = new TextDecoder().decode(n); if (t) return t; } const t = convertToIUint8Array(n); return decodeURIComponent(escape(String.fromCharCode.apply(null, t))); } function countOfNotNullObj_(Arr) { return Arr.reduce((n, t) => n + (t ? 1 : 0), 0); } function E(n, t) { return (n - t + 256) % 256; } function R(n) { const t = convertToIUint8Array(n), e = Math.ceil(t.length / p), r = []; for (let o = 0; o < e; o++) { const n = o * p, e = t.slice(n, Math.min(n + p, t.length)); r.push(String.fromCharCode.apply(null, e)); } return btoa(r.join(\"\")); } function base64Encode(n) { const t = atob(n), e = t.length, r = new Uint8Array(e); for (let o = 0; o < e; o++) r[o] = t.charCodeAt(o); return r; } function I(n) { return R(n).replace(/\\+/g, \"-\").replace(/\\//g, \"_\").replace(/=+$/, \"\"); } let keyArr; function getHash(str) { return getHash_(convertToUint8Array(str)); } function getHash_(str) { const t = convertToIUint8Array(str); keyArr = keyArr || (function () { let n; const t = new Uint32Array(256); for (let e = 0; e < 256; e++) { n = e; for (let t = 0; t < 8; t++) n = 1 & n ? 3988292384 ^ (n >>> 1) : n >>> 1; t[e] = n; } return t; })(); let e = -1; for (let r = 0; r < t.length; r++) e = (e >>> 8) ^ keyArr[255 & (e ^ t[r])]; return (-1 ^ e) >>> 0; } function C(n) { return void 0 === n ? void 0 : `${n}`; } function P(n, t) { if (void 0 !== n) { if (!Array.isArray(n)) throw new TypeError( `Expected ${t} to be an array, a ${(function (n) { return \"object\" == typeof n ? n ? Object.prototype.toString.call(n) : \"null\" : typeof n; })(n)} is given`, ); return n.map(String); } } function T(n) { const t = new Uint8Array(n.length / 2); for (let e = 0; e < n.length; e += 2) t[e / 2] = parseInt(n[e] + n[e + 1], 16); return t; } function getObjectKeys(n) { if (n instanceof Array) return n.map(getObjectKeys); if (n && \"object\" == typeof n) { const t = {}; for (const e of Object.keys(n)) t[e] = getObjectKeys(n[e]); return t; } return n; } function sleep(n, t) { return new Promise((e) => setTimeout(e, n, t)); } function hasKey_then(n) { return !!n && \"function\" == typeof n.then; } function j(n, t) { try { const e = n(); hasKey_then(e) ? e.then( (n) => t(true, n), (n) => t(false, n), ) : t(true, e); } catch (e) { t(false, e); } } async function V(stage_workers, func, e = 16) { const r = Array(stage_workers.length); let o = Date.now(); for (let i = 0; i < stage_workers.length; ++i) { r[i] = func(stage_workers[i], i); const u = Date.now(); u >= o + e && ((o = u), await new Promise((n) => { const t = new MessageChannel(); ((t.port1.onmessage = () => n()), t.port2.postMessage(null)); })); } return r; } function justRunPromise(n) { return (n.then(void 0, () => { }), n); } function parseInt_(n) { return parseInt(n); } function StrToFloat(n) { return parseFloat(n); } function checkNaN(num, defaultValue) { return \"number\" == typeof num && isNaN(num) ? defaultValue : num; } function countOfNotNullObj(Arr) { return Arr.reduce((n, t) => n + (t ? 1 : 0), 0); } function H(n, t) { const e = n[0] >>> 16, r = 65535 & n[0], o = n[1] >>> 16, i = 65535 & n[1], u = t[0] >>> 16, c = 65535 & t[0], s = t[1] >>> 16; let a = 0, l = 0, f = 0, d = 0; ((d += i + (65535 & t[1])), (f += d >>> 16), (d &= 65535), (f += o + s), (l += f >>> 16), (f &= 65535), (l += r + c), (a += l >>> 16), (l &= 65535), (a += e + u), (a &= 65535), (n[0] = (a < 16) | l), (n[1] = (f < 16) | d)); } function G(n, t) { const e = n[0] >>> 16, r = 65535 & n[0], o = n[1] >>> 16, i = 65535 & n[1], u = t[0] >>> 16, c = 65535 & t[0], s = t[1] >>> 16, a = 65535 & t[1]; let l = 0, f = 0, d = 0, m = 0; ((m += i * a), (d += m >>> 16), (m &= 65535), (d += o * a), (f += d >>> 16), (d &= 65535), (d += i * s), (f += d >>> 16), (d &= 65535), (f += r * a), (l += f >>> 16), (f &= 65535), (f += o * s), (l += f >>> 16), (f &= 65535), (f += i * c), (l += f >>> 16), (f &= 65535), (l += e * a + r * s + o * c + i * u), (l &= 65535), (n[0] = (l < 16) | f), (n[1] = (d < 16) | m)); } function U(n, t) { const e = n[0]; 32 === (t %= 64) ? ((n[0] = n[1]), (n[1] = e)) : t < 32 ? ((n[0] = (e < t) | (n[1] >>> (32 - t))), (n[1] = (n[1] < t) | (e >>> (32 - t)))) : ((t -= 32), (n[0] = (n[1] < t) | (e >>> (32 - t))), (n[1] = (e < t) | (n[1] >>> (32 - t)))); } function B(n, t) { 0 !== (t %= 64) && (t < 32 ? ((n[0] = n[1] >>> (32 - t)), (n[1] = n[1] < t)) : ((n[0] = n[1] < (t - 32)), (n[1] = 0))); } function $(n, t) { ((n[0] ^= t[0]), (n[1] ^= t[1])); } const Y = [4283543511, 3981806797], X = [3301882366, 444984403]; function J(n) { const t = [0, n[0] >>> 1]; ($(n, t), G(n, Y), (t[1] = n[0] >>> 1), $(n, t), G(n, X), (t[1] = n[0] >>> 1), $(n, t)); } const z = [2277735313, 289559509], q = [1291169091, 658871167], K = [0, 5], Q = [0, 1390208809], nn = [0, 944331445]; function tn(n) { return \"function\" != typeof n; } function runStageTasks(stage, context, aArray, optimize) { const stage_workers = Object.keys(stage).filter( (n) => !(function (n, t) { for (let e = 0, r = n.length; e < r; ++e) if (n[e] === t) return true; return false; })(aArray, n), ), i = justRunPromise( V( stage_workers, (e) => (function (worker, ContextToWorker) { const e = justRunPromise( new Promise((e) => { const r = Date.now(); j(worker.bind(null, ContextToWorker), (...n) => { const t = Date.now() - r; if (!n[0]) return e(() => ({ error: n[1], duration: t })); const o = n[1]; if (tn(o)) return e(() => ({ value: o, duration: t })); e( () => new Promise((n) => { const e = Date.now(); j(o, (...r) => { const o = t + Date.now() - e; if (!r[0]) return n({ error: r[1], duration: o }); n({ value: r[1], duration: o }); }); }), ); }); }), ); return function () { return e.then((n) => n()); }; })(stage[e], context), optimize, ), ); return async function () { const n = await i, t = await V(n, (n) => justRunPromise(n()), optimize), e = await Promise.all(t), u = {}; for (let r = 0; r < stage_workers.length; ++r) u[stage_workers[r]] = e[r]; return u; }; } function do_a_then_pass_res_to_b(funcA, funcB) { const e = (n) => tn(n) ? funcB(n) : () => { const e = n(); return hasKey_then(e) ? e.then(funcB) : funcB(e); }; return (t) => { const r = funcA(t); return hasKey_then(r) ? r.then(e) : e(r); }; } function collectSomeKeys8_related_to_IE() { const n = window, t = navigator; return ( countOfNotNullObj([ \"MSCSSMatrix\" in n, \"msSetImmediate\" in n, \"msIndexedDB\" in n, \"msMaxTouchPoints\" in t, \"msPointerEnabled\" in t, ]) >= 4 ); } function collectSomeKeys9_related_to_Edge() { const n = window, t = navigator; return ( countOfNotNullObj([ \"msWriteProfilerMark\" in n, \"MSStream\" in n, \"msLaunchUri\" in t, \"msSaveBlob\" in t, ]) >= 3 && !collectSomeKeys8_related_to_IE() ); } function collectSomeKeys10_related_to_chrome() { const n = window, t = navigator; return ( countOfNotNullObj([ \"webkitPersistentStorage\" in t, \"webkitTemporaryStorage\" in t, 0 === (t.vendor || \"\").indexOf(\"Google\"), \"webkitResolveLocalFileSystemURL\" in n, \"BatteryManager\" in n, \"webkitMediaStream\" in n, \"webkitSpeechGrammar\" in n, ]) >= 5 ); } function collectSomeKeys6_related_to_Apple() { const n = window; return ( countOfNotNullObj([ \"ApplePayError\" in n, \"CSSPrimitiveValue\" in n, \"Counter\" in n, 0 === navigator.vendor.indexOf(\"Apple\"), \"RGBColor\" in n, \"WebKitMediaKeys\" in n, ]) >= 4 ); } function collectSomeKeys7_related_to_safari() { const n = window, { HTMLElement: t, Document: e } = n; return ( countOfNotNullObj([ \"safari\" in n, !(\"ongestureend\" in n), !(\"TouchEvent\" in n), !(\"orientation\" in n), t && !(\"autocapitalize\" in t.prototype), e && \"pointerLockElement\" in e.prototype, ]) >= 4 ); } function collectSomeKeys1_related_to_firefox() { // 检查下下面几个元素是否至少存在4个 var n, t; const windowObj = window; return ( countOfNotNullObj([ \"buildID\" in navigator, \"MozAppearance\" in (null !== // 获取 reject(throw_err(\"timeout\")), Math.min(r, l + o - Date.now())); }, d = () => { try { const r = testAudioData.startRendering(); switch ((hasKey_then(r) && justRunPromise(r), testAudioData.state)) { case \"running\": ((l = Date.now()), s && f()); break; case \"suspended\": (document.hidden || a++, s && a >= t ? reject(throw_err(\"suspended\")) : setTimeout(d, e)); } } catch (r) { reject(r); } }; (convertToIUint8Array(), (i = () => { s || ((s = true), l > 0 && f()); })); }); return [u, i]; })(testAudioData), c = justRunPromise( i.then( (n) => (function (n) { let t = 0; for (let e = 0; e < n.length; ++e) t += Math.abs(n[e]); return t; })(n.getChannelData(0).subarray(4500)), (n) => { if (\"timeout\" === n.name || \"suspended\" === n.name) return -3; throw n; }, ), ); return () => (u(), c); } function throw_err(name) { const t = new Error(name); return ((t.name = name), t); } async function getSandBoxAndRunFunc(func, HtmlCode, e = 50) { var r, o, i; const Document = document; for (; !Document.body;) await sleep(e); const aIframe = Document.createElement(\"iframe\"); try { for ( await new Promise((resolve, reject) => { let r = false; const o = () => { ((r = true), resolve()); }; ((aIframe.onload = o), (aIframe.onerror = (n) => { ((r = true), reject(n)); })); const { style: i } = aIframe; (i.setProperty(\"display\", \"block\", \"important\"), (i.position = \"absolute\"), (i.top = \"0\"), (i.left = \"0\"), (i.visibility = \"hidden\"), HtmlCode && (\"srcdoc\" in aIframe) ? (aIframe.srcdoc = HtmlCode) : (aIframe.src = \"about:blank\"), Document.body.appendChild(aIframe)); const s = () => { var n, t; r || (\"complete\" === (null === (t = null === (n = aIframe.contentWindow) || void 0 === n ? void 0 : n.document) || void 0 === t ? void 0 : t.readyState) ? o() : setTimeout(s, 10)); }; s(); }); !(null === (o = null === (r = aIframe.contentWindow) || void 0 === r ? void 0 : r.document) || void 0 === o ? void 0 : o.body); ) await sleep(e); return await func(aIframe, aIframe.contentWindow); } finally { null === (i = aIframe.parentNode) || void 0 === i || i.removeChild(aIframe); } } function CSSElementCreator(ElementKeys) { const [t, e] = (function (ElementKeys) { var t, e; const err = `Unexpected syntax '${ElementKeys}'`, o = /^\\s*([a-z-]*)(.*)$/i.exec(ElementKeys), i = o[1] || void 0, u = {}, c = /([.:#][\\w-]+|\\[.+?\\])/gi, s = (n, t) => { ((u[n] = u[n] || []), u[n].push(t)); }; for (; ;) { const n = c.exec(o[2]); if (!n) break; const i = n[0]; switch (i[0]) { case \".\": s(\"class\", i.slice(1)); break; case \"#\": s(\"id\", i.slice(1)); break; case \"[\": { const n = /^\\[([\\w-]+)([~|^$*]?=(\"(.*?)\"|([\\w-]+)))?(\\s+[is])?\\]$/.exec(i); if (!n) throw new Error(err); s( n[1], null !== (e = null !== (t = n[4]) && void 0 !== t ? t : n[5]) && void 0 !== e ? e : \"\", ); break; } default: throw new Error(err); } } return [i, u]; })(ElementKeys), r = document.createElement(null != t ? t : \"div\"); for (const o of Object.keys(e)) { const n = e[o].join(\" \"); \"style\" === o ? wn(r.style, n) : r.setAttribute(o, n); } return r; } function wn(n, t) { for (const e of t.split(\";\")) { const t = /^\\s*([\\w-]+)\\s*:\\s*(.+?)(\\s*!([\\w-]+))?\\s*$/.exec(e); if (t) { const [, e, r, , o] = t; n.setProperty(e, r, o || \"\"); } } } function draw_canvas_test(n) { let t, e, r = false; const [canvas, canvas_2d] = (function () { const canvas = document.createElement(\"canvas\"); return ((canvas.width = 1), (canvas.height = 1), [canvas, canvas.getContext(\"2d\")]); })(); return ( !(function (n, t) { return !(!t || !n.toDataURL); })(canvas, canvas_2d) ? (t = e = \"unsupported\") : ((r = (function (n) { return ( n.rect(0, 0, 10, 10), n.rect(2, 2, 6, 6), !n.isPointInPath(5, 5, \"evenodd\") ); })(canvas_2d)), n ? (t = e = \"skipped\") : ([t, e] = (function (n, t) { !(function (n, t) { ((n.width = 240), (n.height = 60), (t.textBaseline = \"alphabetic\"), (t.fillStyle = \"#f60\"), t.fillRect(100, 1, 62, 20), (t.fillStyle = \"#069\"), (t.font = '11pt \"Times New Roman\"')); const e = `Cwm fjordbank gly ${String.fromCharCode(55357, 56835)}`; (t.fillText(e, 2, 15), (t.fillStyle = \"rgba(102, 204, 0, 0.2)\"), (t.font = \"18pt Arial\"), t.fillText(e, 4, 45)); })(n, t); const e = bn(n), r = bn(n); if (e !== r) return [\"unstable\", \"unstable\"]; !(function (n, t) { ((n.width = 122), (n.height = 110), (t.globalCompositeOperation = \"multiply\")); for (const [e, r, o] of [ [\"#f2f\", 40, 40], [\"#2ff\", 80, 40], [\"#ff2\", 60, 80], ]) ((t.fillStyle = e), t.beginPath(), t.arc(r, o, 40, 0, 2 * Math.PI, true), t.closePath(), t.fill()); ((t.fillStyle = \"#f9c\"), t.arc(60, 60, 60, 0, 2 * Math.PI, true), t.arc(60, 60, 20, 0, 2 * Math.PI, true), t.fill(\"evenodd\")); })(n, t); const o = bn(n); return [o, e]; })(canvas, canvas_2d))), { winding: r, geometry: t, text: e } ); } function bn(n) { return n.toDataURL(); } function get_H_W() { const screen_ = screen, t = (n) => checkNaN(parseInt_(n), null), e = [t(screen_.width), t(screen_.height)]; return (e.sort().reverse(), e); } let ScreenSizeInfoCache, Sn; function getCheckScreenSizeFunc() { return ( (function () { if (void 0 !== Sn) return; const n = () => { const ScreenSizeInfo = getScreenSizeInfo(); checkAllFalse(ScreenSizeInfo) ? (Sn = setTimeout(n, 2500)) : ((ScreenSizeInfoCache = ScreenSizeInfo), (Sn = void 0)); }; n(); })(), async () => { let ScreenSizeInfo = getScreenSizeInfo(); if (checkAllFalse(ScreenSizeInfo)) { if (ScreenSizeInfoCache) return [...ScreenSizeInfoCache]; checkHasFullScreenElement() && (await (function () { const documentObj = document; return ( documentObj.exitFullscreen || documentObj.msExitFullscreen || documentObj.mozCancelFullScreen || documentObj.webkitExitFullscreen ).call(documentObj); })(), (ScreenSizeInfo = getScreenSizeInfo())); } return (checkAllFalse(ScreenSizeInfo) || (ScreenSizeInfoCache = ScreenSizeInfo), ScreenSizeInfo); } ); } function getScreenSizeInfo() { const screenObj = screen; return [ checkNaN(StrToFloat(screenObj.availTop), null), checkNaN(StrToFloat(screenObj.width) - StrToFloat(screenObj.availWidth) - checkNaN(StrToFloat(screenObj.availLeft), 0), null), checkNaN(StrToFloat(screenObj.height) - StrToFloat(screenObj.availHeight) - checkNaN(StrToFloat(screenObj.availTop), 0), null), checkNaN(StrToFloat(screenObj.availLeft), null), ]; } function checkAllFalse(arr) { for (let t = 0; t < 4; ++t) if (arr[t]) return false; return true; } function setCSS1(n) { (n.style.setProperty(\"visibility\", \"hidden\", \"important\"), n.style.setProperty(\"display\", \"block\", \"important\")); } function Cn(n) { return matchMedia(`(inverted-colors: ${n})`).matches; } function Pn(n) { return matchMedia(`(forced-colors: ${n})`).matches; } function Tn(n) { return matchMedia(`(prefers-contrast: ${n})`).matches; } function On(n) { return matchMedia(`(prefers-reduced-motion: ${n})`).matches; } function _n(n) { return matchMedia(`(prefers-reduced-transparency: ${n})`).matches; } function xn(n) { return matchMedia(`(dynamic-range: ${n})`).matches; } const Nn = Math, jn = () => 0; const testStr = \"mmMwWLliI0fiflO&1\", fontTest = { default: [], apple: [{ font: \"-apple-system-body\" }], serif: [{ fontFamily: \"serif\" }], sans: [{ fontFamily: \"sans-serif\" }], mono: [{ fontFamily: \"monospace\" }], min: [{ fontSize: \"1px\" }], system: [{ fontFamily: \"system-ui\" }], }; const webgl_const = /*#__PURE__*/ new Set([ 10752, 2849, 2884, 2885, 2886, 2928, 2929, 2930, 2931, 2932, 2960, 2961, 2962, 2963, 2964, 2965, 2966, 2967, 2968, 2978, 3024, 3042, 3088, 3089, 3106, 3107, 32773, 32777, 32777, 32823, 32824, 32936, 32937, 32938, 32939, 32968, 32969, 32970, 32971, 3317, 33170, 3333, 3379, 3386, 33901, 33902, 34016, 34024, 34076, 3408, 3410, 3411, 3412, 3413, 3414, 3415, 34467, 34816, 34817, 34818, 34819, 34877, 34921, 34930, 35660, 35661, 35724, 35738, 35739, 36003, 36004, 36005, 36347, 36348, 36349, 37440, 37441, 37443, 7936, 7937, 7938, ]), webgl_Extension_Const = /*#__PURE__*/ new Set([ 34047, 35723, 36063, 34852, 34853, 34854, 34229, 36392, 36795, 38449, ]), Dn = [\"FRAGMENT_SHADER\", \"VERTEX_SHADER\"], Zn = [ \"LOW_FLOAT\", \"MEDIUM_FLOAT\", \"HIGH_FLOAT\", \"LOW_INT\", \"MEDIUM_INT\", \"HIGH_INT\", ], WEBGL_debug_renderer_info__ = \"WEBGL_debug_renderer_info\"; function get_webgl_context(cache) { if (cache.webgl) return cache.webgl.context; const test_canvas = document.createElement(\"canvas\"); let e; test_canvas.addEventListener(\"webglCreateContextError\", () => (e = void 0)); for (const o of [\"webgl\", \"experimental-webgl\"]) { try { e = test_canvas.getContext(o); } catch (r) { } if (e) break; } return ((cache.webgl = { context: e }), e); } function Un(n, t, e) { const r = n.getShaderPrecisionFormat(n[t], n[e]); return r ? [r.rangeMin, r.rangeMax, r.precision] : []; } function str_filter_only_A_Z_0_9_x_str(n) { return Object.keys(n.__proto__).filter(only_A_Z_0_9_x_str); } function only_A_Z_0_9_x_str(n) { return \"string\" == typeof n && !n.match(/[^A-Z0-9_x]/); } function collectSomeKeys1_related_to_firefox__() { return collectSomeKeys1_related_to_firefox(); } function check_getParameter(n) { return \"function\" == typeof n.getParameter; } const AdBlocker_test_worker = async function ({ debug: context } = {}) { if (!collectSomeKeys6_related_to_Apple() && !test_mobile()) return; const someElementKeyList = (function () { const base64_decode = atob; return { abpIndo: [ \"#Iklan-Melayang\", \"#Kolom-Iklan-728\", \"#SidebarIklan-wrapper\", '[title=\"ALIENBOLA\" i]', base64_decode(\"I0JveC1CYW5uZXItYWRz\"), // #Box-Banner-ads ], abpvn: [ \".quangcao\", \"#mobileCatfish\", base64_decode(\"LmNsb3NlLWFkcw==\"), '[id^=\"bn_bottom_fixed_\"]', \"#pmadv\", ], adBlockFinland: [ \".mainostila\", base64_decode(\"LnNwb25zb3JpdA==\"), \".ylamainos\", base64_decode(\"YVtocmVmKj0iL2NsaWNrdGhyZ2guYXNwPyJd\"), base64_decode(\"YVtocmVmXj0iaHR0cHM6Ly9hcHAucmVhZHBlYWsuY29tL2FkcyJd\"), ], adBlockPersian: [ \"#navbar_notice_50\", \".kadr\", 'TABLE[width=\"140px\"]', \"#divAgahi\", base64_decode(\"YVtocmVmXj0iaHR0cDovL2cxLnYuZndtcm0ubmV0L2FkLyJd\"), ], adBlockWarningRemoval: [ \"#adblock-honeypot\", \".adblocker-root\", \".wp_adblock_detect\", base64_decode(\"LmhlYWRlci1ibG9ja2VkLWFk\"), base64_decode(\"I2FkX2Jsb2NrZXI=\"), ], adGuardAnnoyances: [ \".hs-sosyal\", \"#cookieconsentdiv\", 'div[class^=\"app_gdpr\"]', \".as-oil\", '[data-cypress=\"soft-push-notification-modal\"]', ], adGuardBase: [ \".BetterJsPopOverlay\", base64_decode(\"I2FkXzMwMFgyNTA=\"), base64_decode(\"I2Jhbm5lcmZsb2F0MjI=\"), base64_decode(\"I2NhbXBhaWduLWJhbm5lcg==\"), base64_decode(\"I0FkLUNvbnRlbnQ=\"), ], adGuardChinese: [ base64_decode(\"LlppX2FkX2FfSA==\"), base64_decode(\"YVtocmVmKj0iLmh0aGJldDM0LmNvbSJd\"), \"#widget-quan\", base64_decode(\"YVtocmVmKj0iLzg0OTkyMDIwLnh5eiJd\"), base64_decode(\"YVtocmVmKj0iLjE5NTZobC5jb20vIl0=\"), ], adGuardFrench: [ \"#pavePub\", base64_decode(\"LmFkLWRlc2t0b3AtcmVjdGFuZ2xl\"), \".mobile_adhesion\", \".widgetadv\", base64_decode(\"LmFkc19iYW4=\"), ], adGuardGerman: ['aside[data-portal-id=\"leaderboard\"]'], adGuardJapanese: [ \"#kauli_yad_1\", base64_decode(\"YVtocmVmXj0iaHR0cDovL2FkMi50cmFmZmljZ2F0ZS5uZXQvIl0=\"), base64_decode(\"Ll9wb3BJbl9pbmZpbml0ZV9hZA==\"), base64_decode(\"LmFkZ29vZ2xl\"), base64_decode(\"Ll9faXNib29zdFJldHVybkFk\"), ], adGuardMobile: [ base64_decode(\"YW1wLWF1dG8tYWRz\"), base64_decode(\"LmFtcF9hZA==\"), 'amp-embed[type=\"24smi\"]', \"#mgid_iframe1\", base64_decode(\"I2FkX2ludmlld19hcmVh\"), ], adGuardRussian: [ base64_decode(\"YVtocmVmXj0iaHR0cHM6Ly9hZC5sZXRtZWFkcy5jb20vIl0=\"), base64_decode(\"LnJlY2xhbWE=\"), 'div[id^=\"smi2adblock\"]', base64_decode(\"ZGl2W2lkXj0iQWRGb3hfYmFubmVyXyJd\"), \"#psyduckpockeball\", ], adGuardSocial: [ base64_decode(\"YVtocmVmXj0iLy93d3cuc3R1bWJsZXVwb24uY29tL3N1Ym1pdD91cmw9Il0=\"), base64_decode(\"YVtocmVmXj0iLy90ZWxlZ3JhbS5tZS9zaGFyZS91cmw/Il0=\"), \".etsy-tweet\", \"#inlineShare\", \".popup-social\", ], adGuardSpanishPortuguese: [ \"#barraPublicidade\", \"#Publicidade\", \"#publiEspecial\", \"#queTooltip\", \".cnt-publi\", ], adGuardTrackingProtection: [ \"#qoo-counter\", base64_decode(\"YVtocmVmXj0iaHR0cDovL2NsaWNrLmhvdGxvZy5ydS8iXQ==\"), base64_decode(\"YVtocmVmXj0iaHR0cDovL2hpdGNvdW50ZXIucnUvdG9wL3N0YXQucGhwIl0=\"), base64_decode(\"YVtocmVmXj0iaHR0cDovL3RvcC5tYWlsLnJ1L2p1bXAiXQ==\"), \"#top100counter\", ], adGuardTurkish: [ \"#backkapat\", base64_decode(\"I3Jla2xhbWk=\"), base64_decode(\"YVtocmVmXj0iaHR0cDovL2Fkc2Vydi5vbnRlay5jb20udHIvIl0=\"), base64_decode(\"YVtocmVmXj0iaHR0cDovL2l6bGVuemkuY29tL2NhbXBhaWduLyJd\"), base64_decode(\"YVtocmVmXj0iaHR0cDovL3d3dy5pbnN0YWxsYWRzLm5ldC8iXQ==\"), ], bulgarian: [ base64_decode(\"dGQjZnJlZW5ldF90YWJsZV9hZHM=\"), \"#ea_intext_div\", \".lapni-pop-over\", \"#xenium_hot_offers\", ], easyList: [ \".yb-floorad\", base64_decode(\"LndpZGdldF9wb19hZHNfd2lkZ2V0\"), base64_decode(\"LnRyYWZmaWNqdW5reS1hZA==\"), \".textad_headline\", base64_decode(\"LnNwb25zb3JlZC10ZXh0LWxpbmtz\"), ], easyListChina: [ base64_decode(\"LmFwcGd1aWRlLXdyYXBbb25jbGljayo9ImJjZWJvcy5jb20iXQ==\"), // .appguide-wrap[onclick*=\"bcebos.com\"] base64_decode(\"LmZyb250cGFnZUFkdk0=\"), \"#taotaole\", \"#aafoot.top_box\", \".cfa_popup\", ], easyListCookie: [ \".ezmob-footer\", \".cc-CookieWarning\", \"[data-cookie-number]\", base64_decode(\"LmF3LWNvb2tpZS1iYW5uZXI=\"), \".sygnal24-gdpr-modal-wrap\", ], easyListCzechSlovak: [ \"#onlajny-stickers\", base64_decode(\"I3Jla2xhbW5pLWJveA==\"), base64_decode(\"LnJla2xhbWEtbWVnYWJvYXJk\"), \".sklik\", base64_decode(\"W2lkXj0ic2tsaWtSZWtsYW1hIl0=\"), ], easyListDutch: [ base64_decode(\"I2FkdmVydGVudGll\"), base64_decode(\"I3ZpcEFkbWFya3RCYW5uZXJCbG9jaw==\"), \".adstekst\", base64_decode(\"YVtocmVmXj0iaHR0cHM6Ly94bHR1YmUubmwvY2xpY2svIl0=\"), \"#semilo-lrectangle\", ], easyListGermany: [ \"#SSpotIMPopSlider\", base64_decode(\"LnNwb25zb3JsaW5rZ3J1ZW4=\"), base64_decode(\"I3dlcmJ1bmdza3k=\"), base64_decode(\"I3Jla2xhbWUtcmVjaHRzLW1pdHRl\"), base64_decode(\"YVtocmVmXj0iaHR0cHM6Ly9iZDc0Mi5jb20vIl0=\"), ], easyListItaly: [ base64_decode(\"LmJveF9hZHZfYW5udW5jaQ==\"), \".sb-box-pubbliredazionale\", base64_decode(\"YVtocmVmXj0iaHR0cDovL2FmZmlsaWF6aW9uaWFkcy5zbmFpLml0LyJd\"), base64_decode(\"YVtocmVmXj0iaHR0cHM6Ly9hZHNlcnZlci5odG1sLml0LyJd\"), base64_decode(\"YVtocmVmXj0iaHR0cHM6Ly9hZmZpbGlhemlvbmlhZHMuc25haS5pdC8iXQ==\"), ], easyListLithuania: [ base64_decode(\"LnJla2xhbW9zX3RhcnBhcw==\"), base64_decode(\"LnJla2xhbW9zX251b3JvZG9z\"), base64_decode(\"aW1nW2FsdD0iUmVrbGFtaW5pcyBza3lkZWxpcyJd\"), base64_decode(\"aW1nW2FsdD0iRGVkaWt1b3RpLmx0IHNlcnZlcmlhaSJd\"), base64_decode(\"aW1nW2FsdD0iSG9zdGluZ2FzIFNlcnZlcmlhaS5sdCJd\"), ], estonian: [base64_decode(\"QVtocmVmKj0iaHR0cDovL3BheTRyZXN1bHRzMjQuZXUiXQ==\")], fanboyAnnoyances: [ \"#ac-lre-player\", \".navigate-to-top\", \"#subscribe_popup\", \".newsletter_holder\", \"#back-top\", ], fanboyAntiFacebook: [\".util-bar-module-firefly-visible\"], fanboyEnhancedTrackers: [ \".open.pushModal\", \"#issuem-leaky-paywall-articles-zero-remaining-nag\", \"#sovrn_container\", 'div[class$=\"-hide\"][zoompage-fontsize][style=\"display: block;\"]', \".BlockNag__Card\", ], fanboySocial: [ \"#FollowUs\", \"#meteored_share\", \"#social_follow\", \".article-sharer\", \".community__social-desc\", ], frellwitSwedish: [ base64_decode(\"YVtocmVmKj0iY2FzaW5vcHJvLnNlIl1bdGFyZ2V0PSJfYmxhbmsiXQ==\"), base64_decode(\"YVtocmVmKj0iZG9rdG9yLXNlLm9uZWxpbmsubWUiXQ==\"), \"article.category-samarbete\", base64_decode(\"ZGl2LmhvbGlkQWRz\"), \"ul.adsmodern\", ], greekAdBlock: [ base64_decode(\"QVtocmVmKj0iYWRtYW4ub3RlbmV0LmdyL2NsaWNrPyJd\"), base64_decode(\"QVtocmVmKj0iaHR0cDovL2F4aWFiYW5uZXJzLmV4b2R1cy5nci8iXQ==\"), base64_decode( \"QVtocmVmKj0iaHR0cDovL2ludGVyYWN0aXZlLmZvcnRobmV0LmdyL2NsaWNrPyJd\", ), \"DIV.agores300\", \"TABLE.advright\", ], hungarian: [ \"#cemp_doboz\", \".optimonk-iframe-container\", base64_decode(\"LmFkX19tYWlu\"), base64_decode(\"W2NsYXNzKj0iR29vZ2xlQWRzIl0=\"), \"#hirdetesek_box\", ], iDontCareAboutCookies: [ '.alert-info[data-block-track*=\"CookieNotice\"]', \".ModuleTemplateCookieIndicator\", \".o--cookies--container\", \"#cookies-policy-sticky\", \"#stickyCookieBar\", ], icelandicAbp: [ base64_decode( \"QVtocmVmXj0iL2ZyYW1ld29yay9yZXNvdXJjZXMvZm9ybXMvYWRzLmFzcHgiXQ==\", ), ], latvian: [ base64_decode( \"YVtocmVmPSJodHRwOi8vd3d3LnNhbGlkemluaS5sdi8iXVtzdHlsZT0iZGlzcGxheTogYmxvY2s7IHdpZHRoOiAxMjBweDsgaGVpZ2h0OiA0MHB4OyBvdmVyZmxvdzogaGlkZGVuOyBwb3NpdGlvbjogcmVsYXRpdmU7Il0=\", ), base64_decode( \"YVtocmVmPSJodHRwOi8vd3d3LnNhbGlkemluaS5sdi8iXVtzdHlsZT0iZGlzcGxheTogYmxvY2s7IHdpZHRoOiA4OHB4OyBoZWlnaHQ6IDMxcHg7IG92ZXJmbG93OiBoaWRkZW47IHBvc2l0aW9uOiByZWxhdGl2ZTsiXQ==\", ), ], listKr: [ base64_decode(\"YVtocmVmKj0iLy9hZC5wbGFuYnBsdXMuY28ua3IvIl0=\"), base64_decode(\"I2xpdmVyZUFkV3JhcHBlcg==\"), base64_decode(\"YVtocmVmKj0iLy9hZHYuaW1hZHJlcC5jby5rci8iXQ==\"), base64_decode(\"aW5zLmZhc3R2aWV3LWFk\"), \".revenue_unit_item.dable\", ], listeAr: [ base64_decode(\"LmdlbWluaUxCMUFk\"), \".right-and-left-sponsers\", base64_decode(\"YVtocmVmKj0iLmFmbGFtLmluZm8iXQ==\"), base64_decode(\"YVtocmVmKj0iYm9vcmFxLm9yZyJd\"), base64_decode(\"YVtocmVmKj0iZHViaXp6bGUuY29tL2FyLz91dG1fc291cmNlPSJd\"), ], listeFr: [ base64_decode(\"YVtocmVmXj0iaHR0cDovL3Byb21vLnZhZG9yLmNvbS8iXQ==\"), base64_decode(\"I2FkY29udGFpbmVyX3JlY2hlcmNoZQ==\"), base64_decode(\"YVtocmVmKj0id2Vib3JhbWEuZnIvZmNnaS1iaW4vIl0=\"), \".site-pub-interstitiel\", 'div[id^=\"crt-\"][data-criteo-id]', ], officialPolish: [ \"#ceneo-placeholder-ceneo-12\", base64_decode(\"W2hyZWZePSJodHRwczovL2FmZi5zZW5kaHViLnBsLyJd\"), base64_decode( \"YVtocmVmXj0iaHR0cDovL2Fkdm1hbmFnZXIudGVjaGZ1bi5wbC9yZWRpcmVjdC8iXQ==\", ), base64_decode(\"YVtocmVmXj0iaHR0cDovL3d3dy50cml6ZXIucGwvP3V0bV9zb3VyY2UiXQ==\"), base64_decode(\"ZGl2I3NrYXBpZWNfYWQ=\"), ], ro: [ base64_decode(\"YVtocmVmXj0iLy9hZmZ0cmsuYWx0ZXgucm8vQ291bnRlci9DbGljayJd\"), base64_decode( \"YVtocmVmXj0iaHR0cHM6Ly9ibGFja2ZyaWRheXNhbGVzLnJvL3Ryay9zaG9wLyJd\", ), base64_decode( \"YVtocmVmXj0iaHR0cHM6Ly9ldmVudC4ycGVyZm9ybWFudC5jb20vZXZlbnRzL2NsaWNrIl0=\", ), base64_decode(\"YVtocmVmXj0iaHR0cHM6Ly9sLnByb2ZpdHNoYXJlLnJvLyJd\"), 'a[href^=\"/url/\"]', ], ruAd: [ base64_decode(\"YVtocmVmKj0iLy9mZWJyYXJlLnJ1LyJd\"), base64_decode(\"YVtocmVmKj0iLy91dGltZy5ydS8iXQ==\"), base64_decode(\"YVtocmVmKj0iOi8vY2hpa2lkaWtpLnJ1Il0=\"), \"#pgeldiz\", \".yandex-rtb-block\", ], thaiAds: [ \"a[href*=macau-uta-popup]\", base64_decode(\"I2Fkcy1nb29nbGUtbWlkZGxlX3JlY3RhbmdsZS1ncm91cA==\"), base64_decode(\"LmFkczMwMHM=\"), \".bumq\", \".img-kosana\", ], webAnnoyancesUltralist: [ \"#mod-social-share-2\", \"#social-tools\", base64_decode(\"LmN0cGwtZnVsbGJhbm5lcg==\"), \".zergnet-recommend\", \".yt.btn-link.btn-md.btn\", ], }; })(), someElementKeyName = Object.keys(someElementKeyList), allKeys = [].concat(...someElementKeyName.map((n) => someElementKeyList[n])), o = await (async function (allKeys) { var t; const documentObj = document, testDiv = documentObj.createElement(\"div\"), o = new Array(allKeys.length), i = {}; setCSS1(testDiv); for (let u = 0; u < allKeys.length; ++u) { const testCSS_Element = CSSElementCreator(allKeys[u]); \"DIALOG\" === testCSS_Element.tagName && testCSS_Element.show(); const i = documentObj.createElement(\"div\"); (setCSS1(i), i.appendChild(testCSS_Element), testDiv.appendChild(i), (o[u] = testCSS_Element)); } for (; !documentObj.body;) await sleep(50); documentObj.body.appendChild(testDiv); try { for (let t = 0; t < allKeys.length; ++t) o[t].offsetParent || (i[allKeys[t]] = true); } finally { null === (t = testDiv.parentNode) || void 0 === t || t.removeChild(testDiv); } return i; })(allKeys); context && (function (n, t) { let e = \"DOM blockers debug:\\n```\"; for (const r of Object.keys(n)) { e += `\\n${r}:`; for (const o of n[r]) e += `\\n ${t[o] ? \"🚫\" : \"➡️\"} ${o}`; } console.log(`${e}\\n\\`\\`\\``); })(someElementKeyList, o); const i = someElementKeyName.filter((n) => { const e = someElementKeyList[n]; return countOfNotNullObj(e.map((n) => o[n])) > 0.6 * e.length; }); return (i.sort(), i); }, fontWidthTest = function () { return (function (func, width = 4e3) { return getSandBoxAndRunFunc((e, iframe) => { const document = iframe.document, body = document.body, style = body.style; ((style.width = `${width}px`), (style.webkitTextSizeAdjust = style.textSizeAdjust = \"none\"), collectSomeKeys10_related_to_chrome() ? (body.style.zoom = \"\" + 1 / iframe.devicePixelRatio) : collectSomeKeys6_related_to_Apple() && (body.style.zoom = \"reset\")); const c = document.createElement(\"div\"); return ( (c.textContent = [...Array((width / 20) < 0)] .map(() => \"word\") .join(\" \")), body.appendChild(c), func(document, body) ); }, ' { // for (arr.len = 0; cur_pos++, input[cur_pos] !== json_chr1;) { // if (input[cur_pos] === json_chr8) { // cur == \\ // if ((cur_pos++, input[cur_pos] === json_chr11)) { // cur == u // const n = parseInt(convertToString(input.subarray(cur_pos + 1, cur_pos + 5)), 16); // (appendToArr(arr, convertToUint8Array(String.fromCharCode(n))), (cur_pos += 4)); // continue; // } // const n = Le[input[cur_pos]]; // if (n) { // zt(arr, n); // continue; // } // return throw_err(); // } // if (void 0 === input[cur_pos]) return throw_err(); // zt(arr, input[cur_pos]); // } // return (cur_pos++, convertToString(Kt(arr))); // }, // u = () => { // const n = cur_pos; // for ( // ; // input[cur_pos] === json_chr15 || input[cur_pos] === json_chr10 || input[cur_pos] === json_chr12 || input[cur_pos] === json_chr13 || is_Num_(input[cur_pos]); // ) // cur_pos++; // return Number(convertToString(input.subarray(n, cur_pos))); // }, // c = () => { // const n = []; // for (cur_pos++; ;) { // if ((space_strip(), input[cur_pos] === json_chr17)) { // cur_pos++; // break; // } // if (n.length) { // if (input[cur_pos] !== json_chr2) return throw_err(); // cur_pos++; // } // n.push(o()); // } // return n; // }, // s = () => { // const n = {}; // let t = true; // for (cur_pos++; ;) { // if ((space_strip(), input[cur_pos] === json_chr19)) { // cur_pos++; // break; // } // if (!t) { // if (input[cur_pos] !== json_chr2) return throw_err(); // (cur_pos++, space_strip()); // } // if (input[cur_pos] !== json_chr1) return throw_err(); // const u = i(); // if ((space_strip(), input[cur_pos] !== json_chr3)) return throw_err(); // (cur_pos++, // Object.defineProperty(n, u, { // value: o(), // configurable: true, // enumerable: true, // writable: true, // }), // (t = false)); // } // return n; // }, // space_strip = () => { // for (; input[cur_pos] === json_chr4 || input[cur_pos] === json_chr7 || input[cur_pos] === json_chr6 || input[cur_pos] === json_chr5;) cur_pos++; // }, // stream_cmp = (n) => { // for (let t = 0; t < n.length; t++) if (input[cur_pos + t] !== n[t]) return false; // return true; // }, // throw_err = () => { // throw new SyntaxError( // \"Unexpected \" + (cur_pos < input.length ? `byte ${cur_pos}` : \"end\"), // ); // }, // m = o(); // return (space_strip(), void 0 !== input[cur_pos] && throw_err(), m); // } const oe = 34, ie = 44, ue = 58, ce = 32, se = 9, ae = 13, le = 10, fe = 92, de = 48, me = 101, ve = 117, he = 69, pe = 43, ge = 45, we = 46, ye = 91, be = 93, Ee = 123, Re = 125, Se = /*#__PURE__*/ new Uint8Array([110, ve, 108, 108]), Ie = /*#__PURE__*/ new Uint8Array([116, 114, ve, me]), ke = /*#__PURE__*/ new Uint8Array([102, 97, 108, 115, me]), Ae = { '\"': '\"', \"\\\\\": \"\\\\\", \"\\b\": \"b\", \"\\f\": \"f\", \"\\n\": \"n\", \"\\r\": \"r\", \"\\t\": \"t\", } function JSON_parser(n) { const t = getEmptyArr_size128(), e = convertToIUint8Array(n); let r = 0; const o = () => ( a(), e[r] === oe ? i() : is_Num_(e[r]) ? u() : l(Se) ? ((r += Se.length), null) : l(Ie) ? ((r += Ie.length), !0) : l(ke) ? ((r += ke.length), !1) : e[r] === ye ? c() : e[r] === Ee ? s() : f() ), i = () => { for (t.len = 0; r++, e[r] !== oe;) { if (e[r] === fe) { if ((r++, e[r] === ve)) { const n = parseInt(convertToString(e.subarray(r + 1, r + 5)), 16); (qt(t, w(String.fromCharCode(n))), (r += 4)); continue; } const n = Le[e[r]]; if (n) { zt(t, n); continue; } return f(); } if (void 0 === e[r]) return f(); zt(t, e[r]); } return (r++, convertToString(Kt(t))); }, u = () => { const n = r; for ( ; e[r] === we || e[r] === me || e[r] === he || e[r] === pe || is_Num_(e[r]); ) r++; return Number(convertToString(e.subarray(n, r))); }, c = () => { const n = []; for (r++; ;) { if ((a(), e[r] === be)) { r++; break; } if (n.length) { if (e[r] !== ie) return f(); r++; } n.push(o()); } return n; }, s = () => { const n = {}; let t = !0; for (r++; ;) { if ((a(), e[r] === Re)) { r++; break; } if (!t) { if (e[r] !== ie) return f(); (r++, a()); } if (e[r] !== oe) return f(); const u = i(); if ((a(), e[r] !== ue)) return f(); (r++, Object.defineProperty(n, u, { value: o(), configurable: !0, enumerable: !0, writable: !0, }), (t = !1)); } return n; }, a = () => { for (; e[r] === ce || e[r] === le || e[r] === ae || e[r] === se;) r++; }, l = (n) => { for (let t = 0; t < n.length; t++) if (e[r + t] !== n[t]) return !1; return !0; }, f = () => { throw new SyntaxError( \"Unexpected \" + (r < e.length ? `byte ${r}` : \"end\"), ); }, m = o(); return (a(), void 0 !== e[r] && f(), m); } function ee(n) { return void 0 === n || \"function\" == typeof n || \"symbol\" == typeof n; } function is_Num_(n) { return (n >= json_chr9 && n < json_chr9 + 10) || n === json_chr14; } const json_chr1 = 34, // \" json_chr2 = 44, // , json_chr3 = 58, // : json_chr4 = 32, // ' ' json_chr5 = 9, // \\t json_chr6 = 13, // \\r json_chr7 = 10, // \\n json_chr8 = 92, // \\ json_chr9 = 48, // 0 json_chr10 = 49, // 1 json_chr11 = 117, // u json_chr12 = 69, // E json_chr13 = 43, // + json_chr14 = 45, // - json_chr15 = 46, // . json_chr16 = 91, // [ json_chr17 = 93, // ] json_chr18 = 123, // { json_chr19 = 125, // } A_null = /*#__PURE__*/ new Uint8Array([110, json_chr11, 108, 108]), A_true = /*#__PURE__*/ new Uint8Array([116, 114, json_chr11, json_chr10]), A_false = /*#__PURE__*/ new Uint8Array([102, 97, 108, 115, json_chr10]), EscapeCharactersMap = { '\"': '\"', \"\\\\\": \"\\\\\", \"\\b\": \"b\", \"\\f\": \"f\", \"\\n\": \"n\", \"\\r\": \"r\", \"\\t\": \"t\", }, Le = /*#__PURE__*/ (() => { const n = new Uint8Array(128); for (const [t, e] of Object.entries(EscapeCharactersMap)) n[e.charCodeAt(0)] = t.charCodeAt(0); return n; })(), Ce = /[\\x00-\\x1F\"\\\\]/g, Pe = \"Client timeout\", Te = \"Network connection error\", Oe = \"Network request aborted\", _e = \"Response cannot be parsed\", xe = \"Blocked by CSP\", Ne = \"The endpoint parameter is not a valid URL\", je = \"Handle on demand agent data error\"; function Ve(n, t, e = \"...\") { return n.length 1 ? e.slice(1) : []]; } const We = /*#__PURE__*/ Me(\"WrongRegion\"), De = /*#__PURE__*/ Me(\"SubscriptionNotActive\"), Ze = /*#__PURE__*/ Me(\"UnsupportedVersion\"), He = /*#__PURE__*/ Me(\"InstallationMethodRestricted\"), Ge = /*#__PURE__*/ Me(\"HostnameRestricted\"), Ue = /*#__PURE__*/ Me(\"IntegrationFailed\"), Be = /*#__PURE__*/ Me(\"VisitorNotFound\"), $e = /*#__PURE__*/ Me(\"NetworkRestricted\"), Ye = /*#__PURE__*/ Me(\"InvalidProxyIntegrationSecret\"), Xe = /*#__PURE__*/ Me(\"InvalidProxyIntegrationHeaders\"), Je = /*#__PURE__*/ Me(\"ProxyIntegrationSecretEnvironmentMismatch\"); function ze(n, t, e, r) { const o = r.bodyData; return void 0 === o ? or(r) : (function (n) { return ( n instanceof Object && \"2\" === n.v && n.products instanceof Object ); })(o) ? (function (n, t, e, r) { var o; const { notifications: i, requestId: u, sealedResult: c, error: s, products: a, } = n, l = (function (n) { const t = []; for (const e of Object.keys(n)) { const r = n[e]; r && t.push(r); } return t; })(a); er(i); for (const m of l) er(m.notifications); if (s) return ErrExplainer_(s, u, c, e); for (const { error: m } of l) if (m) return ErrExplainer_(m, u, c, e); !(function (n, t, e) { var r; for (const o of t) null === (r = o.onGetResponse) || void 0 === r || r.call(o, n, e); })(n, t, r); const f = null === (o = a.identification) || void 0 === o ? void 0 : o.data, d = f ? { requestId: u, ...(void 0 === c ? {} : { sealedResult: c }), ...f.result, } : Qe(u, c, e); return { result: d }; })(o, n, t, e) : or(r); } function ErrExplainer_(n, t, e, r) { switch (n.code) { case \"NotAvailableForCrawlBots\": case \"NotAvailableForAIBots\": return nr(t, e, true, r); case \"NotAvailableWithoutUA\": return nr(t, e, void 0, r); default: return { error: tr(ErrExplainer(n), t, n), stop: \"VisitorNotFound\" === n.code }; } } function ErrExplainer({ code: n, message: t }) { var e; return void 0 === n ? t : null !== (e = (function (n) { switch (n) { case \"TokenRequired\": return \"API key required\"; case \"TokenNotFound\": return \"API key not found\"; case \"TokenExpired\": return \"API key expired\"; case \"RequestCannotBeParsed\": return \"Request cannot be parsed\"; case \"Failed\": return \"Request failed\"; case \"RequestTimeout\": return \"Request failed to process\"; case \"TooManyRequests\": return \"Too many requests, rate limit exceeded\"; case \"OriginNotAvailable\": return \"Not available for this origin\"; case \"HeaderRestricted\": return \"Not available with restricted header\"; case \"NotAvailableForCrawlBots\": return \"Not available for crawl bots\"; case \"NotAvailableForAIBots\": return \"Not available for AI bots\"; case \"NotAvailableWithoutUA\": return \"Not available when User-Agent is unspecified\"; } })(n)) && void 0 !== e ? e : Me(n); } function Qe(requestId, sealedResult, e) { const r = { requestId: requestId, visitorFound: false, visitorId: \"\", confidence: { score: 0.5, comment: \"The real score is unknown\" }, }; if ((void 0 !== sealedResult && (r.sealedResult = sealedResult), !e)) return r; const o = \"n/a\"; return { ...r, incognito: false, browserName: o, browserVersion: o, device: o, iframe_promise: o, os: o, osVersion: o, firstSeenAt: { subscription: null, global: null }, lastSeenAt: { subscription: null, global: null }, }; } function nr(n, t, e, r) { return { result: { ...Qe(n, t, r), bot: { probability: 1, ...(void 0 === e ? void 0 : { safe: e }) }, }, }; } function tr(n, t, e) { const r = new Error(n); return (void 0 !== t && (r.requestId = t), void 0 !== e && (r.raw = e), r); } function er(n) { null == n || n.forEach(rr); } function rr({ level: n, message: t }) { \"error\" === n ? console.error(t) : \"warning\" === n ? console.warn(t) : console.log(t); } function or(n) { return { error: tr(_e, void 0, { httpStatusCode: n.status, bodyBase64: R(n.body) }), }; } const ir = \"[Fingerprint Pro]\"; function cr(n = `${ir} `) { const t = {}; return (e) => { switch (e.e) { case 15: t[e.getCallId] = e.body; break; case 18: console.log(`${n}Visitor id request`, t[e.getCallId]); break; case 19: console.log(`${n}Visitor id response`, e.body); break; case 16: case 17: delete t[e.getCallId]; } }; } async function runActionInSandbox(action, sandbox) { const { action_queue: action_queue, iframe_promise: iframe_promise } = sandbox; if (null === iframe_promise) throw new Error(\"Shared iframe is not available\"); var i; await Promise.race([ iframe_promise, ((i = `Iframe initialization timed out, debugCounters: ${JSON.stringify(sandbox.dc)}`), runCallbackWhenPageFocusedPromise(2e3).then(() => Promise.reject(new Error(i)))), ]); const u = await new Promise((resolve, reject) => { const i = { action: action, resolve: resolve, reject: reject }; (action_queue.push(i), (async function (sandbox) { const { action_queue: action_queue, ipq: e, si: r, sandbox_iframe_window: o } = sandbox; if (e || 0 === action_queue.length) return; sandbox.ipq = true; for (; action_queue.length > 0;) { const n = action_queue.shift(); if (n) try { const t = await n.action(r, o); n.resolve(t); } catch (i) { n.reject(i); } } sandbox.ipq = false; })(sandbox)); }); return u; } async function initSandbox(sandbox, t = 50) { sandbox.iframe_promise = addEmptyErrHandle( (async function (iframe_sandbox, t) { var e, r; const { dc: dc } = iframe_sandbox, documentObj = document; for (; !documentObj.body;) (dc.adb++, await setTimeoutWrapper(t)); const aIframe = documentObj.createElement(\"iframe\"); for ( await new Promise((n, t) => { let e = false; const r = () => { ((e = true), n()); }; ((aIframe.onload = r), (aIframe.onerror = (n) => { ((e = true), t(n)); })); const { style: style } = aIframe; (style.setProperty(\"display\", \"block\", \"important\"), (style.position = \"absolute\"), (style.top = \"0\"), (style.left = \"0\"), (style.visibility = \"hidden\"), (aIframe.src = \"about:blank\"), documentObj.body.appendChild(aIframe)); const s = () => { var n, t; (dc.crs++, e || (\"complete\" === (null === (t = null === (n = aIframe.contentWindow) || void 0 === n ? void 0 : n.document) || void 0 === t ? void 0 : t.readyState) ? r() : setTimeout(s, 10))); }; s(); }); !(null === (r = null === (e = aIframe.contentWindow) || void 0 === e ? void 0 : e.document) || void 0 === r ? void 0 : r.body); ) (dc.asib++, await setTimeoutWrapper(t)); ((iframe_sandbox.si = aIframe), (iframe_sandbox.sandbox_iframe_window = aIframe.contentWindow)); })(sandbox, t), ); } function setTimeoutWrapper(n, t) { return new Promise((e) => setTimeout(e, n, t)); } const fr = \"__fpjs_pvid\"; function dr() { const n = window, t = n[fr]; return (n[fr] = \"string\" == typeof t ? t : genRandomStrWrapper(10)); } function vr(n, t, e, r) { const o = document, i = \"securitypolicyviolation\"; let u; const c = (t) => { const e = new URL(n, location.href), { blockedURI: r } = t; (r !== e.href && r !== e.protocol.slice(0, -1) && r !== e.origin) || ((u = t), s()); }; o.addEventListener(i, c); const s = () => o.removeEventListener(i, c); return ( null == r || r.then(s, s), Promise.resolve() .then(t) .then( (n) => (s(), n), (n) => new Promise((n) => { const t = new MessageChannel(); ((t.port1.onmessage = () => n()), t.port2.postMessage(null)); }).then(() => { if ((s(), u)) return e(u); throw n; }), ) ); } function isDoucumentVisable() { return !document.hidden; } const pr = \"stripped\", gr = [\"path\", \"query\", \"fragment\"]; async function sha256Hash(n, t) { if (yr(t)) return n; const e = url_parser(n); return ( await Promise.all( gr.map(async (n) => { const r = e[n]; var o; t[n] && r && (e[n] = await (async function (n) { var t; if (\"\" === n) return \"\"; const e = null === (t = window.crypto) || void 0 === t ? void 0 : t.subtle; if (!(null == e ? void 0 : e.digest)) return pr; return R(await e.digest(\"SHA-256\", convertToUint8Array(n))) .replace(/=/g, \"\") .replace(/\\+/g, \"-\") .replace(/\\//g, \"_\"); })(\"query\" === n ? ((o = r), o.split(\"&\").sort().join(\"&\")) : r)); }), ), merge_res(e) ); } function yr(n) { return !(n && gr.some((t) => n[t])); } function url_parser(tls_endpoint) { const [t, e] = split_with(tls_endpoint, \"#\"), [r, o] = split_with(t, \"?\"); let i, u; const c = /^((\\w+:)?\\/\\/[^/]*)?((\\/)(.*)|$)$/.exec(r); return ( c ? ((i = (c[1] || \"\") + (c[4] || \"\")), (u = c[5] || \"\")) : ((i = \"\"), (u = r)), { origin: i, path: u, query: o.length ? o.join(\"?\") : null, fragment: e.length ? e.join(\"#\") : null, } ); } function merge_res({ origin: n, path: t, query: e, fragment: r }) { return n + t + (null === e ? \"\" : `?${e}`) + (null === r ? \"\" : `#${r}`); } function Rr(n, t) { const e = url_parser(n); let r = e.origin + e.path; return ( r && !r.endsWith(\"/\") && (r += \"/\"), (r += t), (e.origin = \"\"), (e.path = r), merge_res(e) ); } function Sr(url, t) { const e = url_parser(url); let { query: r } = e; for (const [o, i] of Object.entries(t)) for (const n of Array.isArray(i) ? i : [i]) r = `${r ? `${r}&` : \"\"}${o}=${Ir(n)}`; return ((e.query = r), merge_res(e)); } function Ir(n) { return n.split(\"/\").map(encodeURIComponent).join(\"/\"); } function kr(n) { return (t) => { const e = [], r = new Map(); const o = window.setInterval(function () { const t = e.shift(); if (t) { const [e, o] = t, i = addEmptyErrHandle(n(o)); r.set(e, i); } }, 1); function i() { window.clearInterval(o); } return (t.then(i, i), [e, r, t]); }; } function Ar(n) { const t = Math.random(); return ( (function (n, t, e) { const [r] = n; r.push([t, e]); })(n.container, t, n), (function (n, t, e) { let r; function o() { window.clearInterval(r); } const [, i, u] = n, c = new Promise((n, e) => { r = window.setInterval(function () { const r = i.get(t); if (r) return (i.delete(t), r.then(n, e)); }, 1); }); return (c.then(o, o), null == e || e.then(o, o), u.then(o, o), c); })(n.container, t, n.abort) ); } const Lr = /*#__PURE__*/ kr(Cr); function Cr(n) { return vr( n.url, () => (function ({ url: n, method: t = \"get\", body: e, headers: r, withCredentials: o = false, timeout: i, responseFormat: u, abort: c, }) { return new Promise((s, a) => { if ( (function (n) { if (URL.prototype) try { return (new URL(n, location.href), false); } catch (t) { if (t instanceof Error && \"TypeError\" === t.name) return true; throw t; } })(n) ) throw Pr(\"InvalidURLError\", \"Invalid URL\"); const l = new XMLHttpRequest(); try { l.open(t, n, true); } catch (f) { if ( f instanceof Error && /violate.+content security policy/i.test(f.message) ) throw Tr(); throw f; } if ( ((l.withCredentials = o), (l.timeout = void 0 === i ? 0 : Math.max(i, 1)), \"binary\" === u && (l.responseType = \"arraybuffer\"), r) ) for (const n of Object.keys(r)) l.setRequestHeader(n, r[n]); ((l.onload = () => s( (function (n) { return { body: n.response, status: n.status, statusText: n.statusText, getHeader: (t) => (function (n, t) { const e = new RegExp( `^${((r = t), r.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&\"))}: (.*)$`, \"im\", ).exec(n); var r; return e ? e[1] : void 0; })(n.getAllResponseHeaders(), t), }; })(l), )), (l.ontimeout = () => a(Pr(\"TimeoutError\", \"The request timed out\"))), (l.onabort = () => a(Pr(\"AbortError\", \"The request is aborted\"))), (l.onerror = () => a( Pr( \"TypeError\", navigator.onLine ? \"Connection error\" : \"Network offline\", ), )), l.send( (function (n) { const t = () => { try { return (new Blob([]), false); } catch (n) { return true; } }; if (n instanceof ArrayBuffer) { if (!t()) return new Uint8Array(n); } else if ( (null == n ? void 0 : n.buffer) instanceof ArrayBuffer && t() ) return n.buffer; return n; })(e), ), null == c || c .catch(() => { }) .then(() => { ((l.onabort = null), l.abort()); })); }); })(n), () => { throw Tr(); }, n.abort, ); } function Pr(n, t) { const e = new Error(t); return ((e.name = n), e); } function Tr() { return Pr(\"CSPError\", \"The request is blocked by the CSP\"); } function xr(n, t, ...e) { n && o(() => { const r = t(...e); void 0 !== r && n(r); }); } async function Nr(n, t, e, r, o) { let i; xr(n, t); try { i = await o(); } catch (u) { throw (xr(n, r, u), u); } return (xr(n, e, i), i); } function Vr(n) { const t = n; return !!t.getCallId && \"string\" == typeof t.getCallId; } function Mr(n) { const t = n; return !!t.collectCallId && \"string\" == typeof t.collectCallId; } function collectSomeKeys5_maybe_new_api() { const windowObj = window, navigatorObj = navigator; return ( countOfNotNullObj_([ \"maxTouchPoints\" in navigatorObj, \"mediaCapabilities\" in navigatorObj, \"PointerEvent\" in windowObj, \"visualViewport\" in windowObj, \"onafterprint\" in windowObj, ]) >= 4 ); } function collectSomeKeys4_related_to_modern_api() { var n; const windowObj = window; return ( countOfNotNullObj_([ \"Iterator\" in windowObj, // ES6 windowObj.Error && \"isError\" in windowObj.Error, windowObj.Atomics && \"pause\" in windowObj.Atomics, (null === (n = windowObj.Document) || void 0 === n ? void 0 : n.prototype) && \"fragmentDirective\" in windowObj.Document.prototype, windowObj.CSSRule && !(\"UNKNOWN_RULE\" in windowObj.CSSRule), !(\"SVGDocument\" in windowObj), ]) >= 4 ); } function collectSomeKeys3_new_api() { const windowObj = window; return ( countOfNotNullObj_([ !(\"PushManager\" in windowObj), !(\"AudioBuffer\" in windowObj), !(\"RTCPeerConnection\" in windowObj), !(\"geolocation\" in navigator), !(\"ServiceWorker\" in windowObj), ]) >= 3 ); } function collectSomeKeys2_very_new_api() { // 这几个api都很新 const windowObj = window; return ( countOfNotNullObj_([ \"ClipboardItem\" in windowObj, \"PerformanceEventTiming\" in windowObj, \"RTCSctpTransport\" in windowObj, ]) >= 2 ); } function Br(n, t, e, r, o = Mt) { const i = o() % (e + 1), u = convertToIUint8Array(n), c = 1 + t.length + 1 + i + r + u.length, s = new ArrayBuffer(c), a = new Uint8Array(s); let l = 0; const f = o(); a[l++] = f; for (const d of t) a[l++] = f + d; a[l++] = f + i; for (let d = 0; d < i; ++d) a[l++] = o(); const m = new Uint8Array(r); for (let d = 0; d < r; ++d) ((m[d] = o()), (a[l++] = m[d])); for (let d = 0; d < u.length; ++d) a[l++] = u[d] ^ m[d % r]; return s; } function decode(u32Arr, Arr, e) { const r = () => { throw new Error(\"Invalid data\"); }, o = convertToIUint8Array(u32Arr); o.length < Arr.length + 2 && r(); for (let f = 0; f < Arr.length; ++f) E(o[1 + f], o[0]) !== Arr[f] && r(); const i = 1 + Arr.length, u = E(o[i], o[0]); o.length < i + 1 + u + e && r(); const c = i + 1 + u, s = c + e, a = new ArrayBuffer(o.length - s), l = new Uint8Array(a); for (let f = 0; f < l.length; ++f) l[f] = o[s + f] ^ o[c + (f % e)]; return a; } function get_cookie_value(n) { const t = `${n}=`; for (const e of document.cookie.split(\";\")) { let n = 0; for (; \" \" === e[n] && n < e.length;) ++n; if (e.indexOf(t) === n) return e.slice(n + t.length); } } function Xr(n, t, e, r) { const o = `${n}=${t}`, i = `expires=${new Date(Date.now() + 24 * e * 60 * 60 * 1e3).toUTCString()}`, u = r ? `domain=${r}` : \"\"; document.cookie = [o, \"path=/\", i, u, \"SameSite=Lax\"].join(\"; \"); } function Jr(n, t, e) { (zr((t) => { !(function (n, t) { Xr(n, \"\", -1, t); })(n, t); }), e < 0 || zr((r) => (Xr(n, t, e, r), get_cookie_value(n) === t))); } function zr(n) { const t = location.hostname, e = collectSomeKeys1_related_to_firefox(); (function (n, t) { let e = n.length - (\".\" === n.slice(-1) ? 1 : 0); do { if ( ((e = e > 0 ? n.lastIndexOf(\".\", e - 1) : -1), true === t(n.slice(e + 1))) ) return true; } while (e >= 0); return false; })(t, (r) => { if (!e || !/^([^.]{1,3}\\.)*[^.]+\\.?$/.test(r) || r === t) return n(r); }) || n(); } function qr(n, t) { (Jr(t, n, 365), to(t, n)); } function add_t(n) { return `${n}_t`; } function add_lr(n) { return `${n}_lr`; } function get_localStorage_value(n) { var t, e; try { return null !== (e = null === (t = null === localStorage || void 0 === localStorage ? void 0 : localStorage.getItem) || void 0 === t ? void 0 : t.call(localStorage, n)) && void 0 !== e ? e : void 0; } catch (r) { } } function to(n, t) { var e; try { null === (e = null === localStorage || void 0 === localStorage ? void 0 : localStorage.setItem) || void 0 === e || e.call(localStorage, n, t); } catch (r) { } } function eo() { return `js/${Ht}`; } const ro = [3, 7]; function oo(n, t) { const e = add_lr(n); if (0 === t.size) return; const r = io(e).filter((n) => !t.has(n[0])); 0 !== r.length ? to(e, JSON.stringify(r)) : (function (n) { var t; try { null === (t = null === localStorage || void 0 === localStorage ? void 0 : localStorage.removeItem) || void 0 === t || t.call(localStorage, n); } catch (e) { } })(e); } function io(n) { const t = get_localStorage_value(n); if (!t) return []; try { const n = t ? JSON.parse(t) : []; return Array.isArray(n) ? n : []; } catch (e) { return []; } } function uo(n) { return \"agentId\" in n; } function co(n, t, e, r) { const o = (function* (n, t, e) { let r = 0, o = 0; for (; r < n.length && o < t.length;) e(n[r], t[o]) ? (yield n[r], r++) : (yield t[o], o++); for (; r < n.length; r++) yield n[r]; for (; o < t.length; o++) yield t[o]; })( n.map((n) => ({ t: ho(n.time), s: \"visible\" === n.state ? \"v\" : \"h\" })), t, (n, t) => n.t < t.t, ), i = []; let u; const c = () => { 0 === i.length && void 0 !== u && i.push({ t: e, s: u }); }; for (; i.length < 100;) { const n = o.next(); if (n.done) break; const t = n.value, s = t.t, a = t.s; if (s > r) break; s < e ? (u = a) : a !== u && (c(), i.push(t), (u = a)); } return (c(), i); } function so(n) { const t = ao(n.map((n) => n.url).filter((n) => Boolean(n))); return n.map((e, r) => { const o = n.length > 1 && r < n.length - 1 && !(\"error\" in e); return fo( e.url, ho(e.startedAt), ho(e.finishedAt), o ? \"Unknown\" : e.error, t[e.url], ); }); } function ao(n) { const t = {}; return ( new Set(n).forEach((n) => { const e = (function (n) { if (!URL.prototype) return n; try { return new URL(n, window.location.origin).toString(); } catch (t) { return n; } })(n), r = performance.getEntriesByName(e, \"resource\"); t[n] = r; }), t ); } function lo(n, t, e, r, o, i) { var u; const c = []; for (const s of n) { const n = s.event; if (n.e !== e && n.e !== r && n.e !== o) continue; if (n.stage !== i) continue; (c[(u = n.tryNumber)] || (c[u] = {}))[n.e] = s; } return c .map((n) => { var i, u, c, s, a, l; const f = null === (i = n[e]) || void 0 === i ? void 0 : i.timestamp, d = null !== (c = null === (u = n[r]) || void 0 === u ? void 0 : u.timestamp) && void 0 !== c ? c : null === (s = n[o]) || void 0 === s ? void 0 : s.timestamp, m = null === (a = n[e]) || void 0 === a ? void 0 : a.event.url, v = null === (l = n[o]) || void 0 === l ? void 0 : l.event.error; return f && d && m ? fo(m, f, d, v, t[m]) : null; }) .filter((n) => Boolean(n)); } function fo(n, t, e, r, o) { const i = (function (n, t, e) { if (!n) return; let r; for (let o = n.length - 1; o >= 0; o--) { const i = n[o]; if (i.startTime < t - 1) break; i.responseEnd n.key).filter((n) => Boolean(n)), sa: so( null !== (w = null == W ? void 0 : W.attempts) && void 0 !== w ? w : [], ), ls: P[0].timestamp, le: P[1].timestamp, ca: lo(C, Y, 9, 10, 11), ss: P[12].timestamp, se: null !== (y = null == $ ? void 0 : $.timestamp) && void 0 !== y ? y : null, sd: vo(P), gs: null !== (E = null === (b = P[3]) || void 0 === b ? void 0 : b.timestamp) && void 0 !== E ? E : null, ge: null !== (R = null == T ? void 0 : T.timestamp) && void 0 !== R ? R : null, cs: null !== (I = null === (S = P[21]) || void 0 === S ? void 0 : S.timestamp) && void 0 !== I ? I : null, ce: null !== (k = null == O ? void 0 : O.timestamp) && void 0 !== k ? k : null, fa: lo(C, Y, 18, 19, 20, 0), ia: lo(C, Y, 18, 19, 20, 1), vs: co( null !== (A = null == W ? void 0 : W.visibilityStates) && void 0 !== A ? A : [], r, H, null !== (L = null == T ? void 0 : T.timestamp) && void 0 !== L ? L : null == O ? void 0 : O.timestamp, ), ab: P[1].event.ab, ao: D, or: Z, }; n(X, M); } return ( logDocumentIsVisable(), { addEvent: c, destroy: () => { ((o = true), i()); }, } ); })((n, t) => { !(function (n, t) { const e = add_lr(t), r = io(e) || []; r.splice(0, r.length - 2); const o = Br(ne(n), ro, 3, 7); (r.push([n.ri, R(o)]), to(e, JSON.stringify(r))); })(n, t); }); let t = new Set(); return { toRequest(n) { const e = (function (n) { const t = add_lr(n), e = io(t) || [], r = []; return ( e.forEach((n) => { try { const t = JSON_parser(decode(base64Encode(n[1]), ro, 7)); r.push(t); } catch (t) { } }), r ); })(n); return ((t = new Set(e.map((n) => n.ri))), { lr: e }); }, onGetResponse(n, e) { oo(e, t); }, onCollectResponse(n) { oo(n, t); }, addEvent: n.addEvent, destroy: n.destroy, }; }; function ko(t, e, r, o = 1 / 0, u) { const c = { failedAttempts: [] }, [s, a] = (function (n) { const t = (function (n) { const t = [...n]; return { current: () => t[0], postpone() { const n = t.shift(); void 0 !== n && t.push(n); }, exclude() { t.shift(); }, }; })(n), e = f(200, 1e4), r = new Set(); return [ t.current(), (n, o, i) => { let u; if (o) ((u = (function (n) { const t = n.getHeader(\"retry-after\"); if (!t) return; if (/^\\s*\\d+(\\.\\d+)?\\s*$/.test(t)) return 1e3 * parseFloat(t); const e = new Date(t); return isNaN(e) ? void 0 : e.getTime() - Date.now(); })(o)), void 0 !== u ? t.postpone() : t.exclude()); else if ( i instanceof Error && (\"CSPError\" === i.name || \"InvalidURLError\" === i.name) ) (t.exclude(), (u = 0)); else { const e = Date.now() - n.getTime() < 50, o = t.current(); (o && e && !r.has(o) && (r.add(o), (u = 0)), t.postpone()); } const c = t.current(); return void 0 === c ? void 0 : [c, null != u ? u : n.getTime() + e() - Date.now()]; }, ]; })(t), l = ((d = [ null == u ? void 0 : u.then( (n) => (c.aborted = { resolve: true, value: n }), (n) => (c.aborted = { resolve: false, error: n }), ), (async () => { if (void 0 === s) return; let t = s; for (let s = 0; s < o; ++s) { const o = new Date(); let f, d; try { f = await i(() => e(t, s, u), u); } catch (l) { ((d = l), c.failedAttempts.push({ level: 0, endpoint: t, error: l })); } if (f) { const n = r(f); if (\"result\" in n) { c.result = n.result; break; } if ( (c.failedAttempts.push({ level: 1, endpoint: t, error: n.error }), n.stop) ) break; } const m = a(o, f, d); if (!m) break; (await i(setTimeOutRun(m[1]), u), (t = m[0])); } })(), ]), Promise.race(d.filter((n) => !!n))).then(() => c); var d; return { then: l.then.bind(l), current: c }; } const Ao = /\\(([^(^\\s^}]+):(\\d)+:(\\d)+\\)/i, Lo = /@([^(^\\s^}]+):(\\d)+:(\\d)+/i; function Co() { const n = new Error(), t = (function (n) { if (n.fileName) return n.fileName.split(\" \")[0]; return n.sourceURL ? n.sourceURL : null; })(n); if (t) return t; if (n.stack) { const t = (function (n) { const [t, e] = n.split(\"\\n\"), r = Ao.exec(e) || Lo.exec(t); return r ? r[1] : void 0; })(n.stack); if (t) return t; } return null; } function si(n) { const t = {}; for (const e of Object.keys(n)) { const r = n[e]; if (r) { const n = \"error\" in r ? ai(r.error) : r.value; t[e] = n; } } return t; } function ai(n) { return { e: li(n) }; } function li(n) { let t; try { n && \"object\" == typeof n && \"message\" in n ? ((t = String(n.message)), \"name\" in n && (t = `${n.name}: ${t}`)) : (t = String(n)); } catch (n) { t = `Code 3017: ${n}`; } return Ve(t, 500); } function runner2(n) { return do_a_then_pass_res_to_b(n, (n) => ({ s: 0, v: n })); } function runner1(func, err_code) { return do_a_then_pass_res_to_b(func, (n) => ({ s: null == n ? err_code : 0, v: null != n ? n : null })); } function check_res_is_err_code(n) { return do_a_then_pass_res_to_b(n, (n) => \"number\" == typeof n ? { s: n, v: null } : { s: 0, v: n }, ); } async function hi({ modules: n, components: t = {}, customComponent: e, apiKey: r, tls: o, tag: i, extendedResult: u, exposeComponents: c, linkedId: s, algorithm: a, imi: l, storageKey: f, products: d, urlHashing: m, ab: v, fast: h, requestId: p, }) { const g = { c: r, t: pi(i), cbd: u ? 1 : void 0, lid: s, a: a, m: l.m, l: l.l, ec: c ? 1 : void 0, mo: n.map((n) => n.key).filter((n) => Boolean(n)), pr: d, s56: o, s67: e ? { s: 0, v: e } : { s: -1, v: null }, sc: gi(), uh: wi(m), gt: 1, ab: v, hu: h ? 0 : p ? 1 : void 0, ri: p, ...si(t), }; return ( await Promise.all( n.map(async ({ toRequest: n }) => { n && Object.assign(g, await n(f, m)); }), ), g ); } function pi(n) { return n && \"object\" == typeof n ? n : null != n ? { tag: n } : void 0; } function gi() { const n = Co(); return { u: n ? Ve(n, 1e3) : null }; } function wi(n) { if (n) return { p: n.path ? 1 : void 0, q: n.query ? 1 : void 0, f: n.fragment ? 1 : void 0, }; } async function yi(n) { if (!bi()) return [false, n]; const [t, e] = (function () { try { return [true, new CompressionStream(\"deflate-raw\")]; } catch (n) { return [false, new CompressionStream(\"deflate\")]; } })(), r = await (async function (n, t) { const e = t.writable.getWriter(); (e.write(n), e.close()); const r = t.readable.getReader(), o = []; let i = 0; for (; ;) { const { value: n, done: t } = await r.read(); if (t) break; (o.push(n), (i += n.byteLength)); } if (1 === o.length) return o[0]; const u = new Uint8Array(i); let c = 0; for (const s of o) (u.set(s, c), (c += s.byteLength)); return u; })(n, e), o = t ? r : (function (n) { return new Uint8Array(n.buffer, n.byteOffset + 2, n.byteLength - 6); })(r); return [true, o]; } function bi() { return \"undefined\" != typeof CompressionStream; } const Ei = [3, 13], Ri = [3, 14]; function Si(n, t) { return Br(n, t ? Ri : Ei, 3, 9); } function Ii(n, t) { return decode(n, t ? Ri : Ei, 9); } function ki(n) { return n.byteLength > 1024 && bi(); } async function Ai(n, t, e, r, o) { if (0 === n.length) throw new TypeError(\"The list of endpoints is empty\"); const i = n.map((n) => (function (n, { apiKey: t, integrations: e = [] }) { return Sr(n, { ci: eo(), q: t, ii: e }); })(n, t), ), u = await hi(t), c = ne(u), s = t.fast ? 0 : 1; return await Nr( o, () => ({ e: 15, stage: s, body: u, isCompressed: ki(c) }), (n) => ({ e: 16, stage: s, result: n }), (n) => ({ e: 17, stage: s, error: n }), async () => (function ({ result: n, failedAttempts: t, aborted: e }) { if (n) return n; const r = t[0]; if (!r) throw e && !e.resolve ? e.error : new Error(\"aborted\"); const { level: o, error: i } = r; if (0 === o && i instanceof Error) { switch (i.name) { case \"CSPError\": throw new Error(xe); case \"InvalidURLError\": throw new Error(Ne); case \"AbortError\": throw new Error(Oe); } throw new Error(Te); } throw i; })( await ko( i, Li.bind(null, c, o, s, e), ze.bind(null, t.modules, !!t.extendedResult, t.storageKey), 1 / 0, r, ), ), ); } function Li(n, t, e, r, o, i, u) { return Nr( t, () => ({ e: 18, stage: e, tryNumber: i, url: o }), ({ status: n, getHeader: t, body: r, bodyData: o, wasSecret: u }) => ({ e: 19, stage: e, tryNumber: i, status: n, retryAfter: t(\"retry-after\"), body: null != o ? o : r, wasSecret: u, }), (n) => ({ e: 20, stage: e, tryNumber: i, error: n }), async () => { const t = await (async function ({ body: n, ...t }) { const [e, r] = ki(n) ? await yi(n) : [false, n], o = await Ar({ ...t, body: Si(r, e), responseFormat: \"binary\" }); let i = o.body, u = false; try { ((i = Ii(i, false)), (u = true)); } catch (c) { } return { ...o, body: i, wasSecret: u }; })({ url: o, method: \"post\", headers: { \"Content-Type\": \"text/plain\" }, body: n, withCredentials: true, abort: u, container: r, }); return (function (n) { let t; try { t = JSON_parser(n.body); } catch (e) { } return { ...n, bodyData: t }; })(t); }, ); } function taskRunnerInit(modules, optimizeLevel, context) { const options = { ...context, cache: {} }, [stage3, stage1_and_2] = (function (modules) { const stage1 = {}, stage2 = {}, stage3 = {}; for (const { sources: i } of modules) i && (Object.assign(stage1, i.stage1), Object.assign(stage2, i.stage2), Object.assign(stage3, i.stage3)); const o = stage2; return (Object.assign(o, stage3), [stage1, o]); })(modules), opt = (function (n) { return n ? 1e5 : 50; })(optimizeLevel), taskPromises = runStageTasks(stage3, context, [], opt), taskPromises2 = addEmptyErrHandle(runWhenNotBusy(8).then(() => runStageTasks(stage1_and_2, context, [], opt))); return async () => { const [n, t] = await Promise.all([taskPromises(), taskPromises2.then((n) => n())]); !(function (n) { const { si: t, action_queue: e } = n; for ( t && t.parentNode && t.parentNode.removeChild(t), n.si = null, n.sandbox_iframe_window = null, n.iframe_promise = null; e.length > 0; ) { const n = e.shift(); n && n.reject(new Error(\"Iframe cleanup called\")); } n.ipq = false; })(context.iframe_sandbox); const e = t; return (Object.assign(e, n), e); }; } function getPropertyNameByHash(Obj, hash) { let e = Obj; for (; e;) { const propertyNames = Object.getOwnPropertyNames(e); for (let e = 0; e < propertyNames.length; e++) { const r = propertyNames[e]; if (getHash(r) == hash) return r; } e = Object.getPrototypeOf(e); } return \"\"; } function get_property_byHash_then_bind(obj, hash) { const e = obj[getPropertyNameByHash(obj, hash)]; return \"function\" == typeof e ? e.bind(obj) : e; } function encrypted_msg_getter(u32Arr, idx) { let e; return (r) => ( e || (e = (function (n, t) { return JSON_parser(decode(new Uint32Array(n), [], t)); })(u32Arr, idx)), getObjectKeys(e[r]) ); } function _i(arr, str_getter, e) { // e= 1 or 2 if (arr.length !== str_getter.length || arr.length !== e.length) throw new Error( \"Invalid encryption configuration: all input arrays must have the same length.\", ); const r = new Array(arr.length).fill(void 0); return (idx) => { var tmp; if (r.every((n) => null === n)) return null; console.log(arr); for (let u = 0; u < arr.length; u++) { console.log(str_getter[u]()); console.log(e[u]); console.log(\"decoder: \", Enc_decoder(arr[u], str_getter[u], e[u])); if ( null !== r[u] && (r[u] || (r[u] = Enc_decoder(arr[u], str_getter[u], e[u])), null !== r[u]) ) return getObjectKeys(null === (tmp = r[u]) || void 0 === tmp ? void 0 : tmp[idx]); } return null; }; } function Enc_decoder(buffer, input_str_getter, e) { const input = convertToUint8Array(input_str_getter()); try { return JSON_parser( (function (u32Arr, input, e) { const r = convertToIUint8Array(u32Arr), o = new ArrayBuffer(r.length - e), i = new Uint8Array(o); for (let u = 0; u < r.length; ++u) i[u] = r[u] ^ input[u % input.length]; console.log(\"decrypted: \", convertToString(o)); return o; })(new Uint32Array(buffer), input, e), ); } catch (o) { if (isErr(o) && \"SyntaxError\" === o.name) return null; throw o; } } var Ni = /*#__PURE__*/ encrypted_msg_getter( [ 3237452699, 2611787672, 3045311674, 2962332150, 4003383289, 4090353905, 3805249708, 3028587956, 2899958253, 2946027702, 4002601983, 4204452091, 4039413417, 3970602410, 3953912762, 2631244730, 3973421252, 2844251834, 2861027766, 2946406891, 3050675130, 3806041579, 2961425392, 4023946731, 3800865722, 4208313581, 2776941242, 3806041513, 4208313085, 2743259834, 3806041513, 4208314361, 3012023994, 3968505257, 3045300922, 2799294954, 4001684968, 2648037617, ], 4, ); const ji = [202, 206]; function Vi(n) { const t = function (n, t) { return n(t); }, e = function (n, t) { return n < t; }, r = function (n, t) { return n / t; }, o = function (n, t, e) { return n(t, e); }, i = function (n, t) { return n + t; }, u = function (n, t) { return n + t; }, c = function (n, t) { return n + t; }, s = function (n, t) { return n - t; }, a = function (n, t, e, r) { return n(t, e, r); }, l = function (n, t) { return n(t); }, f = function (n, t) { return n(t); }, d = function (n, t) { return n + t; }, m = function (n, t) { return n + t; }, v = function (n, t) { return n + t; }, h = function (n, t) { return n + t; }, p = function (n, t) { return n(t); }, g = function (n, t, e) { return n(t, e); }, y = t(murmurHash3, n), b = new Uint8Array(16); for (let w = 0; e(w, y.length); w += 2) b[r(w, 2)] = o(parseInt, i(i(u(i(\"\", y[w]), \"\"), y[c(w, 1)]), \"\"), 16); const E = t(R, b), S = a(Fi, b[o(parseInt, y[s(y.length, 1)], 16)], 8, 22), I = E.slice(0, Math.min(s(E.length, 2), S)), k = o(Wi, l(convertToUint8Array, I), ji), A = l(R, l(Di, f(getHash_, k))).slice(0, 2); return o( Rr, n, g( Mi, d(m(v(h(\"\", I), \"\"), A), \"\") .replace(new RegExp(l(Ni, 1), \"g\"), \"-\") .replace(new RegExp(p(Ni, 2), \"g\"), \"_\"), b, ), ); } function Mi(n, t) { const e = function (n, t) { return n < t; }, r = function (n, t, e, r) { return n(t, e, r); }, o = function (n, t) { return n & t; }, i = function (n, t) { return n + t; }; let u = 0, c = 0, s = \"\"; for (; e(u, n.length);) ((c = r(Fi, t[o(u, 15)], 4, 7)), (s += n.slice(u, i(u, c))), (s += \"/\"), (u += c)); return s.slice(0, -1); } function Fi(n, t, e) { const r = function (n, t) { return n + t; }, o = function (n, t) { return n * t; }, i = function (n, t) { return n / t; }, u = function (n, t) { return n - t; }; return r(t, Math.floor(o(i(n, 256), r(u(e, t), 1)))); } function Wi(n, t) { const e = function (n, t) { return n < t; }, r = function (n, t) { return n + t; }, o = (function (n, t) { return n + t; })(n.length, t.length), i = new Uint8Array(o); for (let u = 0; e(u, n.length); u++) i[u] = n[u]; for (let u = 0; e(u, t.length); u++) i[r(u, n.length)] = t[u]; return i; } function Di(n) { const t = function (n, t) { return n >> t; }, e = function (n, t) { return n >> t; }; return new Uint8Array([ (function (n, t) { return n >> t; })(n, 24), t(n, 16), e(n, 8), n, ]); } function Zi(n, t) { const e = function (n, t, e) { return n(t, e); }; return ( !!n && (function (n, t) { return n === t; })(e(get_property_byHash_then_bind, n, 3814588639), e(get_property_byHash_then_bind, t, 3814588639)) ); } function Hi(n) { const t = function (n, t) { return n(t); }, e = function (n, t) { return n !== t; }, r = function (n, t) { return n + t; }, o = function (n, t) { return n + t; }, i = function (n, t) { return n + t; }, u = function (n, t) { return n(t); }; let c = t(Ni, 3); return ( e(n, t(Ni, 4)) && (c = r(o(i(r(\"\", n), \".\"), c), \"\")), r(i(u(Ni, 5), c), \"/\") ); } function Gi(n) { const t = function (n, t) { return n + t; }, e = function (n, t) { return n(t); }; return t( t( \"\", (function (n, t) { return n(t); })(Ni, 6)[n], ), e(Ni, 7), ); } const Ui = /*#__PURE__*/ (() => ({ noop: [\"a\", \"b\"] }))(); function excuteTask(modules, t, e, apiKey, i, c, storageKey, integrations, imi, urlHashing, ab, p, g) { const w = 1e4, configs = { modules: modules, apiKey: apiKey, integrations: integrations, imi: imi, storageKey: storageKey, ab: ab, urlHashing: urlHashing, }; function b(n) { if (!g) return; const t = genRandomStrWrapper(8); switch (n) { case \"get\": return (function (n, t) { return (e) => { const r = { ...e, getCallId: t }; return n(r); }; })(g, t); case \"collect\": return (function (n, t) { return (e) => { const r = { ...e, collectCallId: t }; return n(r); }; })(g, t); } } const E = (n) => runCallbackWhenPageFocusedPromise(null != n ? n : w).then(() => Promise.reject(new Error(Pe))), R = async (t, e, r) => { var o; const i = E(t.timeout); r(await S(t, i, e)); for (const u of modules) null === (o = u.onCollectResponse) || void 0 === o || o.call(u, storageKey); }, S = async ({ timeout: n = 1e4, tag: t, linkedId: e }, r, o) => { const i = addEmptyErrHandle(Promise.all([_(o), O(n, false, o)])), [c, s] = await Promise.race([r, i]), a = await hi({ ...configs, components: c, tag: t, tls: s, linkedId: C(e) }); return await (async function (n, t, e) { const r = [eo(), t], o = ne(r), i = ne(n), [u, c] = ki(i) ? await yi(i) : [false, i], s = Si(c, u); return ( xr(e, () => ({ e: 24, agentMetadata: r, body: n, isCompressed: u })), `${I(o)}:${I(s)}` ); })(a, configs.integrations, o); }, k = async (n, t, e) => { const r = s(); try { const o = Lr(r), i = E(n.timeout), u = L(n, o, t), c = await A(o, i, t); c ? (e(c), await u(c.requestId, i)) : e(await u(void 0, i)); } finally { r.resolve(); } }, A = async (n, t, e) => { if (!p) return; const r = await T(); let o = false; t.catch(() => (o = true)); try { return await Ai(i, { ...configs, tls: r, fast: true }, n, t, e); } catch (u) { if (o) throw u; return void ((isErr(u) && u.message === Be) || console.warn(u)); } }, L = ( { timeout: n = 1e4, tag: t, linkedId: e, disableTls: r, extendedResult: o, exposeComponents: s, environment: a, products: l, }, f, d, ) => { const m = addEmptyErrHandle(Promise.all([_(d), O(n, r, d)])); return async (n, r) => { const [u, v] = await Promise.race([r, m]); return await Ai( i, { ...configs, components: u, customComponent: a, tag: t, tls: v, linkedId: C(e), extendedResult: o, exposeComponents: s, algorithm: c, products: P(l, \"products\"), requestId: n, }, f, r, d, ); }; }, T = () => (null == e ? void 0 : e(0, 50, false, void 0)), O = (n, t, r) => (null == e ? void 0 : e(0.1 * n, 0.4 * n, t, r)), _ = async (n) => { try { const e = await t(); return (xr(n, () => ({ e: 13, result: e })), e); } catch (e) { throw (xr(n, () => ({ e: 14, error: e })), e); } }; return { get: (n = {}) => { const t = b(\"get\"); return Nr( t, () => ({ e: 3, options: n }), (n) => ({ e: 4, result: n }), (n) => ({ e: 5, error: n }), () => a((e) => k(n, t, e)), ); }, collect: (n = {}) => { const t = b(\"collect\"); return Nr( t, () => ({ e: 21, options: n }), (n) => ({ e: 22, result: n }), (n) => ({ e: 23, error: n }), () => a((e) => R(n, t, e)), ); }, }; } function $i() { const n = /{(.*?)}/.exec(location.hash); return !!n && 3025844545 === getHash(n[1]); } const runService = async function (configs) { const t = (function (n) { const t = n.filter((n) => !!n); return t.length ? (...n) => { for (const e of t) o(() => e(...n)); } : void 0; })([ $i() && cr(), ...((null == configs ? void 0 : configs.modules) || []).map((n) => n.addEvent), ]), e = t && (function (n, t) { return (e) => { const r = { ...e, agentId: t }; return n(r); }; })(t, genRandomStrWrapper(8)), [r] = await Nr( e, () => ({ e: 0, version: Ht, options: configs }), ([, n]) => ({ e: 1, ab: n }), (n) => ({ e: 2, error: n }), () => { var t; const { token: token, apiKey: apiKey = token, region: region = \"us\", tlsEndpoint: tlsEndpoint = Bt, disableTls: disableTls, storageKey: storageKey = Yt, endpoint: endpoint = Gt, te: te = Ut, integrationInfo: integrationInfo = [], algorithm: algorithm, imi: imi = { m: \"s\" }, stripUrlParams: stripUrlParams, urlHashing: urlHashing = $t(stripUrlParams), modules: modules, abTests: abTests = {}, externalABSelections: externalABSelections = {}, optimizeRepeatedVisits: optimizeRepeatedVisits = false, aggressiveOptimization: aggressiveOptimization = false, } = configs; if (!apiKey || \"string\" != typeof apiKey) throw new Error(\"API key required\"); const E = (function (n, t, e) { const r = { ...e }, o = Object.entries(n); for (const [u, c] of o) { const n = t[u]; if (n) try { r[u] = Dt(n); continue; } catch (i) { console.error(i); } r[u] = Dt(c); } return r; })( (function (n) { const t = { ...Ui }; for (const e of n) Object.assign(t, e.ab); return t; })(modules), abTests, externalABSelections, ), R = (function (n, t) { const e = function (n, t, e) { return n(t, e); }, r = function (n, t) { return n(t); }; return (Array.isArray(n) ? n : [n]).map((n) => e(Zi, n, Gt) ? r(Hi, t) : r(String, n), ); })(endpoint, region), S = null === (t = (function (n) { for (const t of n) if (t.tls) return t.tls; })(modules)) || void 0 === t ? void 0 : t(tlsEndpoint, R, apiKey, disableTls, void 0, e); xr(e, () => ({ e: 12 })); const I = (function (n, t) { const e = function (n, t) { return n(t); }, r = function (n, t) { return n(t); }; return ((o = n), Zi(o, Ut) ? e(Gi, t) : r(String, n)); var o; })(te, region), sandbox = { action_queue: [], ipq: false, si: null, sandbox_iframe_window: null, iframe_promise: null, dc: { adb: 0, crs: 0, asib: 0 }, }; initSandbox(sandbox); return [ excuteTask( modules, taskRunnerInit(modules, aggressiveOptimization, { urlHashing: urlHashing, ab: E, te: I, iframe_sandbox: sandbox }), S, apiKey, R, C(algorithm), storageKey, integrationInfo, imi, urlHashing, E, optimizeRepeatedVisits, e, ), E, ]; }, ); return r; }, Xi = function (n, t = {}) { const { storageKey: e = Yt, do: r } = t; try { const t = (function (n) { const t = base64Encode(n); let e = t; try { e = Ii(t, false); } catch (r) { } try { return JSON_parser(e); } catch (o) { } return null; })(n); null !== t ? (t.visitorToken && qr(t.visitorToken, add_t(e)), er(t.notifications), xr(r, () => ({ e: 25, result: { response: t } }))) : xr(r, () => ({ e: 25, result: { error: new Error(\"Failed to decode response\") }, })); } catch (o) { throw ( xr(r, () => ({ e: 25, result: { error: o instanceof Error ? o : new Error(String(o)) }, })), tr(je, void 0, o) ); } }, AdBlocker_test = /*#__PURE__*/ runner1(AdBlocker_test_worker, -1), font_width_test = /*#__PURE__*/ runner2(fontWidthTest), audio_data_collector_ = /*#__PURE__*/ do_a_then_pass_res_to_b(audio_data_collector, (n) => -1 === n || -2 === n || -3 === n ? { s: n, v: null } : { s: 0, v: n }, ), getScreenSize_worker = /*#__PURE__*/ do_a_then_pass_res_to_b(getCheckScreenSizeFunc, (n) => ({ s: 0, v: n.map((n) => (null === n ? -1 : n)), })), oscpu = /*#__PURE__*/ runner1(get_oscpu, -1), language = /*#__PURE__*/ runner2(get_language), get_color_depth_ = /*#__PURE__*/ runner1(colorDepth, -1), get_deviceMemory = /*#__PURE__*/ runner1(deviceMemory, -1), get_H_W_ = /*#__PURE__*/ do_a_then_pass_res_to_b(get_H_W, (n) => ({ s: 0, v: n.map((n) => (null === n ? -1 : n)), })), get_hardwareConcurrency = /*#__PURE__*/ runner1(hardwareConcurrency, -1), timezone = /*#__PURE__*/ runner2(get_timezone), sessionStorage_ = /*#__PURE__*/ runner2(has_sessionStorage), localStorage_ = /*#__PURE__*/ runner2(has_localStorage), openDatabase = /*#__PURE__*/ runner2(has_openDatabase), get_cpuClass_ = /*#__PURE__*/ runner1(get_cpuClass, -1), is_ipad_or_iphone_ = /*#__PURE__*/ runner1(is_ipad_or_iphone, -1), plugins = /*#__PURE__*/ runner1(get_plugins, -1), canvas_test_worker = /*#__PURE__*/ do_a_then_pass_res_to_b( () => draw_canvas_test(), (n) => { const { geometry: geometry, text: text } = n, r = \"unsupported\" === geometry ? -1 : \"unstable\" === geometry ? -2 : 0; return { s: r, v: { ...n, geometry: 0 === r ? murmurHash3(geometry) : \"\", text: 0 === r ? murmurHash3(text) : \"\" }, }; }, ), touch_event = /*#__PURE__*/ runner2(test_touch_event), vendor = /*#__PURE__*/ runner2(get_vendor), vendor_keys = /*#__PURE__*/ runner2(test_vendor_keys), cookie = /*#__PURE__*/ runner2(test_cookie), color_gamut = /*#__PURE__*/ runner1(test_color_gamut, -1), invert_color_ = /*#__PURE__*/ runner1(invert_color, -1), force_color_ = /*#__PURE__*/ runner1(force_color, -1), monochrome_test = /*#__PURE__*/ runner1(monochrome, -1), perfer_contrast_ = /*#__PURE__*/ runner1(perfer_contrast, -1), motion_set_ = /*#__PURE__*/ runner1(motion_set, -1), transparency_set_ = /*#__PURE__*/ runner1(transparency_set, -1), dynamic_range_set_ = /*#__PURE__*/ runner1(dynamic_range_set, -1), Math_func_test_hash = /*#__PURE__*/ do_a_then_pass_res_to_b(Math_func_test, (n) => ({ s: 0, v: murmurHash3( Object.keys(n) .map((t) => `${t}=${n[t]}`) .join(\",\"), ), })), pdfViewerEnabled_ = /*#__PURE__*/ runner1(pdfViewerEnabled, -1), NaN_imply_ = /*#__PURE__*/ runner2(get_NaN_imply), attributionSourceId = /*#__PURE__*/ runner1(test_attributionSourceId, -1), getAudioLatency_ = /*#__PURE__*/ do_a_then_pass_res_to_b(getAudioLatency, (n) => -1 === n || -2 === n || -3 === n ? { s: n, v: null } : { s: 0, v: n }, ), webgl_context_info = /*#__PURE__*/ check_res_is_err_code(collect_webgl_context_info), webgl_infos = /*#__PURE__*/ do_a_then_pass_res_to_b(get_webgl_infos, (n) => { var t; if (\"number\" == typeof n) return { s: n, v: null }; const e = [\"32926\", \"32928\"], // GL_CURRENT_PROGRAM,GL_CURRENT_PROGRAM r = n.parameters.map((n) => { const [t, r, o] = n.split(\"=\", 3); return void 0 !== o || e.includes(r) ? `${t}(${r})=null` : `${t}=${r}`; }), o = n.extensionParameters.map((n) => { const [t, e, r] = n.split(\"=\", 3); return void 0 !== r && \"34047\" !== e ? `${t}(${e})=${r}` : `${t}=${e}`; }); return { s: 0, v: { contextAttributes: murmurHash3(n.contextAttributes.join(\"&\")), parameters: murmurHash3(r.join(\"&\")), parameters2: murmurHash3(n.parameters.join(\"&\")), shaderPrecisions: murmurHash3(n.shaderPrecisions.join(\"&\")), extensions: murmurHash3( (null === (t = n.extensions) || void 0 === t ? void 0 : t.join(\",\")) || \"\", ), extensionParameters: murmurHash3(o.join(\",\")), extensionParameters2: murmurHash3(n.extensionParameters.join(\"&\")), unsupportedExtensions: n.unsupportedExtensions, }, }; }), get_locale_ = /*#__PURE__*/ check_res_is_err_code(get_locale), run_IE_KEY_collector = /*#__PURE__*/ runner2(collectSomeKeys8_related_to_IE), run_Edge_KEY_collector = /*#__PURE__*/ runner2(collectSomeKeys9_related_to_Edge), run_Chrome_KEY_collector = /*#__PURE__*/ runner2(collectSomeKeys10_related_to_chrome), run_Apple_KEY_collector = /*#__PURE__*/ runner2(collectSomeKeys6_related_to_Apple), run_safari_KEY_collector = /*#__PURE__*/ runner2(collectSomeKeys7_related_to_safari), run_firefox_KEY_collector = /*#__PURE__*/ runner2(collectSomeKeys1_related_to_firefox), mobile = /*#__PURE__*/ runner2(test_mobile), new_api = /*#__PURE__*/ runner2(collectSomeKeys3_new_api), new_web_api = /*#__PURE__*/ runner2(test_new_webAPI); function Brave_detect() { const Window = window; if (!collectSomeKeys10_related_to_chrome()) return ret(false); try { if ( [66, 114, 97, 118, 101].map((n) => String.fromCharCode(n)).join(\"\") in Window //Brave ) return ret(true); const testCanvas = document.createElement(\"canvas\"); ((testCanvas.width = 4), (testCanvas.height = 4), (testCanvas.style.display = \"inline\")); const canvasData = testCanvas.toDataURL(); if (\"\" === canvasData) return ret(true); const r = base64Encode(canvasData.split(\",\")[1]), o = indexOfArrayInString(r, [73, 68, 65, 84, 24]); if (-1 === o) return ret(false); const i = indexOfArrayInString(r, [73, 69, 78, 68]); if (-1 === i) return ret(false); const u = r.slice(o + 5, i); return ret(1321 !== u.reduce((n, t) => n + t, 0)); } catch (t) { return ret(false); } } function ret(n) { return { s: 0, v: n }; } function test_theme_color() { return match_media(\"dark\") ? { s: 0, v: true } : match_media(\"light\") ? { s: 0, v: false } : { s: -1, v: null }; } function match_media(n) { return matchMedia(`(prefers-color-scheme: ${n})`).matches; } function getTime() { const now = Date.now(); return { s: 0, v: [cc(now), cc(now - 6e4 * new Date().getTimezoneOffset())] }; } function cc(n) { const t = Number(n); return isNaN(t) ? -1 : t; } const standard_font = [\"monospace\", \"sans-serif\", \"serif\"], test_font = [ \"sans-serif-thin\", \"ARNO PRO\", \"Agency FB\", \"Arabic Typesetting\", \"Arial Unicode MS\", \"AvantGarde Bk BT\", \"BankGothic Md BT\", \"Batang\", \"Bitstream Vera Sans Mono\", \"Calibri\", \"Century\", \"Century Gothic\", \"Clarendon\", \"EUROSTILE\", \"Franklin Gothic\", \"Futura Bk BT\", \"Futura Md BT\", \"GOTHAM\", \"Gill Sans\", \"HELV\", \"Haettenschweiler\", \"Helvetica Neue\", \"Humanst521 BT\", \"Leelawadee\", \"Letter Gothic\", \"Levenim MT\", \"Lucida Bright\", \"Lucida Sans\", \"Menlo\", \"MS Mincho\", \"MS Outlook\", \"MS Reference Specialty\", \"MS UI Gothic\", \"MT Extra\", \"MYRIAD PRO\", \"Marlett\", \"Meiryo UI\", \"Microsoft Uighur\", \"Minion Pro\", \"Monotype Corsiva\", \"PMingLiU\", \"Pristina\", \"SCRIPTINA\", \"Segoe UI Light\", \"Serifa\", \"SimHei\", \"Small Fonts\", \"Staccato222 BT\", \"TRAJAN PRO\", \"Univers CE 55 Medium\", \"Vrinda\", \"ZWAdobeF\", ]; async function Font_Test(n) { return { s: 0, v: await testFont(n) }; } function testFont(context) { return runActionInSandbox((sandbox_iframe, { document: documentObj }) => { const Body = documentObj.body; Body.style.fontSize = \"48px\"; const aTestDiv = documentObj.createElement(\"div\"); aTestDiv.style.setProperty(\"visibility\", \"hidden\", \"important\"); const offsetWidthRes = {}, i = {}, createSpanAndTestFont = (font) => { const atestSpan = documentObj.createElement(\"span\"), { style: o } = atestSpan; return ( (o.position = \"absolute\"), (o.top = \"0\"), (o.left = \"0\"), (o.fontFamily = font), (atestSpan.textContent = \"mmMwWLliI0O&1\"), aTestDiv.appendChild(atestSpan), atestSpan ); }, c = (n, t) => createSpanAndTestFont(`'${n}',${t}`), spans = standard_font.map(createSpanAndTestFont), a = (() => { const n = {}; for (const t of test_font) n[t] = standard_font.map((n) => c(t, n)); return n; })(); Body.appendChild(aTestDiv); for (let f = 0; f < standard_font.length; f++) ((offsetWidthRes[standard_font[f]] = spans[f].offsetWidth), (i[standard_font[f]] = spans[f].offsetHeight)); const l = test_font.filter((n) => { return ( (t = a[n]), standard_font.some( (n, e) => t[e].offsetWidth !== offsetWidthRes[n] || t[e].offsetHeight !== i[n], ) ); var t; }); return (Body.removeChild(aTestDiv), (Body.style.fontSize = \"\"), l); }, context.iframe_sandbox); } function measurePerformanceIntervals() { const { performance: performance } = window; if (!(null == performance ? void 0 : performance.now)) return { s: -1, v: null }; let t = 1, e = 1, now = performance.now(), o = now; for (let i = 0; i < 5e4; i++) if ((now = o) < (o = performance.now())) { const n = o - now; n > t ? n < e && (e = n) : n < t && ((e = t), (t = n)); } return { s: 0, v: [t, e] }; } var mc = /*#__PURE__*/ encrypted_msg_getter( [1910186786, 4206938268, 3099470367, 511281317, 2493621742, 2512262268], 6, ); // mc(0)= performance function get_jsHeapSizeLimit() { var performance, memory, equal = function (n, t) { return n === t; }, equal_ = function (n, t) { return n === t; }, fun_2arg_func = function (n, t, e) { return n(t, e); }; const i = equal( (memory = (function (n, t) { return n === t; })( (performance = window[ (function (n, t) { return n(t); })(mc, 0) ]), null, ) || equal_(performance, void 0) ? void 0 : fun_2arg_func(get_property_byHash_then_bind, performance, 3933025333)), // memory null, ) || equal_(memory, void 0) ? void 0 : (console.log(memory), fun_2arg_func(get_property_byHash_then_bind, memory, 3098533860)); // jsHeapSizeLimit return equal(i, null) || equal(i, void 0) ? { s: -1, v: null } : { s: 0, v: i }; } function draw_and_get_webgl_render_data({ cache: cache }) { const webgl_context = get_webgl_context(cache); return webgl_context ? ((function (webgl_context) { webgl_context.clearColor(0, 0, 1, 1); const t = webgl_context.createProgram(); if (!t) return; function e(e, code) { const shader = webgl_context.createShader(35633 - e); t && shader && (webgl_context.shaderSource(shader, code), webgl_context.compileShader(shader), webgl_context.attachShader(t, shader)); } (e( 0, \"attribute vec2 p;uniform float t;void main(){float s=sin(t);float c=cos(t);gl_Position=vec4(p*mat2(c,s,-s,c),1,1);}\", ), e(1, \"void main(){gl_FragColor=vec4(1,0,0,1);}\"), webgl_context.linkProgram(t), webgl_context.useProgram(t), webgl_context.enableVertexAttribArray(0)); const r = webgl_context.getUniformLocation(t, \"t\"), o = webgl_context.createBuffer(), i = 34962; (webgl_context.bindBuffer(i, o), webgl_context.bufferData(i, new Float32Array([0, 1, -1, -1, 1, -1]), 35044), webgl_context.vertexAttribPointer(0, 2, 5126, false, 0, 0), webgl_context.clear(16384), webgl_context.uniform1f(r, 3.65), webgl_context.drawArrays(4, 0, 3)); })(webgl_context), { s: 0, v: murmurHash3(webgl_context.canvas.toDataURL()) }) : { s: -1, v: null }; } function getVoiceInfoHash_worker_func(context) { return getVoiceInfoHash(context, CollectVoiceOnReturnHandler); } async function getVoiceInfoHash({ cache: Cache }, r) { const { speechSynthesis: speechSynthesis } = window; if (\"function\" != typeof (null == speechSynthesis ? void 0 : speechSynthesis.getVoices)) return { s: -1, v: null }; Cache.tts || (Cache.tts = (async function (speechSynthesis) { const getSpeechSynthesisVoiceArr = () => speechSynthesis.getVoices(); if ( (function (speechSynthesis) { return !speechSynthesis.addEventListener || (collectSomeKeys1_related_to_firefox() && collectSomeKeys3_new_api()); })(speechSynthesis) // 检查这几个特性是否存在 ) return { voiceArr: getSpeechSynthesisVoiceArr() }; const res = { voiceArr: null }; let i; try { await new Promise((resolve, reject) => { let s; const Localfunc = () => { const voiceArr = getSpeechSynthesisVoiceArr(); voiceArr.length ? ((res.voiceArr = voiceArr), null == s || s(), (s = tryRunFunc(resolve, 50))) : s || (s = runCallbackWhenPageFocused(resolve, 600)); }; ((i = addEventListenerWrapper(speechSynthesis, \"voiceschanged\", () => { try { Localfunc(); } catch (n) { reject(n); } })), Localfunc()); }); } finally { i && runCallbackWhenPageFocused(i, 1e4); } return res; })(speechSynthesis)); const ttsInfo = await Cache.tts; return () => (ttsInfo.v ? r(ttsInfo.v) : { s: -2, v: null }); } function CollectVoiceOnReturnHandler(n) { const t = (n) => n.replace(/([,\\\\])/g, \"\\\\$1\"), voiceInfos = n .map((voice) => [ t(voice.voiceURI), t(voice.name), t(voice.lang), voice.localService ? \"1\" : \"0\", voice.default ? \"1\" : \"0\", ].join(\",\"), ) .sort(); return { haveVoice: n.length ? 0 : 1, res: murmurHash3(JSON.stringify(voiceInfos)) }; } const platformInfoList = [ \"brands\", \"mobile\", \"platform\", \"platformVersion\", \"architecture\", \"bitness\", \"model\", \"uaFullVersion\", \"fullVersionList\", ]; async function getPlatformInfoFromList() { var n; const { userAgentData: userAgentData } = navigator; if (!userAgentData || \"object\" != typeof userAgentData) return { s: -1, v: null }; const e = {}, fail_List = []; return ( \"function\" == typeof userAgentData.getHighEntropyValues && (await Promise.all( platformInfoList.map(async (platformInfoKey) => { try { const r = (await userAgentData.getHighEntropyValues([platformInfoKey]))[platformInfoKey]; void 0 !== r && (e[platformInfoKey] = \"string\" == typeof r ? r : JSON.stringify(r)); } catch (o) { if (!(o instanceof Error && \"NotAllowedError\" === o.name)) throw o; fail_List.push(platformInfoKey); } }), )), { s: 0, res: { b: userAgentData.brands.map((n) => ({ b: n.brand, v: n.version })), m: userAgentData.mobile, p: null !== (n = userAgentData.platform) && void 0 !== n ? n : null, h: e, nah: fail_List, }, } ); } async function getIframeUrl({ urlHashing: context }) { const iframeUrlData = (function (windowObj) { var t, e; const r = []; let windowObj_ = windowObj; for (; ;) try { const n = null === (t = windowObj_.location) || void 0 === t ? void 0 : t.href, i = null === (e = windowObj_.document) || void 0 === e ? void 0 : e.referrer; if (void 0 === n || void 0 === i) return { s: 1, v: r }; r.push({ l: n, f: i }); const u = windowObj_.parent; if (!u || u === windowObj_) return { s: 0, v: r }; windowObj_ = u; } catch (i) { if (checkSecErr(i)) return { s: 1, v: r }; throw i; } })(window); return { ...iframeUrlData, v: await convertUrlToSHA256(iframeUrlData.v, context) }; } async function convertUrlToSHA256(n, t) { return Promise.all( n.map(async (n) => { const [e, r] = await Promise.all([sha256Hash(n.l, t), sha256Hash(n.f, t)]); return { l: e, f: r }; }), ); } function checkSecErr(n) { if (!n || \"object\" != typeof n) return false; const t = n; return ( !( (!collectSomeKeys8_related_to_IE() && !collectSomeKeys9_related_to_Edge()) || (\"Error\" !== t.name && \"TypeError\" !== t.name) || \"Permission denied\" !== t.message ) || \"SecurityError\" === t.name ); } function get_origin() { return (function ({ location: location, origin: origin }) { const e = location.origin, r = location.ancestorOrigins; let o = null; if (r) { o = new Array(r.length); for (let n = 0; n < r.length; ++n) o[n] = r[n]; } return { s: 0, v: { w: null == origin ? null : origin, l: null == e ? null : e, a: o }, }; })(window); } function get_eval_toString_length() { return { s: 0, v: eval.toString().length }; } function test_webdriver() { const { webdriver: n } = navigator; return null === n ? { s: -1, v: null } : void 0 === n ? { s: -2, v: null } : { s: 0, v: n }; } function test_storage_getDirectory() { const run2arg_func = function (n, t, e) { return n(t, e); }, equal = function (n, t) { return n === t; }, equal_ = function (n, t) { return n === t; }, run2arg_func_ = function (n, t, e) { return n(t, e); }; return run2arg_func_( prepareRace, (function (n, t, e) { return n(t, e); })(runCallbackWhenPageFocusedPromise, 250, { s: -2, v: null }), async () => { const storage = run2arg_func(get_property_byHash_then_bind, navigator, 1417288500); // storage return (equal(storage, null) || equal_(storage, void 0) ? void 0 : run2arg_func_(get_property_byHash_then_bind, storage, 3686698663)) // getDirectory ? await run2arg_func(get_property_byHash_then_bind, storage, 3686698663)().then( () => ({ s: 0, v: \"\" }), (n) => ({ s: 0, v: get_property_byHash_then_bind(n, 3065852031) }), ) : { s: -1, v: null }; }, ); } function maybeGetEncKey() { const n = new Image().style; console.log([getPropertyNameByHash((t = n), 2882756133), getPropertyNameByHash(t, 3858258232)]) return reshuffleStr( [getPropertyNameByHash((t = n), 2882756133), getPropertyNameByHash(t, 3858258232)], // webkitTapHighlightColor null [ 18, 23, 22, 11, 23, 17, 3, 20, 4, 22, 19, 11, 25, 13, 23, 22, 7, 7, 17, 18, 4, 18, 11, 8, 11, 8, 3, 5, 2, 4, 3, 3, 5, 6, 5, 3, 1, 2, 2, 0, 0, ], ); var t; } function Oc(n, t, e) { const r = getPropertyNameByHash(n, t); if (!r) return \"\"; const o = base64Encode(e), i = Array(o.length); for (let u = 0; u < o.length; u++) i[u] = o[u] ^ r.charCodeAt(u % r.length); return String.fromCharCode.apply(null, i); } function reshuffleStr(Strs, arr) { const e = Strs.join(\"\"), r = e.split(\"\"), res = Array(e.length); for (let i = 0; i < res.length; ++i) res[i] = r.splice(arr[i % arr.length], 1); return res.join(\"\"); } var get_encryted_obj_key = /*#__PURE__*/ _i( [ [ 290799128, 256122120, 104421910, 67116302, 755371265, 505093152, 152897830, 504707661, 470222364, 504898635, 1531393810, 35461445, 285283613, 151395398, 386279171, 454440300, 1259148302, 67715140, 117915663, 1445400833, 70599515, 280581, 270008841, 369435995, 272236574, 119803980, 704973062, 135268614, 184563807, 1026755337, 824180753, 521019142, 404440330, 1310525212, 689393240, 992889883, 118162967, 75079, 371069214, 14400, 67440946, 336725549, 100928582, 419697754, 37884160, 822483751, 151655985, 440867606, 34934535, 1544297499, 69023765, 1530421525, 521022789, 352788490, 152182535, 1095068179, 168111383, 102371362, 1379942426, 218301962, 410405200, 674697750, 150995736, 1460669954, 289295192, 422585355, 276197185, 1241580055, 503401029, 169544981, 956309037, 1628772625, 269702473, 1481182751, 12887, 860704273, 607786827, 1079856400, 370150428, 234881091, 407897606, 354309752, 1157892134, 252333381, 1264080656, 304025857, 1627786793, 302143352, 172563473, 34688007, 17172047, 337261841, 285893380, 117845831, 1448695310, 152569103, 1095068178, 68628788, 120395278, 352653340, 1245924639, 288361223, 2951185, 3425555, ], ], [maybeGetEncKey], [1], ); function get_encryted_obj_key0_() { return get_encryted_obj_key(0); } function jc() { const run_func_arg1 = function (n, t) { return n(t); }, a_is_instanceof_b = function (n, t) { return n instanceof t; }, equal = function (n, t) { return n === t; }, run_func_arg1_ = function (n, t) { return n(t); }; if ( !(function (n, t) { return n in t; })(run_func_arg1(get_encryted_obj_key, 1), window) ) return false; // false try { return (new window[run_func_arg1(get_encryted_obj_key, 1)](), true); } catch (o) { if (a_is_instanceof_b(o, Error) && equal(o.name, run_func_arg1_(get_encryted_obj_key, 2))) return false; throw o; } } async function Vc(n) { const t = function (n, t) { return n(t); }, e = function (n, t) { return n(t); }, r = function (n, t) { return n(t); }, o = function (n, t) { return n !== t; }, [i, u, c] = t(Mc, n); return o(u, 0) ? { n: i, l: u } : await new Promise((n) => { const o = function (n, t) { return e(n, t); }; c[r(get_encryted_obj_key, 3)]( (r) => { t(n, { n: i, l: r[e(get_encryted_obj_key, 4)] }); }, () => { o(n, { n: i, l: -1 }); }, ); }); } function Mc(n) { const t = function (n, t) { return n(t); }, e = function (n, t, e) { return n(t, e); }, r = function (n, t) { return n(t); }, o = function (n, t) { return n(t); }, i = function (n, t) { return n(t); }, u = function (n, t) { return n(t); }, c = function (n, t) { return n(t); }, s = function (n, t) { return n(t); }, a = function (n, t) { return n instanceof t; }, l = function (n, t) { return n === t; }, f = function (n, t) { return n(t); }, d = function (n, t) { return n !== t; }, m = function (n, t) { return n === t; }, v = function (n, t) { return n(t); }, h = function (n, t) { return n(t); }, p = function (n, t) { return n === t; }, g = function (n, t) { return n(t); }; var w; const [y] = n.split(\"/\").slice(-1), b = new window[t(get_encryted_obj_key, 1)](), E = e(getPropertyNameByHash, new window[t(get_encryted_obj_key, 5)](\"\")[r(get_encryted_obj_key, 6)](\"\"), 3626513111), R = document[o(get_encryted_obj_key, 7)](E); R[t(get_encryted_obj_key, 8)] = i(get_encryted_obj_key, 3); const S = new window[u(get_encryted_obj_key, 9)]([], n, c(get_encryted_obj_key, 10)); try { b[t(get_encryted_obj_key, 11)][s(get_encryted_obj_key, 12)](S); } catch (I) { if ( a(I, Error) && l(I.name, f(get_encryted_obj_key, 2)) && convertToIUint8Array( l((w = I[i(get_encryted_obj_key, 13)]), null) || m(w, void 0) ? void 0 : w.indexOf(c(get_encryted_obj_key, 14)), -1, ) ) return [y, -3, null]; throw I; } return ( (R[i(get_encryted_obj_key, 15)] = b[v(get_encryted_obj_key, 15)]), l(typeof R[h(get_encryted_obj_key, 16)], o(get_encryted_obj_key, 17)) ? [y, -4, null] : p(R[g(get_encryted_obj_key, 16)].length, 0) ? [y, -2, null] : [y, 0, R[c(get_encryted_obj_key, 16)][0]] ); } var Fc = /*#__PURE__*/ encrypted_msg_getter( [ 752472786, 243421427, 1304376727, 44907654, 246431386, 1168077535, 16463263, 1619723729, 1257995473, 1606171802, 1236083594, 66480798, 250966748, 1912304588, ], 4, ); async function s79_worker() { const runFunc = function (n) { return n(); }, runFunc_with1arg = function (n, t) { return n(t); }, runFunc_with2arg = function (n, t, e) { return n(t, e); }, runFunc_with2arg_ = function (n, t, e) { return n(t, e); }, i = (function (n) { return n(); })(get_encryted_obj_key0_); return i ? runFunc(jc) ? await runFunc_with2arg_(prepareRace, runFunc_with2arg(runCallbackWhenPageFocusedPromise, 350, { s: -2, v: null }), async () => ({ s: 0, v: await Promise.all(i.map(Vc)), })) : await runFunc_with2arg_(prepareRace, runFunc_with2arg(runCallbackWhenPageFocusedPromise, 350, { s: -1, v: null }), async () => ({ s: -1, v: await Promise.all([runFunc_with1arg(Dc, i[0])]), })) : await runFunc_with2arg(prepareRace, runFunc_with2arg(runCallbackWhenPageFocusedPromise, 350, { s: -3, v: null }), async () => ({ s: -3, v: await Promise.all([runFunc(Dc)]), })); } async function Dc(n = Fc(0)) { const t = function (n, t) { return n(t); }, e = function (n, t) { return n + t; }, r = function (n, t) { return n + t; }, o = function (n, t) { return n + t; }, i = function (n, t) { return n(t); }, u = function (n, t, e) { return n(t, e); }, c = function (n, t) { return n === t; }, s = function (n, t) { return n(t); }, a = function (n, t) { return n === t; }, l = function (n, t) { return n === t; }; var f, d; const [m] = n.split(\"/\").slice(-1); try { const v = new window[t(Fc, 1)]([], n), h = new window[t(Fc, 2)]( e( r( r(e(e(o(i(Fc, 3), u(get_property_byHash_then_bind, v, 4081332993) || \"\"), \"\"), m), t(Fc, 4)), u(get_property_byHash_then_bind, v, 3034174415), ), \"\", ), ); return c( c((f = u(get_property_byHash_then_bind, h, 3518522040)), null) || c(f, void 0) ? void 0 : f.substring(1), \"\", ) ? { n: m, l: -2 } : { n: m, l: s( getHash, a((d = u(get_property_byHash_then_bind, h, 3518522040)), null) || l(d, void 0) ? void 0 : d.substring(1), ), }; } catch (v) { return { n: m, l: -1 }; } } function test_doNotTrack() { const equal = function (n, t) { return n === t; }, doNotTrack = (function (n, t, e) { return n(t, e); })(get_property_byHash_then_bind, navigator, 3087401394); // doNotTrack return equal(doNotTrack, void 0) || equal(doNotTrack, null) ? { s: -1, v: null } : { s: 0, v: doNotTrack }; } function test_wasm() { const run_func = function (n, t, e) { return n(t, e); }, equal = function (n, t) { return n === t; }, run_func_ = function (n, t, e) { return n(t, e); }, WebAssembly = run_func(get_property_byHash_then_bind, window, 4177808745); // WebAssembly if (!(equal(WebAssembly, null) || equal(WebAssembly, void 0) ? void 0 : run_func(get_property_byHash_then_bind, WebAssembly, 1108488788))) // validate return { s: -1, v: null }; const o = [0, 97, 115, 109, 1, 0, 0, 0, 1, 4, 1, 96, 0, 0, 3, 2, 1, 0, 10], i = [ [ 9, 1, 7, 0, 65, 0, 253, 15, 26, 11, 0, 10, 4, 110, 97, 109, 101, 2, 3, 1, 0, 0, // v128.const ], [ 240, 67, 0, 0, 0, 12, 1, 10, 0, 252, 2, 3, 1, 1, 0, 0, 110, 26, 11, 161, 10, // ref.null extern ], [6, 1, 4, 0, 18, 0, 11, 0, 10, 4, 110, 97, 109, 101, 2, 3, 1, 0, 0], // i32.eqz [ 8, 1, 6, 0, 65, 0, 192, 26, 11, 0, 10, 4, 110, 97, 109, 101, 2, 3, 1, 0, 0, // i64.extend_i32_u ], [ 7, 1, 5, 0, 208, 112, 26, 11, 0, 10, 4, 110, 97, 109, 101, 2, 3, 1, 0, 0, // f32.const ], ]; let u = 0; for (const c of i) { ((u { run_2arg_func___(get_property_byHash_then_bind, webkitTemporaryStorage, 1291883197)((t, e) => n(e)); //queryUsageAndQuota }), ]); if (not_equal(e, void 0)) return { s: 0, v: e }; } if (equal(storage, null) || equal_(storage, void 0) ? void 0 : run_2arg_func(get_property_byHash_then_bind, storage, 3538568711)) {// estimate const t = await Promise.race([ run_2arg_func(setTimeOutRun, 250, void 0), run_2arg_func__(get_property_byHash_then_bind, storage, 3538568711)().then((n) => get_property_byHash_then_bind(n, 1813778413)), // quota ]); if (not_equal(t, void 0)) return { s: 1, v: t }; } return { s: -2, v: null }; } async function test_webkitRequestFileSystem_() { const run_func = function (n) { return n(); }, run_2arg_func = function (n, t, e) { return n(t, e); }, equal = function (n, t) { return n === t; }; if ( (function (n) { return n(); })(collectSomeKeys10_related_to_chrome) && run_func(collectSomeKeys2_very_new_api) ) return { s: -3, v: null }; const o = await Promise.race([run_2arg_func(setTimeOutRun, 100, null), run_func(test_webkitRequestFileSystem)]); return equal(o, null) ? { s: -2, v: null } : equal(o, void 0) ? { s: -1, v: null } : { s: 0, v: o }; } async function test_webkitRequestFileSystem() { const n = function (n, t, e, r, o) { return n(t, e, r, o); }, webkitRequestFileSystem = (function (n, t, e) { return n(t, e); })(get_property_byHash_then_bind, window, 2796484463); // webkitRequestFileSystem if (webkitRequestFileSystem) return new Promise((e) => { // 尝试请求1byte空间 n( webkitRequestFileSystem, 0, 1, () => e(true), () => e(false), ); }); } function getSandbox_Iframe_width_height(n) { return runActionInSandbox((n, t) => { const e = t.screen, r = (n) => { const t = parseInt(n); return \"number\" == typeof t && isNaN(t) ? -1 : t; }; return { s: 0, v: { w: r(e.width), h: r(e.height) } }; }, n.iframe_sandbox); } var indexDB_related_msg = /*#__PURE__*/ encrypted_msg_getter( [ 3924185679, 3632893699, 2980828376, 2699881398, 2597186493, 3081479162, 2868636342, 4104912311, 2917654778, 3120294056, 3186092732, 3169643453, 4210205690, 3086875321, 2867519889, 3068977853, 2897456556, 2783771306, 3033247220, 4104908215, 3152862458, 2900426157, 2868628129, 2242641335, ], 4, ); function has_indexedDB() { const run_1arg_func = function (n, t) { return n(t); }, run_1arg_func_ = function (n, t) { return n(t); }; try { return run_1arg_func(fs, !!window[run_1arg_func(indexDB_related_msg, 0)]); // indexedDB } catch (e) { return run_1arg_func_(fs, true); } } function fs(n) { return { s: 0, v: n }; } function test_indexDB() { const run_func = function (n) { return n(); }, runTwoArgFunc = function (n, t, e) { return n(t, e); }; return runTwoArgFunc(prepareRace, runTwoArgFunc(runCallbackWhenPageFocusedPromise, 250, { s: -3, v: null }), async () => run_func(collectSomeKeys6_related_to_Apple) || run_func(collectSomeKeys1_related_to_firefox) ? run_func(testIndexDB) : { s: -1, v: null }, ); } async function testIndexDB() { const run_2arg_func = function (n, t, e) { return n(t, e); }, run_2arg_func_ = function (n, t, e) { return n(t, e); }, run_1arg_func = function (n, t) { return n(t); }, run_1arg_func_ = function (n, t) { return n(t); }, a_is_insof_b = function (n, t) { return n instanceof t; }, run_1arg_func__ = function (n, t) { return n(t); }, run_2arg_func__ = function (n, t, e) { return n(t, e); }, run_1arg_func_________ = function (n, t) { return n(t); }, run_2arg_func___ = function (n, t, e) { return n(t, e); }, run_1arg_func___ = function (n, t) { return n(t); }, run_func = function (n) { return n(); }, equal = function (n, t) { return n === t; }, run_1arg_func____ = function (n, t) { return n(t); }, run_1arg_func_____ = function (n, t) { return n(t); }, run_1arg_func______ = function (n, t) { return n(t); }, add = function (n, t) { return n + t; }, add_ = function (n, t) { return n + t; }, run_1arg_func_______ = function (n, t) { return n(t); }, indexedDB = window[run_1arg_func___(indexDB_related_msg, 0)]; // indexedDB if (!indexedDB) return { s: -2, v: null }; const aRandomStr = add(add_(\"\", run_1arg_func_______(genRandomStrWrapper, 16)), \"\"); return new Promise((resolve, reject) => { const _run_1arg_func_________ = function (n, t) { return run_1arg_func_________(n, t); }; try { const indexDB_open = run_2arg_func___(get_property_byHash_then_bind, indexedDB, 2758837156)(aRandomStr, 1); ((indexDB_open[run_1arg_func___(indexDB_related_msg, 1)] = () => { // onerror _run_1arg_func_________(resolve, { s: -5, v: null }); }), (indexDB_open[run_1arg_func(indexDB_related_msg, 2)] = (c) => { // onupgradeneeded const s = run_2arg_func(get_property_byHash_then_bind, run_2arg_func(get_property_byHash_then_bind, c, 1181691900), 325763347); try { return ( run_2arg_func( get_property_byHash_then_bind, run_2arg_func_(get_property_byHash_then_bind, s, 138212912)(\"-\", run_1arg_func(indexDB_related_msg, 3)), 2928708052, )(new window[run_1arg_func_(indexDB_related_msg, 4)]()),// Blob void run_1arg_func_(resolve, { s: 0, v: \"\" }) ); } catch (a) { if (a_is_insof_b(a, Error)) return void run_1arg_func__(resolve, { s: 0, v: run_2arg_func__(get_property_byHash_then_bind, a, 3065852031) }); run_1arg_func_(reject, a); } finally { (run_2arg_func(get_property_byHash_then_bind, s, 318865860)(), run_2arg_func__(get_property_byHash_then_bind, indexedDB, 3885781331)(aRandomStr)); } })); } catch (b) { if (!run_func(collectSomeKeys6_related_to_Apple)) return void run_1arg_func__(resolve, { s: -5, v: null }); if (a_is_insof_b(b, Error) && equal(b.name, convertToIUint8Array(indexDB_related_msg, 5))) // SecurityError return void run_1arg_func_____(resolve, { s: -4, v: null }); run_1arg_func______(reject, b); } }); } function check_no_storage() { const run_func = function (n) { return n(); }, run_2arg_func = function (n, t, e) { return n(t, e); }, run_2arg_func_ = function (n, t, e) { return n(t, e); }, run_4arg_func = function (n, t, e, r, o) { return n(t, e, r, o); }, a_test = \"test\"; if (!run_func(collectSomeKeys6_related_to_Apple) || run_func(collectSomeKeys5_maybe_new_api)) return { s: -1, v: null }; const i = run_2arg_func(get_property_byHash_then_bind, window, 693717494), // not found in windows-chrome localStorage = run_2arg_func_(get_property_byHash_then_bind, window, 1703339950); // localStorage try { run_4arg_func(i, null, null, null, null); } catch (c) { return { s: 0, v: true }; } try { return ( run_2arg_func_(get_property_byHash_then_bind, localStorage, 2330630162)(a_test, \"1\"), // setItem run_2arg_func_(get_property_byHash_then_bind, localStorage, 588657539)(a_test), // removeItem { s: 0, v: false } ); } catch (s) { return { s: 0, v: true }; } } function test_system_color(n) { return runActionInSandbox((n, window) => { const e = {}, testDiv = window.document.createElement(\"div\"); window.document.body.appendChild(testDiv); const style_keys = { AccentColor: \"ac\", AccentColorText: \"act\", ActiveText: \"at\", ActiveBorder: \"ab\", ActiveCaption: \"aca\", AppWorkspace: \"aw\", Background: \"b\", ButtonHighlight: \"bh\", ButtonShadow: \"bs\", ButtonBorder: \"bb\", ButtonFace: \"bf\", ButtonText: \"bt\", FieldText: \"ft\", GrayText: \"gt\", Highlight: \"h\", HighlightText: \"ht\", InactiveBorder: \"ib\", InactiveCaption: \"ic\", InactiveCaptionText: \"ict\", InfoBackground: \"ib\", InfoText: \"it\", LinkText: \"lt\", Mark: \"m\", Menu: \"me\", Scrollbar: \"s\", ThreeDDarkShadow: \"tdds\", ThreeDFace: \"tdf\", ThreeDHighlight: \"tdh\", ThreeDLightShadow: \"tdls\", ThreeDShadow: \"tds\", VisitedText: \"vt\", Window: \"w\", WindowFrame: \"wf\", WindowText: \"wt\", Selecteditem: \"si\", Selecteditemtext: \"sit\", }; for (const u of Object.keys(style_keys)) { e[style_keys[u]] = ((i = u), (testDiv.style.color = i), window.getComputedStyle(testDiv).color); } var i; return (window.document.body.removeChild(testDiv), { s: 0, v: e }); }, n.iframe_sandbox); } function get_size_and_font(n, t) { const e = {}, r = [\"x\", \"y\", \"left\", \"right\", \"bottom\", \"height\", \"top\", \"width\"], o = n.getBoundingClientRect(); for (const u of r) u in o && (e[u] = o[u]); const i = t.getComputedStyle(n, null).getPropertyValue(\"font-family\"); return ((e.font = i), e); } function test_emoji(n) { let t = \"\"; for (let e = 128512; e { const testSpan = e.document.createElement(\"span\"); ((testSpan.style.whiteSpace = \"nowrap\"), (testSpan.innerText = t), e.document.body.append(testSpan)); const o = get_size_and_font(testSpan, e); return (e.document.body.removeChild(testSpan), { s: 0, v: o }); }, n.iframe_sandbox); } function test_mathML(n) { let t = \"∏\"; const e = [ [\"𝔈\", \"υ\", \"τ\", \"ρ\", \"σ\"], [\"𝔇\", \"π\", \"ο\", \"ν\", \"ξ\"], [\"𝔄\", \"δ\", \"γ\", \"α\", \"β\"], [\"𝔅\", \"θ\", \"η\", \"ε\", \"ζ\"], [\"𝔉\", \"ω\", \"ψ\", \"ϕ\", \"χ\"], [\"ℭ\", \"μ\", \"λ\", \"ι\", \"κ\"], ]; function r(n, t, e, r, o) { return `${n}${t}${e}${r}${o}`; } for (const o of e) { const n = r(...o); t += n; } return ( (t += \"\"), runActionInSandbox((n, e) => { const r = e.document.createElement(\"math\"); ((r.style.whiteSpace = \"nowrap\"), (r.innerHTML = t), e.document.body.append(r)); const o = get_size_and_font(r, e); return (e.document.body.removeChild(r), { s: 0, v: o }); }, n.iframe_sandbox) ); } var encrypted_msg_getter_ = /*#__PURE__*/ encrypted_msg_getter( [ 2849665133, 3102332852, 3030028940, 2360597915, 3649086422, 4118989755, 2159729800, 2492790230, 3150617845, 3422263962, 3398214861, 3000338617, 2163578059, 3720000219, 2782764965, 3422263962, 3600523980, 2895432685, 2292567243, 3617170646, 3986333093, 2578762955, 2596645530, 2227996313, 2259142812, 3700204490, 3100285842, 3422263963, 3903489002, 2496302258, 2360989318, 3615531995, 4120169401, 2192956830, 3971720145, 3000875412, 2277047195, 3431641814, 4124477118, 2273483461, 3481713107, 2781523129, 3321219718, 3599275162, 4157376185, 2293418634, 3418993356, 3067464120, 3120021895, 4221285085, 3000403896, 2260651146, 2496373974, 3051664885, 2293418634, 3735466700, 2345307313, 3287931573, 3669330832, 3151268020, 2192890251, 2525727716, 3051664893, 3382957959, 3448764377, 3201075897, 3045840518, 3837111258, 2966063285, 2276644252, 3402212556, 3201145010, 3048463771, 2462561764, 2816128395, 2359614875, 3837109206, 4221223093, 2209732555, 2594026717, 2782776315, 2862995355, 2592912343, 2781727739, 3422263941, 3683431633, 3202123702, 2359548301, 3617301981, 4120169381, 2595804298, 2496377821, 3100936949, 2257903002, 3683432918, 3117908131, 2331350219, 3431510730, 2748951986, 2294283144, 3565992406, 2564589462, 2612190863, 3687578522, 2999682747, 2277103530, 3516773597, 3220146104, 2625885836, 3601643978, 2325387955, ], 3, ); async function ia({ te: te }) { console.log(te) const runFunc = function (n) { return n(); }, equal = function (n, t) { return n === t; }, two_arg_runner = function (func, t, e) { return func(t, e); }, serial = runFunc(get_random_serial_str), u = await two_arg_runner(prepareRace, two_arg_runner(runCallbackWhenPageFocusedPromise, 300, -4), ua.bind(null, serial, te)); return () => { const n = runFunc(u); return equal(n, 0) || equal(n, -4) ? { s: n, v: { u: serial, e: [], s: [] } } : { s: n, v: null }; }; } async function ua(serial, tls_endpoint) { const two_arg_runner__local = function (n, t, e) { return n(t, e); }, not_eq_local = function (n, t) { return n !== t; }, two_arg_runnerlocal = function (n, t, e) { return n(t, e); }, two_arg_runner_local = function (n, t, e) { return n(t, e); }, u = two_arg_runner__local(ca, serial, tls_endpoint), { s: c, v: s } = two_arg_runner__local(la, u, true); if (not_eq_local(c, 0)) return c; const a = two_arg_runner__local(ha, s, tls_endpoint); try { const { s: n, v: t } = await two_arg_runner__local(get_property_byHash_then_bind, a, 142982734)(); return not_eq_local(n, 0) ? n : (await two_arg_runner__local(get_property_byHash_then_bind, s, 76151562)(t), 0); } finally { two_arg_runner_local(get_property_byHash_then_bind, a, 107910612)(); } } function ca(serial, tls_endpoint) { const run_1arg_func = function (n, t) { return n(t); }, run_1arg_func_ = function (n, t) { return n(t); }, run_1arg_func__ = function (n, t) { return n(t); }, credential = (function (n, t) { return n(t); })(encrypted_msg_getter_, 0); // enc_result // credential 0 // urls 1 // username 2 // iceServers 3 // turn: 4 // transport 5 ((credential[run_1arg_func(encrypted_msg_getter_, 1)] = run_1arg_func_(sa, tls_endpoint)), (credential[run_1arg_func__(encrypted_msg_getter_, 2)] = serial)); const u = {}; return ((u[run_1arg_func_(encrypted_msg_getter_, 3)] = [credential]), u); } function sa(tls_endpoint) { const add = function (n, t) { return n + t; }, run_1arg_func = function (n, t) { return n(t); }, run_2arg_func = function (n, t, e) { return n(t, e); }; return add(add(run_1arg_func(encrypted_msg_getter_, 4), run_2arg_func(Sr, tls_endpoint, run_1arg_func(encrypted_msg_getter_, 5))), \"\"); } const _NotSupportedError = /*#__PURE__*/ encrypted_msg_getter_(6); // NotSupportedError function la(n, t) { const e = function (n, t) { return n(t); }, r = function (n, t) { return n(t); }, o = function (n, t) { return n instanceof t; }, i = function (n, t) { return n === t; }, u = t ? window[ (function (n, t) { return n(t); })(encrypted_msg_getter_, 7) ] || window[e(encrypted_msg_getter_, 8)] : window[r(encrypted_msg_getter_, 7)]; if (!u) return { s: -3, v: null }; let c; try { c = new u(n); } catch (s) { if (o(s, Error)) { if (i(s.name, _NotSupportedError)) return { s: -6, v: null }; if (e(da, s)) return { s: -9, v: null }; } throw s; } return { s: 0, v: c }; } function fa(n, t) { const e = function (n, t) { return n === t; }, r = function (n, t, e) { return n(t, e); }, o = function (n, t) { return n === t; }, i = function (n, t) { return n instanceof t; }; var u; try { return ( e((u = r(get_property_byHash_then_bind, n, 34843658)), null) || o(u, void 0) || u.call(n, t || Math.random().toString()), 0 ); } catch (c) { if (i(c, Error) && o(c.name, _NotSupportedError)) return -7; throw c; } } function da(n) { const t = function (n, t) { return n(t); }, e = function (n, t, e) { return n(t, e); }; return ( (function (n, t) { return n === t; })(n.name, t(encrypted_msg_getter_, 9)) && e(get_property_byHash_then_bind, new RegExp(t(encrypted_msg_getter_, 10)), 3632233996)(e(get_property_byHash_then_bind, n, 3065852031)) ); } function ma(n) { const t = function (n, t, e) { return n(t, e); }; try { t(get_property_byHash_then_bind, n, 318865860)(); } catch (e) { } } async function va(n, t) { const e = function (n, t, e) { return n(t, e); }, r = function (n, t) { return n instanceof t; }, o = function (n, t, e) { return n(t, e); }, i = function (n, t) { return n(t); }, u = function (n, t) { return n === t; }; let c; try { c = e(get_property_byHash_then_bind, n, 882066760)(t); } catch (a) { if ( !r(a, Error) || !o(get_property_byHash_then_bind, new RegExp(i(encrypted_msg_getter_, 11), \"i\"), 3632233996)(o(get_property_byHash_then_bind, a, 3065852031)) ) throw a; c = new Promise((r, o) => { e(get_property_byHash_then_bind, n, 882066760)(r, o, t); }); } const s = await c; return u(s, void 0) ? { s: -8, v: null } : { s: 0, v: s }; } function ha(n, t) { const r = function (n, t) { return n(t); }, o = function (n, t) { return n === t; }, i = function (n, t, e) { return n(t, e); }, u = function (n, t, e) { return n(t, e); }, c = function (n, t) { return n === t; }, s = function (n, t) { return n(t); }, a = function (n, t) { return n !== t; }, l = function (n, t) { return n in t; }, f = function (n, t) { return n(t); }, d = function (n, t) { return n in t; }, m = function (n, t, e) { return n(t, e); }, v = function (n) { return n(); }, h = function (n, t) { return n === t; }, p = function (n, t, e) { return n(t, e); }, g = function (n, t) { return n(t); }, w = function (n, t, e, r) { return n(t, e, r); }, y = function (n, t) { return n(t); }, b = function (n, t) { return n !== t; }, E = function (n, t) { return n !== t; }, R = function (n, t, e) { return n(t, e); }, S = function (n, t) { return n(t); }, I = function (n, t, e) { return n(t, e); }; function k(n, t) { return ( r(A, n) && o(i(get_property_byHash_then_bind, n, 3920415024), 400) && u(get_property_byHash_then_bind, n, 4101391790).includes(t) ); } function A(n) { return ( c(typeof n, s(encrypted_msg_getter_, 12)) && a(n, null) && l(f(encrypted_msg_getter_, 13), n) && convertToIUint8Array(s(encrypted_msg_getter_, 14), n) ); } let L = null, C = false; async function P() { const t = r(fa, n); if (b(t, 0)) return { s: t, v: null }; const { s: e, v: o } = await r(va, n); return E(e, 0) ? { s: e, v: null } : { s: 0, v: o }; } t && (function (n, t, e) { return n(t, e); })( get_property_byHash_then_bind, n, 123626528, )(S(encrypted_msg_getter_, 15), (e) => { m(k, e, t) && (L ? (v(L), (L = null), r(ma, n)) : (C = true)); }); const T = { [y(encrypted_msg_getter_, 17)]: () => ma(n), [r(encrypted_msg_getter_, 18)]: async () => { const t = await v(P); return (b(R(get_property_byHash_then_bind, t, 453955339), 0) && r(ma, n), t); }, }; return t ? I( get_property_byHash_then_bind, Object, 1914874273, )(T, { [f(encrypted_msg_getter_, 19)]: function () { h(p(get_property_byHash_then_bind, n, 4184312542), g(encrypted_msg_getter_, 16)) || (C ? y(ma, n) : (L = w(runCallbackWhenPageFocused, ma, 5e3, n))); }, }) : T; } var get_enc_msg_for_s95 = /*#__PURE__*/ _i( [ [ 1158230590, 352328197, 922751784, 234887733, 1045777409, 235013451, 1077693209, 86185296, 321396490, 462366, 488115742, 1213075980, 4402479, 184943903, 188551425, 1398147351, 268897603, 491523647, 306988571, 1261376568, 269223502, 570890009, 34866732, 470426899, 403966778, 253756433, 304419089, 491347009, 508233756, 403654977, 421396492, 1329803025, 184551506, 1057755406, 136120322, 118163754, 373378420, 453843998, 1159464460, 319444544, 855642889, 402851378, 1191248155, 151015493, 219352090, 67375366, 17696018, 1263095066, 420348421, 21908811, 168961297, 171640095, 14413, ], ], [ function () { const n = new Image().style; return reshuffleStr( [getPropertyNameByHash((t = n), 2487676862), getPropertyNameByHash(t, 41374024)], [ 5, 23, 47, 9, 35, 9, 44, 7, 37, 41, 19, 25, 32, 26, 30, 32, 8, 31, 12, 15, 40, 18, 15, 20, 9, 4, 2, 13, 21, 17, 18, 34, 40, 2, 48, ], ); var t; }, ], [2], ); async function ga() { const run1arg_func = function (n, t) { return n(t); }, run1arg_func_ = function (n, t) { return n(t); }, run1arg_func__ = function (n, t, e) { return n(t, e); }, less = function (n, t) { return n < t; }, run2arg_func = function (n, t, e) { return n(t, e); }, sub = function (n, t) { return n - t; }; if ( (function (n) { return n(); })(collectSomeKeys4_related_to_modern_api) ) return [-1, NaN]; const u = new Uint8Array([0]), c = run1arg_func(get_enc_msg_for_s95, 0), s = await navigator[run1arg_func_(get_enc_msg_for_s95, 1)](run1arg_func_(get_enc_msg_for_s95, 2), c), a = await s[run1arg_func_(get_enc_msg_for_s95, 3)](); let l = await run1arg_func__(ya, a, u); const f = less(l, 10); if (f) { const n = sub(sub(run2arg_func(Wt, 10, 2500), l), 1); for (let t = 0; less(t, n); t++) run2arg_func(ba, a, u); l = await run2arg_func(ya, a, u); } return [f ? 1 : 0, l]; } function wa() { const run1arg_func = function (n, t) { return n(t); }; return (function (n, t) { return n == t; })( typeof navigator[ (function (n, t) { return n(t); })(get_enc_msg_for_s95, 1) ], run1arg_func(get_enc_msg_for_s95, 4), ); } async function ya(n, t) { const e = function (n, t) { return n(t); }, r = function (n, t) { return n(t); }, o = n[e(get_enc_msg_for_s95, 5)](); return (await o[r(get_enc_msg_for_s95, 6)](e(get_enc_msg_for_s95, 7), t), r(Number, o[r(get_enc_msg_for_s95, 8)])); } function ba(n, t) { const e = function (n, t) { return n(t); }; (function (n, t) { n(t); })( addEmptyErrHandle, n[ (function (n, t) { return n(t); })(get_enc_msg_for_s95, 5) ]()[e(get_enc_msg_for_s95, 6)](e(get_enc_msg_for_s95, 7), t), ); } async function s95_worker() { const runFunc = function (n) { return n(); }, equal = function (n, t) { return n === t; }, run2arg_func = function (n, t, e) { return n(t, e); }, run2arg_func_ = function (n, t, e) { return n(t, e); }; return (function (n) { return n(); })(wa) ? run2arg_func(prepareRace, run2arg_func_(runCallbackWhenPageFocusedPromise, 500, { s: -2, v: null }), async () => { const e = await runFunc(ga); return equal(e[0], -1) ? { s: -3, v: null } : { s: 0, v: e }; }) : () => ({ s: -1, v: null }); } var Ra = /*#__PURE__*/ _i( [ [ 89472536, 67911963, 202988290, 386077465, 1866537770, 1224742518, 488243476, 419627011, 184819487, 437598027, 340225859, 172033032, 437716482, 471155211, 1095068177, 1092107040, 419499526, 423762697, 100665116, 490210839, 1194790674, 673115, 85280006, 1510540548, 2756129, 939992591, 1246643516, 1108281098, 52370449, 641031181, 822350097, 201595136, 1447512348, 1107565334, 605101077, 923815180, 201460231, 369557787, 421401919, 370608902, 386208007, 1158809130, 67652933, 420829977, 1325996060, 705104933, 100734005, 18485518, 1079117841, 520555597, 117716299, 441132557, 117836552, 454886414, 1079380231, 235285315, 167851373, 438045445, 354104902, 218503945, 1450723136, 1261309460, 853525, 339100932, 1443038736, 103498560, 3566862, 1175192861, 252709131, 16777237, 1984516105, 1829509143, 185926151, 436356353, 185073670, 1779174662, 991969605, 50610456, 1275666182, 419565839, 202771726, 1124408096, 135546735, 168313092, 253563142, 135813653, 822480166, 72178038, 222758157, 52298251, 454823449, 56244746, 1427123716, 67914571, 353589766, 51775754, 625419022, 219166498, 1258491144, 521093188, 151601409, 456523793, 678234648, 169481234, 118557701, 391005526, 241568771, 422784012, 438716682, 1309089280, 806492, 990010373, 638390299, 134885451, 1481180934, 17176407, 655231834, 2049314574, 84410418, 220531716, 167778574, 105923661, 106502459, 185600556, 170279180, 1046087172, 151977997, 35061763, 1263338788, 84282176, 52366156, 1544356616, 420816433, 50605842, 1229146882, 1511529224, 186319630, 4664589, 35268139, 100748290, 1379942427, 1174536207, 322636309, 208471067, 373756952, 7684, 1481509910, 69665358, 440083533, 1174866696, 403505177, 1129127711, 956961098, 571674714, 285606663, 67257606, 151460637, 725827670, 862785030, 168106503, 289803037, 203297033, 1197361671, 1327110967, 169477163, 84548876, 1840656, 1325404447, 537919532, 1158350651, 118114894, 454640143, 269026054, 471146315, 372321280, 1196229131, 421140297, 17891399, 256321038, 167983925, 135074069, 1379942427, 1174536207, 523897886, 187303186, 16788313, 1007685120, 1447054106, 1193610767, 121055758, 235738112, 118572573, 1091181577, 956569372, 1632457991, 1191843846, 387122178, 420174362, 755830297, 929124171, 222888474, 50727960, 118447621, 1229986830, 202905462, 51517293, 1159661069, 219156518, 1296957445, 772541034, 285869946, 471598093, 437591628, 102564608, 341211207, 72035854, 453396244, 286989059, 252909895, 100927823, 207059041, 440798984, 347163, 218169348, 389222492, 3416153, 1128989210, 404424777, 102242906, 1193875213, 338048784, 17827353, 1077939469, 33558354, 973080134, 923734551, 118361931, 390678349, 407312666, 756351505, 606227719, 1078676741, 1275397643, 369236248, 102176796, 152328767, 505090338, 1195966464, 68884054, 402849858, 604117287, 387586598, 184555596, 52366851, 290079565, 39467274, 337061379, 1044450054, 822546697, 1309087752, 202009165, 100891182, 1259996933, 521093188, 51986689, 390009692, 187041819, 1296385283, 1528366088, 1539, 1194856717, 20458516, 188762957, 374080774, 100861208, 604249353, 906778884, 134487574, 1444022019, 51205721, 688201243, 275581722, 638910490, 553654793, 438246915, 1191185666, 68310648, 100862061, 1157897218, 203233559, 1296957442, 1829962602, 35198010, 17122832, 1079118092, 101515597, 370942795, 117714965, 54019863, 889585674, 1079385113, 386672195, 236790637, 420024595, 406539288, 689707789, 956765442, 1198474037, 1091441944, 102564636, 119409668, 205263381, 108670990, 151781382, 1313753605, 457245696, 855645709, 391058950, 235019008, 471534109, 474699863, 756351517, 540018203, 272974679, 51463965, 386470914, 67506497, 1297423660, 1224806753, 520230941, 878058775, 289625664, 571801658, 289411104, 88480259, 1641997, 388317194, 1477786881, 50998065, 521022728, 202398474, 33949981, 1095115776, 1582986863, 239750725, 289150477, 469830174, 14416, ], ], [maybeGetEncKey], [2], ); function Ra_0() { return Ra(0); } async function Ia() { const run_func = function (n, t) { return n(t); }, t = (function (n) { return n(); })(Ra_0), e = await Promise.all(t.map(ka)), r = {}; return ( t.forEach((t, o) => { const i = run_func(getHash, t).toString(16); r[i] = e[o]; }), r ); } function ka(ra_0) { const add = function (n, t) { return n + t; }, add_ = function (n, t) { return n + t; }, run_arg1_func = function (n, t) { return n(t); }, run_arg1_func_ = function (n, t) { return n(t); }, run_arg1_func__ = function (n, t) { return n(t); }, not_equal = function (n, t) { return n !== t; }, run_arg1_func___ = function (n, t) { return n(t); }; return new Promise((s) => { const a = add(add_(run_arg1_func(Ra, 1), ra_0), run_arg1_func_(Ra, 2)); try { const [, n, t] = run_arg1_func__(Mc, a); if (not_equal(n, 0)) return void run_arg1_func___(s, n); t[run_arg1_func(Ra, 3)]( () => s(0), () => s(-1), ); } catch (l) { run_arg1_func___(s, -2); } }); } async function s97_worker() { const run_func_ = function (n) { return n(); }, run_func = function (n) { return n(); }, run2arg_func = function (n, t, e) { return n(t, e); }; return await run2arg_func(prepareRace, run2arg_func(runCallbackWhenPageFocusedPromise, 500, { s: -2, v: null }), async () => run_func_(Ra_0) ? run_func_(jc) ? { s: 0, v: await run_func(Ia) } : { s: -1, v: null } : { s: -3, v: null }, ); } function get_serviceWorker() { return { s: 0, v: \"serviceWorker\" in Navigator.prototype }; } function get_isSecureContext() { return { s: 0, v: Boolean(window.isSecureContext) }; } var get_s70_related_msg = /*#__PURE__*/ _i( [ [ 37637135, 1447917654, 1074862848, 221320987, 185417728, 1279479069, 287641348, 1585126709, 277761, 1427768864, 1124076042, 2035529, 455018507, 23675461, 120393521, 1444036433, 1141263183, 303105822, 319645969, 1275726848, 36457547, 388709920, 101924677, 1077349638, 303367169, 135938595, 1112349448, 153357637, 121505586, 1480802129, 1141246529, 839976462, 805901, 167780891, 1160643090, 438979704, 100941378, 1381385537, 33619995, 505875729, 119147817, 153229835, 20323964, 453520970, 1308901389, 134224668, 324158218, 140184588, 136785483, 455937847, 1145648204, 1494293834, 320544012, 1971969, 319380746, 359333889, 104340027, 1544500554, 1141003010, 1209157132, 67441480, 1511480093, 104666369, 1328827942, 1075133262, 152198427, 149830, 1477446935, 1427587336, 1194921745, 1547195181, 353853786, 470698257, 1510890510, 1159481353, 521949703, 526588437, 192026238, 239739657, 442307401, 256466199, 1481069662, 1091916807, 191889498, 175708721, 1578723163, 1142444571, 403526171, 474109016, 436863826, 1513165895, 1227047982, 1410678607, 1310151680, 1326799388, 156435474, 491723532, 153230682, 91688828, 286089482, 471550231, 1511481182, 945321480, 218765652, 526583891, 1131496748, 1561928206, 1498942025, 241044293, 373446478, 340072261, 510001485, 1114971518, 789340426, 1464415314, 121639178, 474109261, 339869763, 510074189, 1131496749, 1561862926, 1482164809, 241043525, 373445966, 1430675269, 981021962, 289151081, 206126103, 1314788169, 308153156, 524440649, 373424195, 493296973, 1131496750, 1562058766, 290982473, 974735686, 324366422, 140184588, 1466392143, 1131765368, 286482698, 1325800471, 394831, 169369099, 54987290, 657872206, 120986675, 1565553235, 1209411907, 253564417, 1280836866, 470686025, 237312859, 522912050, 201357853, 1141003025, 1511147020, 386751269, 1310132765, 292225025, 270091815, 865110, 1465648906, 67108874, 184644125, 1192692237, 309397319, 1601199207, 404362525, 1330912518, 34669650, 1212173143, 1113211225, 1316896855, 104596079, 39597315, 1195772422, 1364869959, 1430658377, 184767552, 1513967123, 321592373, 1510961754, 218960155, 420305921, 1258684700, 1108743697, 506609673, 1547125293, 1478042203, 1494042381, 1327128087, 1225806877, 387334407, 191907615, 108599857, 101923614, 291246082, 1381515331, 1447304521, 1514364485, 1348950091, 1165318776, 1145925391, 391666511, 1465401923, 1413749065, 1497586757, 1348951883, 1081432952, 1129147407, 374889295, 1364738371, 1346640201, 1531141957, 1549950795, 1378683704, 100689750, 151848977, 420305920, 474366537, 1073758992, 140973855, 1579227002, 219771980, 1499072079, 391076631, 390618884, 475275347, 337911369, 489691709, 454256461, 1207961623, 6036480, 1329684253, 1510738463, 1010648577, 791688480, 1565554302, 1431968600, 236390922, 1477205770, 1258697756, 359674705, 2890289, 1326676557, 1393764638, 1225000704, 625476693, 167839243, 1328283662, 75056996, 121710658, 1276451417, 319888927, 386887006, 1176443398, 661342039, 372705078, 1543910474, 1465139282, 357826574, 487414111, 186456605, 1529830456, 1282104626, 101128728, 1142492674, 122947073, 370019595, 559220289, 661996366, 322568504, 437138263, 22894923, 1427576601, 1725955, 1907229, 523115079, 388700960, 67910512, 1432095759, 139985219, 487414091, 469762058, 443565827, 293290614, 16209, 1326529286, 822482699, 151870732, 1275724032, 238767179, 456461092, 1480802125, 1426131009, 441995264, 152915527, 167780869, 1165052930, 389480762, 1447896833, 1074862848, 69211931, 387799325, 1279479052, 70125060, 388696895, 1447917639, 1075187217, 236586839, 1229602839, 993994827, 322112307, 658250785, 285621072, 1968588097, 874523178, 657942583, 657137952, 1265183017, 571878774, 656737658, 56118071, 336660254, 1195642624, 436608286, 523123202, 388700960, 390297089, 1427442705, 202711306, 386744597, 1276396363, 556535562, 388825661, 1448835153, 1393888269, 1124073738, 105513240, 437127707, 153234434, 489367856, 1480796758, 1427181121, 85596973, 268918562, 386802457, 1161763592, 3820664, 286604102, 1443954741, 39214669, 285820951, 135933196, 1161366273, 171461752, 1480796497, 1965894465, 824910122, 540507936, 723659301, 1265187369, 654911862, 302460769, 1377901318, 1125192974, 725421897, 1008740640, 1164397610, 1059916595, 286337602, 1326791431, 1297487624, 286088775, 458048331, 388629257, 293290614, 16209, 1140930566, 69667613, 507776785, 504765259, 1165052930, 389285664, 419442256, 56118035, 251731212, 1464995601, 223167252, 321198856, 595280502, 758325110, 1915829052, 606223904, 642384199, 825638694, 1158167604, 455756920, 1480802137, 1899308097, 540090416, 1195642657, 167840283, 102439938, 1585126695, 390275448, 1393888271, 337122105, 1045565184, 1113342297, 1266171991, 1584021604, 1447888658, 1159005711, 1532363296, 282183, 1112349960, 138353989, 34999078, 121856001, 1141245463, 1294536525, 151473735, 439229702, 254283539, 104270649, 1447917648, 1443954709, 106323533, 271276288, 662811, 523123219, 388700960, 390297089, 1427442705, 203108618, 17189896, 17563948, 1161366275, 511382904, 402929730, 1146508097, 85659905, 407527168, 185421125, 891619072, 389873713, 117443153, 56118032, 822089500, 151870732, 1275724032, 37243979, 472919072, 454237511, 223746326, 319881805, 135938563, 185336072, 157893189, 1585125691, 353582593, 56118036, 1125129226, 1707849, 402849818, 37633794, 386537254, 1447917655, 1912866830, 67113755, 273285447, 504234503, 1160710935, 490359928, 19080019, 1393626885, 339090747, 386747139, 139281227, 337772558, 1349864508, 419639120, 223747338, 117510221, 1192904707, 251809093, 506998551, 1585122618, 556866817, 1812203566, 1125193216, 540675913, 1112353576, 87956805, 321592373, 1447917658, 1076889111, 857805595, 1195642665, 17367296, 359219781, 388767537, 270544464, 1140857090, 119159581, 3477258, ], [ 386942744, 1229409564, 135333655, 220795160, 755369005, 1162041120, 503777537, 1079123715, 101517389, 52050726, 1427192580, 236473163, 17109769, 173424715, 371009796, 1292251441, 203046987, 50927385, 503982872, 1446053403, 2376539, 169555715, 117837325, 355405073, 438900482, 405154853, 1145049870, 34409291, 436733206, 2017924890, 638784598, 973210372, 286198279, 134625543, 1778647041, 1009795397, 268569364, 290080074, 202965528, 507332635, 134354452, 152965423, 402923329, 102564125, 236739842, 706150459, 290790203, 240978695, 52177998, 454823436, 1197226506, 251672392, 419431940, 285429263, 286416394, 290006535, 454303788, 1090915598, 354048009, 1091132175, 356080479, 1362842883, 236919825, 1209617177, 1075316761, 1093555476, 337803338, 1427785501, 1461339656, 1327303942, 2047102737, 571952141, 1411208983, 1326531854, 1276973337, 957501722, 745215771, 457971551, 407048258, 1413810758, 189744919, 1549274479, 1208835629, 122683732, 290717969, 1259620628, 638538288, 504780064, 289608031, 404029529, 1326585167, 1276018207, 1460741645, 67916804, 1511283736, 5195038, 273234948, 18622334, 507904847, 352344385, 1426083608, 1329023043, 947075610, 202117450, 224136543, 1162101260, 1076894017, 225976393, 122166853, 524816962, 356848732, 759700802, 1934427230, 839535692, 39204446, 173872912, 827003996, 778964035, 457907295, 1396720145, 1175783745, 475925317, 240979582, 341646696, 1346527045, 877014553, 34144849, 994774908, 138743678, 457380169, 375002446, 172294213, 223881039, 1179478043, 1108677450, 1146689345, 924407616, 357832018, 155268902, 1497649743, 1094734404, 220025925, 438702086, 70325591, 1643545, 408686104, 873550429, 472322827, 1550150419, 16787279, 34278407, 1180648471, 637797448, 705626696, 68491267, 202001233, 153046535, 1929861143, 640029993, 1109330433, 340264718, 221009951, 287179034, 392108605, 33756966, 84029457, 1074532368, 341187916, 1850366843, 185875050, 105454599, 253041247, 1598032221, 1531017813, 1582329169, 520750428, 38280011, 172363532, 1397193033, 1599825007, 201611598, 1293566492, 152902925, 1513770251, 1228544271, 386943257, 1528448786, 1477775372, 271666946, 1530556186, 1142562583, 337331719, 1090600968, 2015169296, 974674202, 89939485, 4923146, 505091400, 2018055445, 1735348549, 1363894105, 1447319620, 1480607296, 1381915715, 1364935032, 1364940655, 1564958533, 1482178904, 1447053120, 1951357028, 1430470776, 1598381646, 1532780110, 1111776323, 1113088073, 1112109901, 1346787403, 1409356039, 504713500, 1259350291, 386693676, 273026379, 1577274897, 121837076, 1479285852, 473648920, 390531163, 55525907, 105650965, 460533334, 104543053, 118166278, 51401991, 102436100, 894245895, 1766327564, 1560547859, 790446857, 822095617, 1632649257, 544018770, 218371856, 1594628871, 1241852697, 390673753, 318898225, 1543849261, 420228884, 1090781211, 558652764, 655163434, 1325931325, 508117330, 525344259, 520690773, 85014549, 84018010, 1126112264, 878009691, 135922955, 1259218440, 425033074, 491261958, 134813266, 220011032, 1211127597, 1534153233, 487532364, 270076938, 306978074, 439238914, 980298315, 677136966, 218171141, 16778500, 1951154752, 1996624386, 202705923, 437853723, 336330837, 756226304, 606995002, 374278681, 189012548, 386466882, 387778316, 474766640, 72698209, 520751643, 118564625, 824054024, 788928801, 1158290237, 18434638, 85723410, 1581910529, 50410823, 206135566, 119147077, 270153991, 1313754636, 101132047, 1297688929, 135073796, 355993372, 437918484, 1450723095, 103155988, 169542172, 1465403663, 353242630, 103158868, 1500917265, 1026695245, 404360509, 973741573, 822219547, 390290262, 1009987360, 909389373, 623721020, 1682123578, 67903563, 824389676, 1078217532, 436798749, 1197361674, 354289187, 521285926, 236526109, 173431126, 353177886, 771897901, 352983332, 1242711104, 706153743, 387711750, 1431205399, 84157967, 1226512898, 391600150, 404031771, 218106372, 463655, 1162482194, 67700042, 201393710, 20649781, 472001799, 1293750808, 118966599, 286787601, 506267706, 376860481, 469959197, 169290252, 1293748502, 738480196, 1866662918, 1027487047, 607402026, 691414576, 220997944, 2019637031, 926361687, 68033578, 473498121, 1192693518, 790779512, 892871434, 1229409572, 603983891, 68944909, 755120940, 1263341619, 470555456, 424820800, 34144769, 341211207, 50603539, 236599298, 287706393, 391663133, 319831107, 1297053222, 201657107, 487396891, 1245924636, 438372881, 1467564803, 206261002, 18488836, 625886550, 807019577, 638652732, 758393632, 792740939, 808860735, 1982210107, 705844568, 1162154527, 606742093, 757868074, 1783451184, 808257051, 53943568, 1313479195, 206441271, 387124483, 337319170, 1011697446, 1196966233, 1162304324, 1298094684, 1632580729, 51255864, 1380653101, 152833856, 1581915406, 402663239, 120202771, 407720773, 285678367, 1076433227, 252062531, 456402476, 17498899, 67241733, 1245924639, 53545988, 39931221, 438965010, 454105369, 201932032, 205132824, 376860481, 469959197, 17640204, 184618269, 990256173, 1628639760, 88411209, 403573006, 155930199, 739118874, 694227212, 117787993, 805699599, 168304137, 370358301, 1130059303, 922943536, 118365952, 1259412253, 69162560, 755641148, 136131120, 1145772055, 504699968, 521797641, 303512068, 424111939, 1196236296, 352784457, 1314410014, 1091380740, 168261231, 520359188, 353973005, 222041630, 1450723078, 909312026, 169674243, 5654345, 67961882, 1261175836, 439837007, 488644127, 503778831, 439157540, 637539342, 625171286, 437131532, 1447512327, 17498374, 1682118685, 842400075, 1075120659, 50678596, 371142940, 1229982465, 874984310, 705102862, 1225657094, 740710232, 1296969773, 555096682, 102565685, 1246054939, 221512470, 540872219, 1431860777, 402861320, 424494405, 285213966, 137697306, 102578176, 152771889, 3489800, ], ], [ function () { return (function (navigator, frameset) { const e = get_property_byHash_then_bind(navigator, 704082790); return reshuffleStr( [ getPropertyNameByHash(frameset, 3017323393), Oc(navigator, 859837811, \"QjslADtOBipACA\") || Oc(e, 72906005, \"Tjo/DSpIETFCCQ\"), ], [ 20, 1, 24, 23, 23, 21, 14, 8, 11, 8, 6, 13, 1, 1, 12, 4, 9, 10, 6, 2, 1, 2, 0, 1, 2, 1, 1, ], ); })(navigator, document.createElement(\"frameset\")); }, maybeGetEncKey, ], [1, 1], ); function Ta() { const run_func = function (n, t) { return n(t); }; return run_func(get_s70_related_msg, 0) && navigator[run_func(get_s70_related_msg, 0)]; } function Oa() { const n = function (n, t) { return n(t); }, t = function (n, t) { return n(t); }; return document[n(get_s70_related_msg, 1)](n(get_s70_related_msg, 2))[n(get_s70_related_msg, 3)](t(get_s70_related_msg, 4)); } async function _a(n, t) { const e = function (n, t) { return n === t; }, r = function (n, t) { return n === t; }, o = function (n, t) { return n(t); }, i = function (n, t, e, r) { return n(t, e, r); }, u = function (n, t) { return n(t); }, c = Array.from(e(n, null) || r(n, void 0) ? void 0 : n[o(get_s70_related_msg, 5)].values()), [s, a] = await Promise.all([i(Na, n, c, t), u(Va, n)]); return [s, a, c]; } const xa = 16; async function Na(n, t, e) { const r = function (n, t) { return n(t); }, o = function (n, t) { return n(t); }, i = function (n, t) { return n * t; }, u = function (n, t) { return n(t); }, c = function (n, t) { return n(t); }, s = function (n, t) { return n(t); }, a = function (n, t) { return n(t); }, l = function (n, t) { return n(t); }, f = function (n, t) { return n(t); }, d = function (n, t) { return n / t; }, m = function (n, t) { return n + t; }, v = function (n, t) { return n(t); }, h = function (n, t) { return n(t); }, p = function (n, t) { return n(t); }, g = function (n, t) { return n(t); }, w = function (n, t) { return n(t); }, y = function (n, t) { return n(t); }, b = function (n, t) { return n(t); }, E = function (n, t) { return n | t; }, S = function (n, t) { return n(t); }, I = function (n, t) { return n(t); }, k = function (n, t) { return n(t); }, A = function (n, t) { return n(t); }, L = function (n, t) { return n(t); }, C = function (n, t) { return n(t); }, P = function (n, t) { return n(t); }, T = function (n, t) { return n(t); }, O = function (n, t) { return n(t); }, _ = function (n, t) { return n * t; }, x = function (n, t) { return n(t); }, N = function (n, t) { return n(t); }, j = function (n, t) { return n(t); }, V = function (n, t) { return n(t); }, M = function (n, t) { return n(t); }, F = function (n, t) { return n(t); }, W = function (n, t) { return n < t; }, D = function (n, t) { return n(t); }, Z = function (n, t) { return n(t); }, H = function (n, t) { return n(t); }, G = function (n, t) { return n(t); }, U = function (n, t) { return n(t); }, B = function (n, t) { return n(t); }, $ = function (n, t) { return n(t); }, Y = function (n, t) { return n(t); }, X = function (n, t) { return n(t); }, J = function (n, t) { return n(t); }, z = function (n, t) { return n === t; }, q = function (n, t) { return n(t); }, K = function (n, t) { return n(t); }, Q = function (n, t) { return n(t); }, nn = function (n, t) { return n(t); }, tn = function (n, t) { return n(t); }, en = function (n, t) { return n(t); }, rn = function (n, t) { return n + t; }, on = function (n, t) { return n + t; }, un = function (n, t) { return n(t); }, cn = function (n, t) { return n * t; }, sn = function (n, t) { return n + t; }, an = function (n, t) { return n + t; }, ln = function (n, t) { return n(t); }, fn = function (n, t) { return n(t); }, dn = function (n, t) { return n < t; }, mn = function (n, t) { return n(t); }, vn = function (n, t) { return n(t); }, hn = function (n, t) { return n * t; }, pn = function (n, t) { return n * t; }, gn = function (n, t) { return n + t; }, wn = function (n, t) { return n + t; }, yn = function (n, t) { return n + t; }, bn = await n[f(get_s70_related_msg, 6)]({ requiredFeatures: t }), En = Math.PI, Rn = [ [0, 1, 0, convertToIUint8Array(En, 7)], [1, 0, 0, convertToIUint8Array(En, 8)], [0, 1, 1, convertToIUint8Array(En, 4)], [1, 2, 1, convertToIUint8Array(En, 8)], ], Sn = Rn.length, In = new Uint8Array(i(Sn, m(m(16, xa), 8))), kn = navigator[v(get_s70_related_msg, 0)][o(get_s70_related_msg, 7)](); e[a(get_s70_related_msg, 8)]({ device: bn, format: kn }); const An = bn[h(get_s70_related_msg, 9)]({ label: p(get_s70_related_msg, 10), code: g(get_s70_related_msg, 11) }), Ln = bn[w(get_s70_related_msg, 12)]({ label: s(get_s70_related_msg, 13), layout: y(get_s70_related_msg, 14), vertex: { module: An }, fragment: { module: An, targets: [{ format: kn }] }, primitive: b(get_s70_related_msg, 15), }), Cn = [ [255, 0, 0, 255], [0, 255, 0, 255], [0, 0, 255, 255], ], Pn = new Uint8Array( v(Array, i(7, 9)) .fill(void 0) .map((n, t) => Cn[t % 3]) .flat(), ), Tn = bn[u(get_s70_related_msg, 16)]({ label: s(get_s70_related_msg, 17), size: [7, 9], format: w(get_s70_related_msg, 18), usage: E(window[S(get_s70_related_msg, 19)][I(get_s70_related_msg, 20)], window[c(get_s70_related_msg, 19)][o(get_s70_related_msg, 21)]), }); bn[k(get_s70_related_msg, 22)][A(get_s70_related_msg, 23)]( { texture: Tn }, Pn, { bytesPerRow: i(7, 4) }, { width: 7, height: 9 }, ); const On = bn[L(get_s70_related_msg, 24)](C(get_s70_related_msg, 25)), _n = bn[P(get_s70_related_msg, 26)]({ layout: Ln[s(get_s70_related_msg, 27)](0), entries: [ { binding: 0, resource: On }, { binding: 1, resource: Tn[c(get_s70_related_msg, 28)]() }, ], }), xn = Rn.map((n) => { const t = bn[r(get_s70_related_msg, 29)]({ label: o(get_s70_related_msg, 30), size: i(4, Float32Array[u(get_s70_related_msg, 31)]), usage: window[c(get_s70_related_msg, 32)][s(get_s70_related_msg, 33)], mappedAtCreation: true, }); return ( new Float32Array(t[u(get_s70_related_msg, 34)]())[a(get_s70_related_msg, 35)](n), t[o(get_s70_related_msg, 36)](), bn[a(get_s70_related_msg, 26)]({ layout: Ln[l(get_s70_related_msg, 27)](1), entries: [{ binding: 0, resource: { buffer: t } }], }) ); }), Nn = bn[T(get_s70_related_msg, 37)](O(get_s70_related_msg, 38)), jn = bn[b(get_s70_related_msg, 29)]({ size: _(Nn[x(get_s70_related_msg, 39)], 8), usage: E(window[k(get_s70_related_msg, 32)][N(get_s70_related_msg, 40)], window[j(get_s70_related_msg, 32)][P(get_s70_related_msg, 41)]), }), Vn = bn[j(get_s70_related_msg, 29)]({ size: i(jn[N(get_s70_related_msg, 42)], Sn), usage: E(window[L(get_s70_related_msg, 32)][V(get_s70_related_msg, 21)], window[M(get_s70_related_msg, 32)][M(get_s70_related_msg, 43)]), }), Mn = { label: S(get_s70_related_msg, 44), colorAttachments: F(get_s70_related_msg, 45), timestampWrites: { querySet: Nn, beginningOfPassWriteIndex: 0, endOfPassWriteIndex: 1, }, }; for (let R = 0; W(R, xn.length); R++) { const n = xn[R]; Mn[w(get_s70_related_msg, 46)][0][D(get_s70_related_msg, 47)] = e[u(get_s70_related_msg, 48)]()[Z(get_s70_related_msg, 28)](); const t = bn[H(get_s70_related_msg, 49)](M(get_s70_related_msg, 50)), r = t[G(get_s70_related_msg, 51)](Mn); (r[c(get_s70_related_msg, 52)](Ln), r[g(get_s70_related_msg, 53)](0, _n), r[U(get_s70_related_msg, 53)](1, n)); const o = window[B(get_s70_related_msg, 54)][B(get_s70_related_msg, 55)](); (r[$(get_s70_related_msg, 56)](48), r[Y(get_s70_related_msg, 57)](), t[X(get_s70_related_msg, 58)](Nn, 0, Nn[J(get_s70_related_msg, 39)], jn, 0), z(Vn[q(get_s70_related_msg, 59)], K(get_s70_related_msg, 60)) && t[Q(get_s70_related_msg, 61)](jn, 0, Vn, i(R, 16), jn[H(get_s70_related_msg, 42)])); const s = t[$(get_s70_related_msg, 62)](); bn[nn(get_s70_related_msg, 22)][A(get_s70_related_msg, 63)]([s]); const a = tn(ja, e[en(get_s70_related_msg, 2)]); (In[K(get_s70_related_msg, 35)](a, m(8, _(R, rn(on(16, xa), 8)))), In[un(get_s70_related_msg, 35)]( new Uint8Array(new Float64Array([o])[w(get_s70_related_msg, 64)]), cn(R, sn(an(16, xa), 8)), )); } if (z(Vn[ln(get_s70_related_msg, 59)], l(get_s70_related_msg, 60))) { await Vn[$(get_s70_related_msg, 65)](window[fn(get_s70_related_msg, 66)][l(get_s70_related_msg, 67)]); const n = Vn[N(get_s70_related_msg, 34)](), t = new Uint8Array(n); for (let e = 0; dn(e, Sn); e++) In[mn(get_s70_related_msg, 35)]( t[vn(get_s70_related_msg, 68)](hn(e, xa), pn(gn(e, 1), xa)), wn(rn(8, 16), _(e, m(yn(16, xa), 8))), ); Vn[mn(get_s70_related_msg, 36)](); } return fn(R, In); } function ja(n) { return (function (n, t) { return n(t); })( T, (function (n, t) { return n(t); })( murmurHash3, n[ (function (n, t) { return n(t); })(get_s70_related_msg, 69) ](), ), ); } async function Va(n) { const t = function (n, t) { return n !== t; }, e = function (n, t) { return n(t); }; var r; return (function (n, t) { return n !== t; })( (r = n[ (function (n, t) { return n(t); })(get_s70_related_msg, 70) ]), null, ) && t(r, void 0) ? r : await n[e(get_s70_related_msg, 71)](); } const Ma = /*#__PURE__*/ new RegExp( /*#__PURE__*/ encrypted_msg_getter( [ 39174333, 51812406, 885210665, 4099360837, 1242130291, 1365653239, 2003041115, 1707369036, 3273002536, 359933e3, 1948332465, ], 5, )(0), ); function s70_worker() { const run_func = function (n) { return n(); }, not_equal = function (n, t) { return n !== t; }, run_2arg_func = function (n, t, e) { return n(t, e); }, run_2arg_func_ = function (n, t, e) { return n(t, e); }, run_2arg_func__ = function (n, t, e) { return n(t, e); }, a_is_insof_b = function (n, t) { return n instanceof t; }, run_1arg_func = function (n, t) { return n(t); }; return run_2arg_func_( prepareRace, (function (n, t, e) { return n(t, e); })(runCallbackWhenPageFocusedPromise, 1e3, { s: -2, v: null }), async () => { const r = await run_func(get_gpu_requestAdapter); if (not_equal(run_2arg_func(get_property_byHash_then_bind, r, 453955339), 0)) return r; // s try { const [requestAdapter, t] = run_2arg_func(get_property_byHash_then_bind, r, 1801730948), [u, c, s] = await run_2arg_func(_a, requestAdapter, t); return { s: 0, v: { s: s, f: u, v: run_2arg_func_(get_property_byHash_then_bind, c, 4112659446), a: run_2arg_func__(get_property_byHash_then_bind, c, 1956208378) }, }; } catch (c) { if (a_is_insof_b(c, TypeError) && run_1arg_func(Da, run_2arg_func(get_property_byHash_then_bind, c, 3065852031))) return { s: -7, v: null }; throw c; } }, ); } async function get_gpu_requestAdapter() { const run2arg_func = function (n, t, e) { return n(t, e); }, a_is_insof_b = function (n, t) { return n instanceof t; }, run_func = function (n) { return n(); }, run_func__ = function (n) { return n(); }, gpu = run2arg_func(get_property_byHash_then_bind, navigator, 3179935986); // gpu if (!gpu) return { s: -3, v: null }; let requestAdapter = null; try { requestAdapter = await run2arg_func(get_property_byHash_then_bind, gpu, 1678473624)(); //requestAdapter } catch (c) { if (a_is_insof_b(c, Error) && run_func(collectSomeKeys1_related_to_firefox)) return { s: -3, v: run2arg_func(get_property_byHash_then_bind, c, 3065852031) }; throw c; } if (!requestAdapter) return { s: -4, v: null }; if (!run_func(Ta)) return { s: -1, v: null }; const u = run_func__(Oa); return u ? { s: 0, v: [requestAdapter, u] } : { s: -5, v: null }; } function Da(n) { const t = function (n, t) { return n === t; }, e = function (n, t) { return n(t); }, r = n.match(Ma); return !!r && t(e(getHash, r[1]), 4169850297); } function get_timeStamp() { var n; return { s: 0, v: null !== (n = performance.timeOrigin) && void 0 !== n ? n : Date.now() - performance.now(), }; } function tls_worker(n, t, e, r, o, i) { const u = r ? [] : (function (n, t, e) { return (function (n, t) { const e = function (n, t, e) { return n(t, e); }, r = function (n, t) { return n(t); }, o = function (n, t) { return n(t); }, i = Array.isArray(n) ? n : [n], u = []; for (const c of i) if (e(Zi, c, Bt)) for (const n of t) u.push(r(Vi, n)); else u.push(o(String, c)); return u; })(n, t).map((n) => Sr(n, { q: e })); })(n, t, e); if (0 === u.length) return () => Promise.resolve({ s: -1, v: null }); xr(i, () => ({ e: 6 })); const c = s(), a = Lr(c), l = Date.now(), f = ko(u, qa.bind(null, 5e3, i, a), Ka, Math.max(10, u.length), o); return ( f.then( () => c.resolve(), () => c.resolve(), ), async function (n, t, e, r) { if (e) return { s: -1, v: null }; try { await Promise.race([f, Qa(l, n, t)]); const e = (function ({ result: n, failedAttempts: t }) { if (void 0 !== n) return n; const e = t[0]; if (!e) return { s: -3, v: null }; if (1 === e.level) return e.error; const { error: r, endpoint: o } = e; if (r instanceof Error) { const { name: n, message: t } = r; switch (n) { case \"AbortError\": return { s: -2, v: t }; case \"TimeoutError\": return { s: -3, v: t }; case \"CSPError\": return { s: -6, v: t }; case \"InvalidURLError\": return { s: -7, v: `Invalid URL: ${Ve(o, 255)}` }; case \"TypeError\": return { s: -4, v: t }; } } return ai(r); })(f.current); return (xr(r, () => ({ e: 7, result: e })), e); } catch (o) { throw (xr(r, () => ({ e: 8, error: o })), o); } } ); } function qa(n, t, e, r, o, i) { return Nr( t, () => ({ e: 9, tryNumber: o, url: r, timeout: n }), ({ status: n, getHeader: t, body: e }) => ({ e: 10, tryNumber: o, status: n, retryAfter: t(\"retry-after\"), body: e, }), (n) => ({ e: 11, tryNumber: o, error: n }), () => Ar({ url: r, timeout: n, abort: i, container: e }), ); } function Ka({ status: n, body: t }) { if (200 === n && /^[a-zA-Z0-9+/]{1,1022}={0,2}$/.test(t)) return { result: { s: 0, v: t } }; return { error: { s: -5, v: Ve(`${n}: ${t}`, 255) } }; } function Qa(n, t, e) { return runCallbackWhenPageFocusedPromise(Math.min(Math.max(t, n + 1e4 - Date.now()), e)); } function get__vid_t(n) { const t = add_t(n); let [e, r] = (function (n) { return [get_cookie_value(n), get_localStorage_value(n)]; // _vid_t })(t); return ( (e = shorter_than_1e3(e)), (r = shorter_than_1e3(r)), void 0 !== e && void 0 !== r ? { s: 0, v: e || r } : void 0 !== e ? { s: 1, v: e } : void 0 !== r ? { s: 2, v: r } : { s: -1, v: null } ); } function shorter_than_1e3(n) { return n && n.length","link":"/gallery/files/fingerprint-js/fYicOuiT1WRGwuZgAESv.js"}]}